// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Experience interface {
	IsExperience()
	GetYearsOfExperience() float64
}

type Hobby interface {
	IsHobby()
	GetEmployees() []*Employee
}

type Country struct {
	Key *CountryKey `json:"key"`
}

func (Country) IsEntity() {}

type CountryKey struct {
	Name string `json:"name"`
}

type Employee struct {
	ID      int     `json:"id"`
	Hobbies []Hobby `json:"hobbies,omitempty"`
}

func (Employee) IsEntity() {}

type Exercise struct {
	Employees []*Employee  `json:"employees"`
	Category  ExerciseType `json:"category"`
}

func (Exercise) IsHobby() {}
func (this Exercise) GetEmployees() []*Employee {
	if this.Employees == nil {
		return nil
	}
	interfaceSlice := make([]*Employee, 0, len(this.Employees))
	for _, concrete := range this.Employees {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Flying struct {
	Employees         []*Employee `json:"employees"`
	PlaneModels       []string    `json:"planeModels"`
	YearsOfExperience float64     `json:"yearsOfExperience"`
}

func (Flying) IsExperience()                      {}
func (this Flying) GetYearsOfExperience() float64 { return this.YearsOfExperience }

func (Flying) IsHobby() {}
func (this Flying) GetEmployees() []*Employee {
	if this.Employees == nil {
		return nil
	}
	interfaceSlice := make([]*Employee, 0, len(this.Employees))
	for _, concrete := range this.Employees {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Gaming struct {
	Employees         []*Employee `json:"employees"`
	Genres            []GameGenre `json:"genres"`
	Name              string      `json:"name"`
	YearsOfExperience float64     `json:"yearsOfExperience"`
}

func (Gaming) IsExperience()                      {}
func (this Gaming) GetYearsOfExperience() float64 { return this.YearsOfExperience }

func (Gaming) IsHobby() {}
func (this Gaming) GetEmployees() []*Employee {
	if this.Employees == nil {
		return nil
	}
	interfaceSlice := make([]*Employee, 0, len(this.Employees))
	for _, concrete := range this.Employees {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Other struct {
	Employees []*Employee `json:"employees"`
	Name      string      `json:"name"`
}

func (Other) IsHobby() {}
func (this Other) GetEmployees() []*Employee {
	if this.Employees == nil {
		return nil
	}
	interfaceSlice := make([]*Employee, 0, len(this.Employees))
	for _, concrete := range this.Employees {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Programming struct {
	Employees []*Employee           `json:"employees"`
	Languages []ProgrammingLanguage `json:"languages"`
}

func (Programming) IsHobby() {}
func (this Programming) GetEmployees() []*Employee {
	if this.Employees == nil {
		return nil
	}
	interfaceSlice := make([]*Employee, 0, len(this.Employees))
	for _, concrete := range this.Employees {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Query struct {
}

type Sdk struct {
	Upc             string                `json:"upc"`
	ClientLanguages []ProgrammingLanguage `json:"clientLanguages"`
}

func (Sdk) IsEntity() {}

type Subscription struct {
}

type Travelling struct {
	Employees      []*Employee `json:"employees"`
	CountriesLived []*Country  `json:"countriesLived"`
}

func (Travelling) IsHobby() {}
func (this Travelling) GetEmployees() []*Employee {
	if this.Employees == nil {
		return nil
	}
	interfaceSlice := make([]*Employee, 0, len(this.Employees))
	for _, concrete := range this.Employees {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type ExerciseType string

const (
	ExerciseTypeCalisthenics     ExerciseType = "CALISTHENICS"
	ExerciseTypeHiking           ExerciseType = "HIKING"
	ExerciseTypeSport            ExerciseType = "SPORT"
	ExerciseTypeStrengthTraining ExerciseType = "STRENGTH_TRAINING"
)

var AllExerciseType = []ExerciseType{
	ExerciseTypeCalisthenics,
	ExerciseTypeHiking,
	ExerciseTypeSport,
	ExerciseTypeStrengthTraining,
}

func (e ExerciseType) IsValid() bool {
	switch e {
	case ExerciseTypeCalisthenics, ExerciseTypeHiking, ExerciseTypeSport, ExerciseTypeStrengthTraining:
		return true
	}
	return false
}

func (e ExerciseType) String() string {
	return string(e)
}

func (e *ExerciseType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ExerciseType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ExerciseType", str)
	}
	return nil
}

func (e ExerciseType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GameGenre string

const (
	GameGenreAdventure  GameGenre = "ADVENTURE"
	GameGenreBoard      GameGenre = "BOARD"
	GameGenreFps        GameGenre = "FPS"
	GameGenreCard       GameGenre = "CARD"
	GameGenreRpg        GameGenre = "RPG"
	GameGenreRoguelite  GameGenre = "ROGUELITE"
	GameGenreSimulation GameGenre = "SIMULATION"
	GameGenreStrategy   GameGenre = "STRATEGY"
)

var AllGameGenre = []GameGenre{
	GameGenreAdventure,
	GameGenreBoard,
	GameGenreFps,
	GameGenreCard,
	GameGenreRpg,
	GameGenreRoguelite,
	GameGenreSimulation,
	GameGenreStrategy,
}

func (e GameGenre) IsValid() bool {
	switch e {
	case GameGenreAdventure, GameGenreBoard, GameGenreFps, GameGenreCard, GameGenreRpg, GameGenreRoguelite, GameGenreSimulation, GameGenreStrategy:
		return true
	}
	return false
}

func (e GameGenre) String() string {
	return string(e)
}

func (e *GameGenre) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GameGenre(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GameGenre", str)
	}
	return nil
}

func (e GameGenre) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProgrammingLanguage string

const (
	ProgrammingLanguageCsharp     ProgrammingLanguage = "CSHARP"
	ProgrammingLanguageGo         ProgrammingLanguage = "GO"
	ProgrammingLanguageRust       ProgrammingLanguage = "RUST"
	ProgrammingLanguageTypescript ProgrammingLanguage = "TYPESCRIPT"
)

var AllProgrammingLanguage = []ProgrammingLanguage{
	ProgrammingLanguageCsharp,
	ProgrammingLanguageGo,
	ProgrammingLanguageRust,
	ProgrammingLanguageTypescript,
}

func (e ProgrammingLanguage) IsValid() bool {
	switch e {
	case ProgrammingLanguageCsharp, ProgrammingLanguageGo, ProgrammingLanguageRust, ProgrammingLanguageTypescript:
		return true
	}
	return false
}

func (e ProgrammingLanguage) String() string {
	return string(e)
}

func (e *ProgrammingLanguage) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProgrammingLanguage(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProgrammingLanguage", str)
	}
	return nil
}

func (e ProgrammingLanguage) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
