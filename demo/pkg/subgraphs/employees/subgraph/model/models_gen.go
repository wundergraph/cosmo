// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
)

type IProduct interface {
	IsIProduct()
	GetUpc() string
	GetEngineers() []*Employee
}

type Identifiable interface {
	IsIdentifiable()
	GetID() int
}

type Products interface {
	IsProducts()
}

type RoleType interface {
	IsRoleType()
	GetDepartments() []Department
	GetTitle() []string
	GetEmployees() []*Employee
}

type City struct {
	Type    string   `json:"type"`
	Name    string   `json:"name"`
	Country *Country `json:"country,omitempty"`
}

type Consultancy struct {
	Upc             string    `json:"upc"`
	Lead            *Employee `json:"lead"`
	IsLeadAvailable *bool     `json:"isLeadAvailable,omitempty"`
}

func (Consultancy) IsProducts() {}

func (Consultancy) IsEntity() {}

type Cosmo struct {
	Upc             string      `json:"upc"`
	Engineers       []*Employee `json:"engineers"`
	Lead            *Employee   `json:"lead"`
	IsLeadAvailable *bool       `json:"isLeadAvailable,omitempty"`
}

func (Cosmo) IsProducts() {}

func (Cosmo) IsIProduct()         {}
func (this Cosmo) GetUpc() string { return this.Upc }
func (this Cosmo) GetEngineers() []*Employee {
	if this.Engineers == nil {
		return nil
	}
	interfaceSlice := make([]*Employee, 0, len(this.Engineers))
	for _, concrete := range this.Engineers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Cosmo) IsEntity() {}

type Country struct {
	Key *CountryKey `json:"key"`
}

func (Country) IsEntity() {}

type CountryKey struct {
	Name string `json:"name"`
}

type DeeplyNestedFileUpload struct {
	File graphql.Upload `json:"file"`
}

type Details struct {
	Forename      string   `json:"forename"`
	Location      *Country `json:"location"`
	Surname       string   `json:"surname"`
	PastLocations []*City  `json:"pastLocations"`
}

type Employee struct {
	Details               *Details      `json:"details"`
	ID                    int           `json:"id"`
	Tag                   string        `json:"tag"`
	Role                  RoleType      `json:"role"`
	Notes                 *string       `json:"notes,omitempty"`
	UpdatedAt             string        `json:"updatedAt"`
	StartDate             string        `json:"startDate"`
	CurrentMood           Mood          `json:"currentMood"`
	DerivedMood           Mood          `json:"derivedMood"`
	IsAvailable           *bool         `json:"isAvailable,omitempty"`
	RootFieldThrowsError  *string       `json:"rootFieldThrowsError,omitempty"`
	RootFieldErrorWrapper *ErrorWrapper `json:"rootFieldErrorWrapper,omitempty"`
}

func (Employee) IsIdentifiable() {}
func (this Employee) GetID() int { return this.ID }

func (Employee) IsEntity() {}

type Engineer struct {
	Departments  []Department `json:"departments"`
	Title        []string     `json:"title"`
	Employees    []*Employee  `json:"employees"`
	EngineerType EngineerType `json:"engineerType"`
}

func (Engineer) IsRoleType() {}
func (this Engineer) GetDepartments() []Department {
	if this.Departments == nil {
		return nil
	}
	interfaceSlice := make([]Department, 0, len(this.Departments))
	for _, concrete := range this.Departments {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this Engineer) GetTitle() []string {
	if this.Title == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Title))
	for _, concrete := range this.Title {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this Engineer) GetEmployees() []*Employee {
	if this.Employees == nil {
		return nil
	}
	interfaceSlice := make([]*Employee, 0, len(this.Employees))
	for _, concrete := range this.Employees {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type ErrorWrapper struct {
	OkField    *string `json:"okField,omitempty"`
	ErrorField *string `json:"errorField,omitempty"`
}

type FileUpload struct {
	Nested     *DeeplyNestedFileUpload `json:"nested,omitempty"`
	NestedList []*graphql.Upload       `json:"nestedList,omitempty"`
}

type Marketer struct {
	Departments []Department `json:"departments"`
	Title       []string     `json:"title"`
	Employees   []*Employee  `json:"employees"`
}

func (Marketer) IsRoleType() {}
func (this Marketer) GetDepartments() []Department {
	if this.Departments == nil {
		return nil
	}
	interfaceSlice := make([]Department, 0, len(this.Departments))
	for _, concrete := range this.Departments {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this Marketer) GetTitle() []string {
	if this.Title == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Title))
	for _, concrete := range this.Title {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this Marketer) GetEmployees() []*Employee {
	if this.Employees == nil {
		return nil
	}
	interfaceSlice := make([]*Employee, 0, len(this.Employees))
	for _, concrete := range this.Employees {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Mutation struct {
}

type Operator struct {
	Departments  []Department    `json:"departments"`
	Title        []string        `json:"title"`
	Employees    []*Employee     `json:"employees"`
	OperatorType []OperationType `json:"operatorType"`
}

func (Operator) IsRoleType() {}
func (this Operator) GetDepartments() []Department {
	if this.Departments == nil {
		return nil
	}
	interfaceSlice := make([]Department, 0, len(this.Departments))
	for _, concrete := range this.Departments {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this Operator) GetTitle() []string {
	if this.Title == nil {
		return nil
	}
	interfaceSlice := make([]string, 0, len(this.Title))
	for _, concrete := range this.Title {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this Operator) GetEmployees() []*Employee {
	if this.Employees == nil {
		return nil
	}
	interfaceSlice := make([]*Employee, 0, len(this.Employees))
	for _, concrete := range this.Employees {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Query struct {
}

type Sdk struct {
	Upc       string      `json:"upc"`
	Engineers []*Employee `json:"engineers"`
	Owner     *Employee   `json:"owner"`
	Unicode   string      `json:"unicode"`
}

func (Sdk) IsProducts() {}

func (Sdk) IsIProduct()         {}
func (this Sdk) GetUpc() string { return this.Upc }
func (this Sdk) GetEngineers() []*Employee {
	if this.Engineers == nil {
		return nil
	}
	interfaceSlice := make([]*Employee, 0, len(this.Engineers))
	for _, concrete := range this.Engineers {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

func (Sdk) IsEntity() {}

type Subscription struct {
}

type Time struct {
	UnixTime  int    `json:"unixTime"`
	TimeStamp string `json:"timeStamp"`
}

type Department string

const (
	DepartmentEngineering Department = "ENGINEERING"
	DepartmentMarketing   Department = "MARKETING"
	DepartmentOperations  Department = "OPERATIONS"
)

var AllDepartment = []Department{
	DepartmentEngineering,
	DepartmentMarketing,
	DepartmentOperations,
}

func (e Department) IsValid() bool {
	switch e {
	case DepartmentEngineering, DepartmentMarketing, DepartmentOperations:
		return true
	}
	return false
}

func (e Department) String() string {
	return string(e)
}

func (e *Department) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Department(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Department", str)
	}
	return nil
}

func (e Department) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Department) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Department) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EngineerType string

const (
	EngineerTypeBackend   EngineerType = "BACKEND"
	EngineerTypeFrontend  EngineerType = "FRONTEND"
	EngineerTypeFullstack EngineerType = "FULLSTACK"
)

var AllEngineerType = []EngineerType{
	EngineerTypeBackend,
	EngineerTypeFrontend,
	EngineerTypeFullstack,
}

func (e EngineerType) IsValid() bool {
	switch e {
	case EngineerTypeBackend, EngineerTypeFrontend, EngineerTypeFullstack:
		return true
	}
	return false
}

func (e EngineerType) String() string {
	return string(e)
}

func (e *EngineerType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EngineerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EngineerType", str)
	}
	return nil
}

func (e EngineerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EngineerType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EngineerType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Mood string

const (
	MoodHappy Mood = "HAPPY"
	MoodSad   Mood = "SAD"
)

var AllMood = []Mood{
	MoodHappy,
	MoodSad,
}

func (e Mood) IsValid() bool {
	switch e {
	case MoodHappy, MoodSad:
		return true
	}
	return false
}

func (e Mood) String() string {
	return string(e)
}

func (e *Mood) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Mood(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Mood", str)
	}
	return nil
}

func (e Mood) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Mood) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Mood) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OperationType string

const (
	OperationTypeFinance        OperationType = "FINANCE"
	OperationTypeHumanResources OperationType = "HUMAN_RESOURCES"
)

var AllOperationType = []OperationType{
	OperationTypeFinance,
	OperationTypeHumanResources,
}

func (e OperationType) IsValid() bool {
	switch e {
	case OperationTypeFinance, OperationTypeHumanResources:
		return true
	}
	return false
}

func (e OperationType) String() string {
	return string(e)
}

func (e *OperationType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationType", str)
	}
	return nil
}

func (e OperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OperationType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OperationType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
