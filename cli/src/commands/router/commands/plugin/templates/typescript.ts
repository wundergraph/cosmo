// Templates for typescript (templating is done by pupa)
// This file is auto-generated. Do not edit manually.
/* eslint-disable no-template-curly-in-string */

const dockerfileTs =
  'FROM --platform=$BUILDPLATFORM oven/bun:1.3.0-alpine AS builder\n\n# Multi-platform build arguments\nARG TARGETOS\nARG TARGETARCH\n\nWORKDIR /build\n\n# Copy package files\nCOPY package.json bun.lock* ./\n\n# Install dependencies\nRUN bun install\n\n# Copy all source code\nCOPY src/ ./src/\nCOPY generated/ ./generated/\n\n# Set BUN_TARGET based on OS and architecture\nRUN BUN_TARGET="bun-$TARGETOS-$([ "$TARGETARCH" = "amd64" ] && echo "x64" || echo "$TARGETARCH")" && \\\n    echo "Building for $BUN_TARGET" && \\\n    bun build src/plugin.ts --compile --outfile bin/plugin --target=$BUN_TARGET\n\nFROM --platform=$BUILDPLATFORM scratch\n\nCOPY --from=builder /build/bin/plugin ./{originalPluginName}-plugin\n\nENTRYPOINT ["./{originalPluginName}-plugin"]\n\n';

const fsPolyfill =
  "import * as fs from 'fs';\n\n// Polyfill for protobufjs which fails to load fs in bundled binaries\n// protobufjs uses eval(\"require\")(\"fs\") which returns null in Bun compiled binaries\n// We need to patch util.fs after protobufjs loads but before it's used\n\n// Import protobufjs util and patch it\n// Side-effect import to ensure google-protobuf is loaded\nimport 'google-protobuf';\n\n// Try to find and patch protobufjs's util.fs\ntry {\n  // Look for protobufjs in the bundled modules\n  const protobufUtil = (globalThis as any).protobuf?.util;\n  if (protobufUtil) {\n    protobufUtil.fs = fs;\n  }\n\n  // Also try to patch via require if available\n  if (typeof require !== 'undefined') {\n    try {\n      const util = require('protobufjs/src/util');\n      if (util) {\n        util.fs = fs;\n      }\n    } catch {\n      // Module might not be available\n    }\n  }\n} catch (e) {\n  if (process.env.DEBUG) {\n    console.error('[fsPolyfill] Warning: Failed to patch protobufjs util.fs:', e);\n  }  \n}\n\n";

const packageJson =
  '{\n  "name": "plugin-bun",\n  "version": "1.0.0",\n  "description": "gRPC Plugin using Bun runtime",\n  "type": "module",\n  "scripts": {\n    "build": "bun build src/plugin.ts --compile --outfile bin/plugin",\n    "dev": "bun run src/plugin.ts",\n    "postinstall": "bun ./node_modules/@protocolbuffers/protoc-gen-js/download-protoc-gen-js.js"\n  },\n  "dependencies": {\n    "@grpc/grpc-js": "^1.14.0",\n    "google-protobuf": "^4.0.0",\n    "grpc-health-check": "^2.0.0"\n  },\n  "devDependencies": {\n    "@protocolbuffers/protoc-gen-js": "4.0.0",\n    "@types/bun": "^1.3.1",\n    "@types/google-protobuf": "^3.20.0",\n    "@types/node": "^20.11.5",\n    "grpc-tools": "^1.12.4",\n    "grpc_tools_node_protoc_ts": "^5.3.3"\n  }\n}\n\n';

const pluginServerTs =
  "// MUST be imported first to polyfill fs for protobufjs\nimport './fs-polyfill';\n\nimport * as grpc from '@grpc/grpc-js';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { HealthImplementation } from 'grpc-health-check';\n\n/**\n * Plugin server that manages gRPC server with Unix domain socket\n */\nexport class PluginServer {\n    private readonly socketPath: string;\n    private readonly network: string = 'unix';\n\n    private server: grpc.Server;\n    private healthImpl: HealthImplementation;\n\n    constructor(socketDir: string = os.tmpdir()) {\n        // Generate a unique temporary file path\n        const tempPath = path.join(socketDir, `plugin_${Date.now()}${Math.floor(Math.random() * 1000000)}`);\n        this.socketPath = tempPath;\n\n        // Ensure the socket file doesn't exist\n        if (fs.existsSync(tempPath)) {\n            fs.unlinkSync(tempPath);\n        }\n\n        // Create the gRPC server\n        this.server = new grpc.Server();\n\n        // Initialize health check service with overall server status and plugin service\n        this.healthImpl = new HealthImplementation();\n        this.healthImpl.addToServer(this.server);\n        this.healthImpl.setStatus('plugin', 'SERVING');\n    }\n\n    /**\n     * Add a service implementation to the server\n     */\n    public addService(service: grpc.ServiceDefinition, implementation: grpc.UntypedServiceImplementation): void {\n        this.server.addService(service, implementation);\n    }\n\n    /**\n     * Start the server and output handshake information for go-plugin\n     */\n    public serve(): Promise<void> {\n        const address = this.network + \"://\" + this.socketPath;\n\n        return new Promise<void>((resolve, reject) => {\n            this.server.bindAsync(\n                address,\n                grpc.ServerCredentials.createInsecure(),\n                (error, port) => {\n                    if (error) {\n                        reject(error);\n                        return;\n                    }\n\n                    // Output the handshake information for go-plugin\n                    // Format: VERSION|PROTOCOL_VERSION|NETWORK|ADDRESS|PROTOCOL\n                    const logEntry = \"1|1|\" +this.network + \"|\" + this.socketPath + \"|grpc\";\n                    console.log(logEntry);\n\n                    resolve();\n                }\n            );\n        });\n    }\n}\n\n";

const pluginTestTs =
  'import { describe, test, expect } from "bun:test";\nimport * as grpc from "@grpc/grpc-js";\nimport type { Subprocess } from "bun";\n\n// Generated gRPC types\nimport { {serviceName}ServiceClient } from \'../generated/service_grpc_pb.js\';\nimport { QueryHelloRequest, QueryHelloResponse } from "../generated/service_pb.js";\n\nfunction queryHello(client: {serviceName}ServiceClient, name: string): Promise<QueryHelloResponse> {\n  return new Promise((resolve, reject) => {\n    const req = new QueryHelloRequest();\n    req.setName(name);\n    client.queryHello(req, (err, resp) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      if (!resp) {\n        reject(new Error("empty response"));\n        return;\n      }\n      resolve(resp);\n    });\n  });\n}\n\ndescribe("{serviceName}Service.queryHello", () => {\n  test("returns greeting with sequential world IDs", async () => {\n    const [subprocess, address] = await startPluginProcess();\n    const client = createClient(address);\n    try {\n      const cases = [\n        { name: "Alice", wantId: "world-1", wantName: "Hello from {serviceName}Service plugin! Alice" },\n        { name: "", wantId: "world-2", wantName: "Hello from {serviceName}Service plugin! " },\n        { name: "John & Jane", wantId: "world-3", wantName: "Hello from {serviceName}Service plugin! John & Jane" },\n      ];\n\n      for (const c of cases) {\n        const resp = await queryHello(client, c.name);\n        const world = resp.getHello();\n        expect(world).toBeTruthy();\n        expect(world!.getId()).toBe(c.wantId);\n        expect(world!.getName()).toBe(c.wantName);\n      }\n    } finally {\n      client.close();\n      subprocess.kill();\n    }\n  });\n\n  test("IDs increment across multiple requests in a fresh process", async () => {\n    const [subprocess, address] = await startPluginProcess();\n    const client = createClient(address);\n    try {\n      const first = await queryHello(client, "First");\n      expect(first.getHello()!.getId()).toBe("world-1");\n\n      const second = await queryHello(client, "Second");\n      expect(second.getHello()!.getId()).toBe("world-2");\n\n      const third = await queryHello(client, "Third");\n      expect(third.getHello()!.getId()).toBe("world-3");\n    } finally {\n      client.close();\n      subprocess.kill();\n    }\n  });\n});\n\n\nasync function startPluginProcess(): Promise<[Subprocess, string]> {\n  const proc = Bun.spawn(["bun", "run", "src/plugin.ts"], {\n    stdout: "pipe",\n    stderr: "inherit",\n  });\n\n  // Read the first line from stdout and parse the address\n  if (!proc.stdout) {\n    throw new Error("plugin stdout not available");\n  }\n  const reader = proc.stdout.getReader();\n  const decoder = new TextDecoder();\n  const { value } = await reader.read();\n  reader.releaseLock();\n\n  const text = decoder.decode(value ?? new Uint8Array());\n  const firstLine = text.split("\\n")[0]?.trim() ?? "";\n  const parts = firstLine.split("|");\n  const address = parts[3];\n\n  return [proc, address];\n}\n\nfunction createClient(address: string): {serviceName}ServiceClient {\n  const target = `unix://${address}`;\n  return new {serviceName}ServiceClient(target, grpc.credentials.createInsecure());\n}';

const pluginTs =
  "import * as grpc from '@grpc/grpc-js';\nimport { PluginServer } from './plugin-server';\n\n// Import generated gRPC code\nimport { \n  {serviceName}Service, \n  I{serviceName}Server \n} from '../generated/service_grpc_pb.js';\nimport { \n  QueryHelloRequest, \n  QueryHelloResponse, \n  World \n} from '../generated/service_pb.js';\n\n// Counter for generating unique IDs\nlet counter = 0;\n\n// Define the service implementation using the generated types\nconst {serviceName}Implementation: I{serviceName}Server = {\n  queryHello: (call: grpc.ServerUnaryCall<QueryHelloRequest, QueryHelloResponse>, callback: grpc.sendUnaryData<QueryHelloResponse>) => {\n    const name = call.request.getName();\n\n    counter += 1;\n\n    const world = new World();\n    world.setId(`world-`+counter);\n    world.setName(`Hello from {serviceName} plugin! `+ name);\n\n    const response = new QueryHelloResponse();\n    response.setHello(world);\n\n    callback(null, response);\n  }\n};\n\nfunction run() {\n  // Create the plugin server (health check automatically initialized)\n  const pluginServer = new PluginServer();\n  \n  // Add the {serviceName} service\n  pluginServer.addService({serviceName}Service, {serviceName}Implementation);\n\n  // Start the server\n  pluginServer.serve().catch((error) => {\n    console.error('Failed to start plugin server:', error);\n    process.exit(1);\n  });\n}\n\nrun();\n\n";

const tsReadme =
  '## Getting Started\n\nPlugin structure:\n\n   ```\n    plugins/{originalPluginName}/\n    ├── package.json                # Package.json file with dependencies\n    ├── src/\n    │   ├── plugin.ts         # Main plugin implementation\n    │   ├── plugin.test.ts    # Main plugin implementation tests\n    │   ├── fs-polyfill.ts    # Polyfill to help bundling into a binary\n    │   ├── plugin-server.ts  # Used to initialize the plugin as a server\n    │   └── schema.graphql    # GraphQL schema defining the API\n    ├── generated/            # Generated code (created during build)\n    └── bin/                  # Compiled binaries (created during build)\n        └── plugin            # The compiled plugin binary\n   ```\n';

const tsconfig =
  '{\n  "compilerOptions": {\n    "strict": true,\n    "target": "ES2020",\n    "module": "ESNext",\n    "moduleResolution": "Bundler",\n    "esModuleInterop": true,\n    "skipLibCheck": true,\n    "types": ["bun"]\n  },\n  "include": ["src/**/*.ts"]\n}\n\n';

export default {
  dockerfileTs,
  fsPolyfill,
  packageJson,
  pluginServerTs,
  pluginTestTs,
  pluginTs,
  tsReadme,
  tsconfig,
};
