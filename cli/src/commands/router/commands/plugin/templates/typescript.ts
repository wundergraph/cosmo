// Templates for typescript (templating is done by pupa)
// This file is auto-generated. Do not edit manually.
/* eslint-disable no-template-curly-in-string */

const dockerfile =
  'FROM --platform=$BUILDPLATFORM oven/bun:1.3.0-alpine AS builder\n\n# Multi-platform build arguments\nARG TARGETOS\nARG TARGETARCH\n\nWORKDIR /build\n\n# Copy package files\nCOPY package.json bun.lock* ./\n\n# Install dependencies\nRUN bun install\n\n# Copy all source code\nCOPY src/ ./src/\nCOPY generated/ ./generated/\n\n# Set BUN_TARGET based on OS and architecture\nRUN BUN_TARGET="bun-$TARGETOS-$([ "$TARGETARCH" = "amd64" ] && echo "x64" || echo "$TARGETARCH")" && \\\n    echo "Building for $BUN_TARGET" && \\\n    bun build src/plugin.ts --compile --outfile bin/plugin --target=$BUN_TARGET\n\nFROM --platform=$BUILDPLATFORM scratch\n\nCOPY --from=builder /build/bin/plugin ./{originalPluginName}-plugin\n\nENTRYPOINT ["./{originalPluginName}-plugin"]\n\n';

const cursorRules =
  "---\ndescription: {name} Plugin Guide\nglobs: src/**\nalwaysApply: false\n---\n\n# {name} Plugin Development Guide\n\nYou are an expert in developing Cosmo Router plugins. You are given a GraphQL schema, and you need to implement the TypeScript code for the plugin.\nYour goal is to implement the plugin in a way that is easy to understand and maintain. You add tests to ensure the plugin works as expected.\n\nAll make commands need to be run from the plugin directory `{pluginDir}`.\n\n## Plugin Structure\n\nA plugin is structured as follows:\n\n```\nplugins/{originalPluginName}/\n├── Makefile                     # Build automation\n├── package.json                 # Node.js package definition\n├── tsconfig.json                # TypeScript configuration\n├── src/\n│   ├── schema.graphql           # GraphQL schema (API contract)\n│   ├── plugin.ts                # Plugin implementation\n│   ├── plugin.test.ts           # Tests for the plugin\n│   ├── plugin-server.ts         # gRPC server setup\n│   └── fs-polyfill.ts           # File system polyfill for bundling\n├── generated/                   # Auto-generated files (DO NOT EDIT)\n│   ├── service.proto            # Generated Protocol Buffers\n│   ├── service_pb.js            # Generated JavaScript structures\n│   ├── service_grpc_pb.js       # Generated gRPC service\n│   ├── service.proto.lock.json  # Generated Protobuf lock file\n│   └── service_pb.d.ts          # TypeScript definitions\n└── bin/                         # Compiled binaries\n    └── plugin                   # The compiled plugin binary\n```\n\n## Development Workflow\n\n1. When modifying the GraphQL schema in `src/schema.graphql`, you need to regenerate the code with `make generate`.\n2. Look into the generated code in `generated/service.proto`, `generated/service_pb.js`, and `generated/service_grpc_pb.js` to understand the updated API contract and service methods.\n3. Implement the new RPC methods in `src/plugin.ts`.\n4. Add tests to `src/plugin.test.ts` to ensure the plugin works as expected. You need to run `make test` to ensure the tests pass.\n5. Finally, build the plugin with `make build` to ensure the plugin is working as expected.\n6. Your job is done after successfully building the plugin. Don't verify if the binary was created. The build command will take care of that.\n\n**Important**: Never manipulate the files inside `generated` directory yourself. Don't touch the `service.proto`, `service.proto.lock.json`, `service_pb.js`, `service_grpc_pb.js` and TypeScript definition files.\n\nYou can update the TypeScript dependencies by running `bun install` to ensure the dependencies are up to date.\n\n## Implementation Pattern\n\n### Service Integration\n\nIf you need to integrate with other HTTP services, you should use the built-in `fetch` API or a library like `axios`.\nAlways prefer a real integration over mocking. In the tests, you can mock the external service by bootstrapping an HTTP server that returns the expected response.\nIn tests, focus on a well-defined contract and the expected behavior of your service. Structure tests by endpoint, use-cases and use descriptive test names.\n\nHere is an example of how to use the `fetch` API:\n\n```typescript\n// Initialize HTTP client for external API calls\nconst baseURL = \"<replace_with_base_url>\";\nconst headers = {\n  'Content-Type': 'application/json',\n  // Add other headers as needed\n};\n\n// A HTTP GET request to the external API\nconst getResponse = await fetch(`<replace_with_base_url>/<replace_with_path>`, {\n  method: 'GET',\n  headers,\n});\nconst getData = await getResponse.json();\n\n// A HTTP POST request to the external API with JSON payload\nconst postResponse = await fetch(`<replace_with_base_url>/<replace_with_path>`, {\n  method: 'POST',\n  headers,\n  body: JSON.stringify(payload),\n});\nconst postData = await postResponse.json();\n\n// Check for success\nif (postResponse.ok) {\n  // StatusCode >= 200 && StatusCode < 300\n  console.log('Success:', postData);\n}\n```\n\n### gRPC Service Implementation\n\nYour plugin implementation should follow the pattern of implementing the gRPC service interface generated from the GraphQL schema. The service methods receive requests and return responses using the generated protobuf types.\n\n```typescript\nimport { I{serviceName}Server } from '../generated/service_grpc_pb.js';\nimport { QueryRequest, QueryResponse } from '../generated/service_pb.js';\n\nconst {serviceName}Implementation: I{serviceName}Server = {\n  queryMethod: (call, callback) => {\n    // Access request data\n    const input = call.request.getFieldName();\n    \n    // Create and populate response\n    const response = new QueryResponse();\n    response.setFieldName(value);\n    \n    // Send response\n    callback(null, response);\n  }\n};\n```\n\n\n";

const fsPolyfillTs =
  "import * as fs from 'fs';\n\n// Polyfill for protobufjs which fails to load fs in bundled binaries\n// protobufjs uses eval(\"require\")(\"fs\") which returns null in Bun compiled binaries\n// We need to patch util.fs after protobufjs loads but before it's used\n\n// Import protobufjs util and patch it\n// Side-effect import to ensure google-protobuf is loaded\nimport 'google-protobuf';\n\n// Try to find and patch protobufjs's util.fs\ntry {\n  // Look for protobufjs in the bundled modules\n  const protobufUtil = (globalThis as any).protobuf?.util;\n  if (protobufUtil) {\n    protobufUtil.fs = fs;\n  }\n\n  // Also try to patch via require if available\n  if (typeof require !== 'undefined') {\n    try {\n      const util = require('protobufjs/src/util');\n      if (util) {\n        util.fs = fs;\n      }\n    } catch {\n      // Module might not be available\n    }\n  }\n} catch (e) {\n  if (process.env.DEBUG) {\n    console.error('[fsPolyfill] Warning: Failed to patch protobufjs util.fs:', e);\n  }  \n}\n\n";

const packageJson =
  '{\n  "name": "plugin-bun",\n  "version": "1.0.0",\n  "description": "gRPC Plugin using Bun runtime",\n  "type": "module",\n  "scripts": {\n    "build": "bun build src/plugin.ts --compile --outfile bin/plugin",\n    "dev": "bun run src/plugin.ts",\n    "postinstall": "bun ./node_modules/@protocolbuffers/protoc-gen-js/download-protoc-gen-js.js"\n  },\n  "dependencies": {\n    "@grpc/grpc-js": "^1.14.0",\n    "google-protobuf": "^4.0.0",\n    "grpc-health-check": "^2.0.0"\n  },\n  "devDependencies": {\n    "@protocolbuffers/protoc-gen-js": "4.0.0",\n    "@types/bun": "^1.3.1",\n    "@types/google-protobuf": "^3.15.12",\n    "@types/node": "^20.11.5",\n    "grpc-tools": "^1.12.4",\n    "grpc_tools_node_protoc_ts": "^5.3.3"\n  }\n}\n\n';

const pluginServerTs =
  "// MUST be imported first to polyfill fs for protobufjs\nimport './fs-polyfill';\n\nimport * as grpc from '@grpc/grpc-js';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { HealthImplementation } from 'grpc-health-check';\n\n/**\n * Plugin server that manages gRPC server with Unix domain socket\n */\nexport class PluginServer {\n    private readonly socketPath: string;\n    private readonly network: string = 'unix';\n\n    private server: grpc.Server;\n    private healthImpl: HealthImplementation;\n\n    constructor(socketDir: string = os.tmpdir()) {\n        // Generate a unique temporary file path\n        const tempPath = path.join(socketDir, `plugin_${Date.now()}${Math.floor(Math.random() * 1000000)}`);\n        this.socketPath = tempPath;\n\n        // Ensure the socket file doesn't exist\n        if (fs.existsSync(tempPath)) {\n            fs.unlinkSync(tempPath);\n        }\n\n        // Create the gRPC server\n        this.server = new grpc.Server();\n\n        // Initialize health check service with overall server status and plugin service\n        this.healthImpl = new HealthImplementation();\n        this.healthImpl.addToServer(this.server);\n        this.healthImpl.setStatus('plugin', 'SERVING');\n    }\n\n    /**\n     * Add a service implementation to the server\n     */\n    public addService(service: grpc.ServiceDefinition, implementation: grpc.UntypedServiceImplementation): void {\n        this.server.addService(service, implementation);\n    }\n\n    /**\n     * Start the server and output handshake information for go-plugin\n     */\n    public serve(): Promise<void> {\n        const address = this.network + \"://\" + this.socketPath;\n\n        return new Promise<void>((resolve, reject) => {\n            this.server.bindAsync(\n                address,\n                grpc.ServerCredentials.createInsecure(),\n                (error, port) => {\n                    if (error) {\n                        reject(error);\n                        return;\n                    }\n\n                    // Output the handshake information for go-plugin\n                    // Format: VERSION|PROTOCOL_VERSION|NETWORK|ADDRESS|PROTOCOL\n                    const logEntry = \"1|1|\" +this.network + \"|\" + this.socketPath + \"|grpc\";\n                    console.log(logEntry);\n\n                    resolve();\n                }\n            );\n        });\n    }\n}\n\n";

const pluginTestTs =
  'import { describe, test, expect } from "bun:test";\nimport * as grpc from "@grpc/grpc-js";\nimport type { Subprocess } from "bun";\n\n// Generated gRPC types\nimport { {serviceName}Client } from \'../generated/service_grpc_pb.js\';\nimport { QueryHelloRequest, QueryHelloResponse } from "../generated/service_pb.js";\n\nfunction queryHello(client: {serviceName}Client, name: string): Promise<QueryHelloResponse> {\n  return new Promise((resolve, reject) => {\n    const req = new QueryHelloRequest();\n    req.setName(name);\n    client.queryHello(req, (err, resp) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      if (!resp) {\n        reject(new Error("empty response"));\n        return;\n      }\n      resolve(resp);\n    });\n  });\n}\n\ndescribe("{serviceName}Service.queryHello", () => {\n  test("returns greeting with sequential world IDs", async () => {\n    const [subprocess, address] = await startPluginProcess();\n    const client = createClient(address);\n    try {\n      const cases = [\n        { name: "Alice", wantId: "world-1", wantName: "Hello from {serviceName} plugin! Alice" },\n        { name: "", wantId: "world-2", wantName: "Hello from {serviceName} plugin! " },\n        { name: "John & Jane", wantId: "world-3", wantName: "Hello from {serviceName} plugin! John & Jane" },\n      ];\n\n      for (const c of cases) {\n        const resp = await queryHello(client, c.name);\n        const world = resp.getHello();\n        expect(world).toBeTruthy();\n        expect(world!.getId()).toBe(c.wantId);\n        expect(world!.getName()).toBe(c.wantName);\n      }\n    } finally {\n      client.close();\n      subprocess.kill();\n    }\n  });\n\n  test("IDs increment across multiple requests in a fresh process", async () => {\n    const [subprocess, address] = await startPluginProcess();\n    const client = createClient(address);\n    try {\n      const first = await queryHello(client, "First");\n      expect(first.getHello()!.getId()).toBe("world-1");\n\n      const second = await queryHello(client, "Second");\n      expect(second.getHello()!.getId()).toBe("world-2");\n\n      const third = await queryHello(client, "Third");\n      expect(third.getHello()!.getId()).toBe("world-3");\n    } finally {\n      client.close();\n      subprocess.kill();\n    }\n  });\n});\n\n\nasync function startPluginProcess(): Promise<[Subprocess, string]> {\n  const proc = Bun.spawn(["bun", "run", "src/plugin.ts"], {\n    stdout: "pipe",\n    stderr: "inherit",\n  });\n\n  // Read the first line from stdout and parse the address\n  if (!proc.stdout) {\n    throw new Error("plugin stdout not available");\n  }\n  const reader = proc.stdout.getReader();\n  const decoder = new TextDecoder();\n  const { value } = await reader.read();\n  reader.releaseLock();\n\n  const text = decoder.decode(value ?? new Uint8Array());\n  const firstLine = text.split("\\n")[0]?.trim() ?? "";\n  const parts = firstLine.split("|");\n  const address = parts[3];\n\n  return [proc, address];\n}\n\nfunction createClient(address: string): {serviceName}Client {\n  const target = \'unix://\' + address;\n  return new {serviceName}Client(target, grpc.credentials.createInsecure());\n}';

const pluginTs =
  "import * as grpc from '@grpc/grpc-js';\nimport { PluginServer } from './plugin-server';\n\n// Import generated gRPC code\nimport { \n  {serviceName}Service, \n  I{serviceName}Server \n} from '../generated/service_grpc_pb.js';\nimport { \n  QueryHelloRequest, \n  QueryHelloResponse, \n  World \n} from '../generated/service_pb.js';\n\n// Thread-safe counter for generating unique IDs using atomics\nconst counterBuffer = new SharedArrayBuffer(4);\nconst counterArray = new Int32Array(counterBuffer);\nAtomics.store(counterArray, 0, 0); // Initialize counter to 0\n\n// Define the service implementation using the generated types\nconst {serviceName}Implementation: I{serviceName}Server = {\n  queryHello: (call: grpc.ServerUnaryCall<QueryHelloRequest, QueryHelloResponse>, callback: grpc.sendUnaryData<QueryHelloResponse>) => {\n    const name = call.request.getName();\n\n    const currentCounter = Atomics.add(counterArray, 0, 1) + 1;\n\n    const world = new World();\n    world.setId(`world-`+currentCounter);\n    world.setName(`Hello from {serviceName} plugin! `+ name);\n\n    const response = new QueryHelloResponse();\n    response.setHello(world);\n\n    callback(null, response);\n  }\n};\n\nfunction run() {\n  // Create the plugin server (health check automatically initialized)\n  const pluginServer = new PluginServer();\n  \n  // Add the {serviceName} service\n  pluginServer.addService({serviceName}Service, {serviceName}Implementation);\n\n  // Start the server\n  pluginServer.serve().catch((error) => {\n    console.error('Failed to start plugin server:', error);\n    process.exit(1);\n  });\n}\n\nrun();\n";

const readmePartialMd =
  '## Getting Started\n\nPlugin structure:\n\n   ```\n    plugins/{originalPluginName}/\n    ├── package.json                # Package.json file with dependencies\n    ├── src/\n    │   ├── plugin.ts         # Main plugin implementation\n    │   ├── plugin.test.ts    # Main plugin implementation tests\n    │   ├── fs-polyfill.ts    # Polyfill to help bundling into a binary\n    │   ├── plugin-server.ts  # Used to initialize the plugin as a server\n    │   └── schema.graphql    # GraphQL schema defining the API\n    ├── generated/            # Generated code (created during build)\n    └── bin/                  # Compiled binaries (created during build)\n        └── plugin            # The compiled plugin binary\n   ```\n';

const tsconfig =
  '{\n  "compilerOptions": {\n    "strict": true,\n    "target": "ES2020",\n    "module": "ESNext",\n    "moduleResolution": "Bundler",\n    "esModuleInterop": true,\n    "skipLibCheck": true,\n    "types": ["bun"]\n  },\n  "include": ["src/**/*.ts"]\n}\n\n';

export default {
  dockerfile,
  cursorRules,
  fsPolyfillTs,
  packageJson,
  pluginServerTs,
  pluginTestTs,
  pluginTs,
  readmePartialMd,
  tsconfig,
};
