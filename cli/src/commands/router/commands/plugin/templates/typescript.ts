// Templates for typescript (templating is done by pupa)
// This file is auto-generated. Do not edit manually.
/* eslint-disable no-template-curly-in-string */

const dockerfileTs = "FROM --platform=$BUILDPLATFORM oven/bun:1.3.0-alpine AS builder\n\n# Multi-platform build arguments\nARG TARGETOS\nARG TARGETARCH\n\nWORKDIR /build\n\n# Copy package files\nCOPY package.json bun.lock* ./\n\n# Install dependencies\nRUN bun install\n\n# Copy all source code\nCOPY src/ ./src/\nCOPY generated/ ./generated/\n\n# Set BUN_TARGET based on OS and architecture\nARG TARGETOS\nARG TARGETARCH\n\nRUN BUN_TARGET=\"bun-$TARGETOS-$([ \"$TARGETARCH\" = \"amd64\" ] && echo \"x64\" || echo \"$TARGETARCH\")\" && \\\n    echo \"Building for $BUN_TARGET\" && \\\n    bun build src/plugin.ts --compile --outfile bin/plugin --target=$BUN_TARGET\n\nFROM --platform=$BUILDPLATFORM scratch\n\nCOPY --from=builder /build/bin/plugin ./{originalPluginName}-plugin\n\nENTRYPOINT [\"./{originalPluginName}-plugin\"]\n\n";

const fsPolyfill = "import * as fs from 'node:fs';\n\n// Polyfill for protobufjs which fails to load fs in bundled binaries\n// protobufjs uses eval(\"require\")(\"fs\") which returns null in Bun compiled binaries\n// We need to patch util.fs after protobufjs loads but before it's used\n\n// Import protobufjs util and patch it\n// @ts-ignore\nimport * as protobuf from 'google-protobuf';\n\n// Try to find and patch protobufjs's util.fs\ntry {\n  // Look for protobufjs in the bundled modules\n  const protobufUtil = (globalThis as any).protobuf?.util;\n  if (protobufUtil) {\n    protobufUtil.fs = fs;\n  }\n\n  // Also try to patch via require if available\n  // eslint-disable-next-line unicorn/prefer-module\n  if (typeof require !== 'undefined') {\n    try {\n      // eslint-disable-next-line unicorn/prefer-module\n      const util = require('protobufjs/src/util');\n      if (util && !util.fs) {\n        util.fs = fs;\n      }\n    } catch {\n      // Module might not be available\n    }\n  }\n} catch {\n  // Silently fail - not critical\n}\n\n";

const packageJson = "{\n  \"name\": \"plugin-bun\",\n  \"version\": \"1.0.0\",\n  \"description\": \"gRPC Plugin using Bun runtime\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"build\": \"bun build src/plugin.ts --compile --outfile dist/plugin\",\n    \"dev\": \"bun run src/plugin.ts\",\n    \"client\": \"bun run src/client.ts\",\n    \"postinstall\": \"bun ./node_modules/@protocolbuffers/protoc-gen-js/download-protoc-gen-js.js\"\n  },\n  \"dependencies\": {\n    \"@grpc/grpc-js\": \"^1.14.0\",\n    \"google-protobuf\": \"^4.0.0\",\n    \"grpc-health-check\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"@protocolbuffers/protoc-gen-js\": \"4.0.0\",\n    \"@types/bun\": \"^1.3.1\",\n    \"@types/node\": \"^20.11.5\",\n    \"grpc-tools\": \"^1.12.4\",\n    \"grpc_tools_node_protoc_ts\": \"^5.3.3\"\n  }\n}\n\n";

const pluginServerTs = "import './fs-polyfill';\n\nimport * as grpc from '@grpc/grpc-js';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { HealthImplementation } from 'grpc-health-check';\n\n/**\n * Plugin server that manages gRPC server with Unix domain socket\n */\nexport class PluginServer {\n    private readonly socketPath: string;\n    private readonly network: string = 'unix';\n\n    private server: grpc.Server;\n    private healthImpl: HealthImplementation;\n\n    constructor(socketDir: string = os.tmpdir()) {\n        // Generate a unique temporary file path\n        const tempPath = path.join(socketDir, `plugin_${Date.now()}${Math.floor(Math.random() * 1000000)}`);\n        this.socketPath = tempPath;\n\n        // Ensure the socket file doesn't exist\n        if (fs.existsSync(tempPath)) {\n            fs.unlinkSync(tempPath);\n        }\n\n        // Create the gRPC server\n        this.server = new grpc.Server();\n\n        // Initialize health check service with overall server status and plugin service\n        this.healthImpl = new HealthImplementation();\n        this.healthImpl.addToServer(this.server);\n        this.healthImpl.setStatus('plugin', 'SERVING');\n    }\n\n    /**\n     * Add a service implementation to the server\n     */\n    public addService(service: grpc.ServiceDefinition, implementation: grpc.UntypedServiceImplementation): void {\n        this.server.addService(service, implementation);\n    }\n\n    /**\n     * Start the server and output handshake information for go-plugin\n     */\n    public serve(): Promise<void> {\n        const address = this.network + \"://\" + this.socketPath;\n\n        return new Promise<void>((resolve, reject) => {\n            this.server.bindAsync(\n                address,\n                grpc.ServerCredentials.createInsecure(),\n                (error, port) => {\n                    if (error) {\n                        reject(error);\n                        return;\n                    }\n\n                    // Output the handshake information for go-plugin\n                    // Format: VERSION|PROTOCOL_VERSION|NETWORK|ADDRESS|PROTOCOL\n                    const logEntry = \"1|1|\" +this.network + \"|\" + this.socketPath + \"|grpc\";\n                    console.log(logEntry);\n\n                    resolve();\n                }\n            );\n        });\n    }\n}\n\n";

const pluginTs = "import * as grpc from '@grpc/grpc-js';\nimport { PluginServer } from './plugin-server';\n\n// Import generated gRPC code\nimport { \n  {serviceName}Service, \n  I{serviceName}Server \n} from '../generated/service_grpc_pb';\nimport { \n  QueryHelloRequest, \n  QueryHelloResponse, \n  World \n} from '../generated/service_pb';\n\n// Counter for generating unique IDs\nlet counter = 0;\n\n// Define the service implementation using the generated types\nconst {serviceName}Implementation: I{serviceName}Server = {\n  queryHello: (call: grpc.ServerUnaryCall<QueryHelloRequest, QueryHelloResponse>, callback: grpc.sendUnaryData<QueryHelloResponse>) => {\n    const name = call.request.getName();\n\n    counter += 1;\n\n    const world = new World();\n    world.setId(`world-`+counter);\n    world.setName(`Hello from {serviceName} plugin! `+ name);\n\n    const response = new QueryHelloResponse();\n    response.setHello(world);\n\n    callback(null, response);\n  }\n};\n\nfunction run() {\n  // Create the plugin server (health check automatically initialized)\n  const pluginServer = new PluginServer();\n  \n  // Add the {serviceName} service\n  pluginServer.addService({serviceName}Service, {serviceName}Implementation);\n\n  // Start the server\n  pluginServer.serve().catch((error) => {\n    process.exit(1);\n  });\n}\n\nrun();\n\n";

const tsReadme = "## Getting Started\n\nPlugin structure:\n\n   ```\n    plugins/{originalPluginName}/\n    ├── go.mod                # Go module file with dependencies\n    ├── go.sum                # Ts checksums file\n    ├── src/\n    │   ├── plugin.ts           # Main plugin implementation\n    │   └── schema.graphql    # GraphQL schema defining the API\n    ├── generated/            # Generated code (created during build)\n    └── bin/                  # Compiled binaries (created during build)\n        └── plugin            # The compiled plugin binary\n   ```\n";

const tsconfig = "{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"Bundler\",\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"types\": [\"bun\"]\n  },\n  \"include\": [\"src/**/*.ts\"]\n}\n\n";

export default {
  dockerfileTs,
  fsPolyfill,
  packageJson,
  pluginServerTs,
  pluginTs,
  tsReadme,
  tsconfig,
};
