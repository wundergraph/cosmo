// TypeScript plugin templates (templating is done by pupa)
// This file is auto-generated. Do not edit manually.

const dockerfile = "FROM --platform=$BUILDPLATFORM oven/bun:1.3.0-alpine AS builder\n\n# Multi-platform build arguments\nARG TARGETOS\nARG TARGETARCH\n\nWORKDIR /build\n\n# Copy package files\nCOPY package.json bun.lock* ./\n\n# Install dependencies\nRUN bun install\n\n# Copy all source code\nCOPY src/ ./src/\nCOPY generated/ ./generated/\n\n# Set BUN_TARGET based on OS and architecture\nARG TARGETOS\nARG TARGETARCH\n\nRUN BUN_TARGET=\"bun-$TARGETOS-$([ \"$TARGETARCH\" = \"amd64\" ] && echo \"x64\" || echo \"$TARGETARCH\")\" && \\\n    echo \"Building for $BUN_TARGET\" && \\\n    bun build src/plugin.ts --compile --outfile bin/plugin --target=$BUN_TARGET\n\nFROM --platform=$BUILDPLATFORM scratch\n\nCOPY --from=builder /build/bin/plugin ./{originalPluginName}-plugin\n\nENTRYPOINT [\"./{originalPluginName}-plugin\"]\n\n";

const dockerfileTs = "FROM --platform=$BUILDPLATFORM oven/bun:1.3.0-alpine AS builder\n\n# Multi-platform build arguments\nARG TARGETOS\nARG TARGETARCH\n\nWORKDIR /build\n\n# Copy package files\nCOPY package.json bun.lock* ./\n\n# Install dependencies\nRUN bun install\n\n# Copy all source code\nCOPY src/ ./src/\nCOPY generated/ ./generated/\n\n# Set BUN_TARGET based on OS and architecture\nARG TARGETOS\nARG TARGETARCH\n\nRUN BUN_TARGET=\"bun-$TARGETOS-$([ \"$TARGETARCH\" = \"amd64\" ] && echo \"x64\" || echo \"$TARGETARCH\")\" && \\\n    echo \"Building for $BUN_TARGET\" && \\\n    bun build src/plugin.ts --compile --outfile bin/plugin --target=$BUN_TARGET\n\nFROM --platform=$BUILDPLATFORM scratch\n\nCOPY --from=builder /build/bin/plugin ./{originalPluginName}-plugin\n\nENTRYPOINT [\"./{originalPluginName}-plugin\"]\n\n";

const packageJson = "{\n  \"name\": \"plugin-bun\",\n  \"version\": \"1.0.0\",\n  \"description\": \"gRPC Plugin using Bun runtime\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"build\": \"bun build src/plugin.ts --compile --outfile dist/plugin\",\n    \"dev\": \"bun run src/plugin.ts\",\n    \"client\": \"bun run src/client.ts\",\n    \"postinstall\": \"bun ./node_modules/@protocolbuffers/protoc-gen-js/download-protoc-gen-js.js\"\n  },\n  \"dependencies\": {\n    \"@grpc/grpc-js\": \"^1.14.0\",\n    \"google-protobuf\": \"^4.0.0\",\n    \"grpc-health-check\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"@protocolbuffers/protoc-gen-js\": \"4.0.0\",\n    \"@types/bun\": \"^1.3.1\",\n    \"@types/node\": \"^20.11.5\",\n    \"grpc-tools\": \"^1.12.4\",\n    \"grpc_tools_node_protoc_ts\": \"^5.3.3\"\n  }\n}\n\n";

const pluginServerTs = "import * as grpc from '@grpc/grpc-js';\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as fs from 'fs';\n\n/**\n * Simple health check service implementation compatible with Bun\n */\nclass SimpleHealthCheck {\n    private statuses: Map<string, number> = new Map();\n\n    constructor() {\n        // Default to serving\n        this.setStatus('', 1); // SERVING = 1\n    }\n\n    setStatus(service: string, status: number): void {\n        this.statuses.set(service, status);\n    }\n\n    check(call: grpc.ServerUnaryCall<any, any>, callback: grpc.sendUnaryData<any>): void {\n        const service = call.request.service || '';\n        const status = this.statuses.get(service) ?? 1; // Default to SERVING\n\n        callback(null, { status });\n    }\n\n    watch(call: grpc.ServerWritableStream<any, any>): void {\n        const service = call.request.service || '';\n        const status = this.statuses.get(service) ?? 1;\n\n        call.write({ status });\n    }\n\n    addToServer(server: grpc.Server): void {\n        const healthCheckService = {\n            check: {\n                path: '/grpc.health.v1.Health/Check',\n                requestStream: false,\n                responseStream: false,\n                requestSerialize: (value: any) => Buffer.from(JSON.stringify(value)),\n                requestDeserialize: (value: Buffer) => JSON.parse(value.toString()),\n                responseSerialize: (value: any) => Buffer.from(JSON.stringify(value)),\n                responseDeserialize: (value: Buffer) => JSON.parse(value.toString()),\n            },\n            watch: {\n                path: '/grpc.health.v1.Health/Watch',\n                requestStream: false,\n                responseStream: true,\n                requestSerialize: (value: any) => Buffer.from(JSON.stringify(value)),\n                requestDeserialize: (value: Buffer) => JSON.parse(value.toString()),\n                responseSerialize: (value: any) => Buffer.from(JSON.stringify(value)),\n                responseDeserialize: (value: Buffer) => JSON.parse(value.toString()),\n            },\n        };\n\n        server.addService(healthCheckService as any, {\n            check: this.check.bind(this),\n            watch: this.watch.bind(this),\n        });\n    }\n}\n\n/**\n * Plugin server that manages gRPC server with Unix domain socket\n */\nexport class PluginServer {\n    private readonly socketPath: string;\n    private readonly network: string = 'unix';\n\n    private server: grpc.Server;\n    private healthImpl: SimpleHealthCheck;\n\n    constructor(socketDir: string = os.tmpdir()) {\n        // Generate a unique temporary file path\n        const tempPath = path.join(socketDir, `plugin_${Date.now()}${Math.floor(Math.random() * 1000000)}`);\n        this.socketPath = tempPath;\n\n        // Ensure the socket file doesn't exist\n        if (fs.existsSync(tempPath)) {\n            fs.unlinkSync(tempPath);\n        }\n\n        // Create the gRPC server\n        this.server = new grpc.Server();\n\n        // Initialize health check service with overall server status and plugin service\n        this.healthImpl = new SimpleHealthCheck();\n        this.healthImpl.setStatus('plugin', 1); // SERVING = 1\n        this.healthImpl.addToServer(this.server);\n    }\n\n    /**\n     * Add a service implementation to the server\n     */\n    public addService(service: grpc.ServiceDefinition, implementation: grpc.UntypedServiceImplementation): void {\n        this.server.addService(service, implementation);\n    }\n\n    /**\n     * Start the server and output handshake information for go-plugin\n     */\n    public serve(): Promise<void> {\n        const address = this.network + \"://\" + this.socketPath;\n\n        return new Promise<void>((resolve, reject) => {\n            this.server.bindAsync(\n                address,\n                grpc.ServerCredentials.createInsecure(),\n                (error, port) => {\n                    if (error) {\n                        reject(error);\n                        return;\n                    }\n\n                    // Output the handshake information for go-plugin\n                    // Format: VERSION|PROTOCOL_VERSION|NETWORK|ADDRESS|PROTOCOL\n                    const logEntry = \"1|1|\" +this.network + \"|\" + this.socketPath + \"|grpc\";\n                    console.log(logEntry);\n\n                    resolve();\n                }\n            );\n        });\n    }\n}\n\n";

const pluginTs = "import * as grpc from '@grpc/grpc-js';\nimport { PluginServer } from './plugin-server';\n\n// Import generated gRPC code\nimport { \n  {serviceName}Service, \n  I{serviceName}Server \n} from '../generated/service_grpc_pb';\nimport { \n  QueryHelloRequest, \n  QueryHelloResponse, \n  World \n} from '../generated/service_pb';\n\n// Counter for generating unique IDs\nlet counter = 0;\n\n// Define the service implementation using the generated types\nconst {serviceName}Implementation: I{serviceName}Server = {\n  queryHello: (call: grpc.ServerUnaryCall<QueryHelloRequest, QueryHelloResponse>, callback: grpc.sendUnaryData<QueryHelloResponse>) => {\n    const name = call.request.getName();\n\n    counter += 1;\n\n    const world = new World();\n    world.setId(`world-`+counter);\n    world.setName(`Hello from {serviceName} plugin! `+ name);\n\n    const response = new QueryHelloResponse();\n    response.setHello(world);\n\n    callback(null, response);\n  }\n};\n\nfunction run() {\n  // Create the plugin server (health check automatically initialized)\n  const pluginServer = new PluginServer();\n  \n  // Add the {serviceName} service\n  pluginServer.addService({serviceName}Service, {serviceName}Implementation);\n\n  // Start the server\n  pluginServer.serve().catch((error) => {\n    process.exit(1);\n  });\n}\n\nrun();\n\n";

export default {
  dockerfile,
  dockerfileTs,
  packageJson,
  pluginServerTs,
  pluginTs,
};
