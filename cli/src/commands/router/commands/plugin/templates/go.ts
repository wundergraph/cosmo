// Templates for go (templating is done by pupa)
// This file is auto-generated. Do not edit manually.
/* eslint-disable no-template-curly-in-string */

const dockerfile =
  'FROM --platform=$BUILDPLATFORM golang:1.25-alpine AS builder\n\n# Multi-platform build arguments\nARG TARGETOS\nARG TARGETARCH\n\nWORKDIR /build\n\n# Copy go mod files\nCOPY go.mod go.sum ./\nRUN go mod download\n\n# Copy source code\nCOPY . .\n\nRUN --mount=type=cache,target="/root/.cache/go-build" CGO_ENABLED=0 GOOS=$TARGETOS GOARCH=$TARGETARCH go build -o dist/plugin ./src\n\nFROM --platform=$BUILDPLATFORM scratch\n\nCOPY --from=builder /build/dist/plugin ./{originalPluginName}-plugin\n\nENTRYPOINT ["./{originalPluginName}-plugin"]\n';

const cursorRules =
  '---\ndescription: {name} Plugin Guide\nglobs: src/**\nalwaysApply: false\n---\n\n# {name} Plugin Development Guide\n\nYou are an expert in developing Cosmo Router plugins. You are given a GraphQL schema, and you need to implement the Go code for the plugin.\nYour goal is to implement the plugin in a way that is easy to understand and maintain. You add tests to ensure the plugin works as expected.\n\nAll make commands need to be run from the plugin directory `{pluginDir}`.\n\n## Plugin Structure\n\nA plugin is structured as follows:\n\n```\nplugins/{originalPluginName}/\n├── Makefile                     # Build automation\n├── go.mod                       # Go module definition\n├── go.sum                       # Go module checksums\n├── src/\n│   ├── schema.graphql           # GraphQL schema (API contract)\n│   ├── main.go                  # Plugin implementation\n│   └── main_test.go             # Tests for the plugin\n├── generated/                   # Auto-generated files (DO NOT EDIT)\n│   ├── service.proto            # Generated Protocol Buffers\n│   ├── service.pb.go            # Generated Go structures\n│   ├── service.proto.lock.json  # Generated Protobuf lock file\n│   └── service_grpc.pb.go       # Generated gRPC service\n└── bin/                         # Compiled binaries\n    └── plugin                   # The compiled plugin binary\n```\n\n## Development Workflow\n\n1. When modifying the GraphQL schema in `src/schema.graphql`, you need to regenerate the code with `make generate`.\n2. Look into the generated code in `generated/service.proto` and `generated/service.pb.go` to understand the updated API contract and service methods.\n3. Implement the new RPC methods in `src/main.go`.\n4. Add tests to `src/main_test.go` to ensure the plugin works as expected. You need to run `make test` to ensure the tests pass.\n5. Finally, build the plugin with `make build` to ensure the plugin is working as expected.\n6. Your job is done after successfully building the plugin. Don\'t verify if the binary was created. The build command will take care of that.\n\n**Important**: Never manipulate the files inside `generated` directory yourself. Don\'t touch the `service.proto`,  `service.proto.lock.json`, `service.pb.go` and `service_grpc.pb.go` files.\n\nYou can update the Go dependencies by running `make test` to ensure the dependencies are up to date. It runs `go mod tidy` under the hood.\n\n## Implementation Pattern\n\n### Service Integration\n\nIf you need to integrate with other HTTP services, you should prefer to use the `github.com/wundergraph/cosmo/router-plugin/httpclient` package.\nAlways prefer a real integration over mocking. In the tests, you can mock the external service by bootstrapping an http server that returns the expected response.\nIn tests, focus on a well-defined contract and the expected behavior of your service. Structure tests by endpoint, use-cases and use table-driven tests when possible.\n\nHere is an example of how to use the `httpclient` package:\n\n```go\n// Initialize HTTP client for external API calls\n// The base URL is the URL of the external API\nclient := httpclient.New(\n  httpclient.WithBaseURL("<replace_with_base_url>"),\n  httpclient.WithTimeout(5*time.Second),\n  httpclient.WithHeaders(map[string]string{}),\n)\n// A HTTP GET request to the external API\nresp, err := client.Get(ctx, "/<replace_with_path>")\n// A HTTP POST/PUT/DELETE request to the external API with a struct that is marshalled to JSON\nresp, err := client.Post(ctx, "/<replace_with_path>", payload)\n// Passing payload with custom request options\nresp, err := client.Put(ctx, "/<replace_with_path>", payload,\n  httpclient.WithHeaders(map[string]string{}),\n)\n// Unmarshal the JSON response into our data structure\ndata, err := httpclient.UnmarshalTo[[]ResponseType](resp)\n// The response offers the following fields:\ntype Response struct {\n\tStatusCode int\n\tHeaders    http.Header\n\tBody       []byte\n}\n// You can check for success (StatusCode >= 200 && StatusCode < 300)\nresp.IsSuccess()\n```\n';

const goMod =
  '\nmodule {modulePath}\n\ngo 1.25.1\n\nrequire (\n  github.com/stretchr/testify v1.10.0\n  github.com/wundergraph/cosmo/router-plugin v0.0.0-20250824152218-8eebc34c4995 // v0.4.1\n  google.golang.org/grpc v1.68.1\n  google.golang.org/protobuf v1.36.5\n)\n';

const mainGo =
  'package main\n\nimport (\n  "context"\n  "log"\n  "strconv"\n\n  service "github.com/wundergraph/cosmo/plugin/generated"\n\n  routerplugin "github.com/wundergraph/cosmo/router-plugin"\n  "google.golang.org/grpc"\n)\n\nfunc main() {\n  pl, err := routerplugin.NewRouterPlugin(func(s *grpc.Server) {\n    s.RegisterService(&service.{serviceName}_ServiceDesc, &{serviceName}{\n      nextID: 1,\n    })\n  }, routerplugin.WithTracing())\n\n  if err != nil {\n    log.Fatalf("failed to create router plugin: %v", err)\n  }\n\n  pl.Serve()\n}\n\ntype {serviceName} struct {\n  service.Unimplemented{serviceName}Server\n  nextID int\n}\n\nfunc (s *{serviceName}) QueryHello(ctx context.Context, req *service.QueryHelloRequest) (*service.QueryHelloResponse, error) {\n  response := &service.QueryHelloResponse{\n    Hello: &service.World{\n      Id:   strconv.Itoa(s.nextID),\n      Name: req.Name,\n    },\n  }\n  s.nextID++\n  return response, nil\n}\n';

const mainTestGo =
  'package main\n\nimport (\n  "context"\n  "net"\n  "testing"\n\n  "github.com/stretchr/testify/assert"\n  "github.com/stretchr/testify/require"\n  service "github.com/wundergraph/cosmo/plugin/generated"\n  "google.golang.org/grpc"\n  "google.golang.org/grpc/credentials/insecure"\n  "google.golang.org/grpc/test/bufconn"\n)\n\nconst bufSize = 1024 * 1024\n\n// testService is a wrapper that holds the gRPC test components\ntype testService struct {\n  grpcConn  *grpc.ClientConn\n  client service.{serviceName}Client\n  cleanup   func()\n}\n\n// setupTestService creates a local gRPC server for testing\nfunc setupTestService(t *testing.T) *testService {\n  // Create a buffer for gRPC connections\n  lis := bufconn.Listen(bufSize)\n\n  // Create a new gRPC server\n  grpcServer := grpc.NewServer()\n\n  // Register our service\n  service.Register{serviceName}Server(grpcServer, &{serviceName}{\n    nextID: 1,\n  })\n\n  // Start the server\n  go func() {\n    if err := grpcServer.Serve(lis); err != nil {\n      t.Fatalf("failed to serve: %v", err)\n    }\n  }()\n\n  // Create a client connection\n  dialer := func(context.Context, string) (net.Conn, error) {\n    return lis.Dial()\n  }\n  conn, err := grpc.Dial(\n    "passthrough:///bufnet",\n    grpc.WithContextDialer(dialer),\n    grpc.WithTransportCredentials(insecure.NewCredentials()),\n  )\n  require.NoError(t, err)\n\n  // Create the service client\n  client := service.New{serviceName}Client(conn)\n\n  // Return cleanup function\n  cleanup := func() {\n    conn.Close()\n    grpcServer.Stop()\n  }\n\n  return &testService{\n    grpcConn:  conn,\n    client: client,\n    cleanup:   cleanup,\n  }\n}\n\nfunc TestQueryHello(t *testing.T) {\n  // Set up basic service\n  svc := setupTestService(t)\n  defer svc.cleanup()\n\n  tests := []struct {\n    name     string\n    userName string\n    wantId   string\n    wantName string\n    wantErr  bool\n  }{\n    {\n      name:     "valid hello",\n      userName: "Alice",\n      wantId:   "1",\n      wantName: "Alice",\n      wantErr:  false,\n    },\n    {\n      name:     "empty name",\n      userName: "",\n      wantId:   "2",\n      wantName: "", // Empty name should be preserved\n      wantErr:  false,\n    },\n    {\n      name:     "special characters",\n      userName: "John & Jane",\n      wantId:   "3",\n      wantName: "John & Jane",\n      wantErr:  false,\n    },\n  }\n\n  for _, tt := range tests {\n    t.Run(tt.name, func(t *testing.T) {\n      req := &service.QueryHelloRequest{\n        Name: tt.userName,\n      }\n\n      resp, err := svc.client.QueryHello(context.Background(), req)\n      if tt.wantErr {\n        assert.Error(t, err)\n        return\n      }\n\n      assert.NoError(t, err)\n      assert.NotNil(t, resp.Hello)\n      assert.Equal(t, tt.wantId, resp.Hello.Id)\n      assert.Equal(t, tt.wantName, resp.Hello.Name)\n    })\n  }\n}\n\nfunc TestSequentialIDs(t *testing.T) {\n  // Set up basic service\n  svc := setupTestService(t)\n  defer svc.cleanup()\n\n  // The first request should get ID "1"\n  firstReq := &service.QueryHelloRequest{Name: "First"}\n  firstResp, err := svc.client.QueryHello(context.Background(), firstReq)\n  require.NoError(t, err)\n  assert.Equal(t, "1", firstResp.Hello.Id)\n\n  // The second request should get ID "2"\n  secondReq := &service.QueryHelloRequest{Name: "Second"}\n  secondResp, err := svc.client.QueryHello(context.Background(), secondReq)\n  require.NoError(t, err)\n  assert.Equal(t, "2", secondResp.Hello.Id)\n\n  // The third request should get ID "3"\n  thirdReq := &service.QueryHelloRequest{Name: "Third"}\n  thirdResp, err := svc.client.QueryHello(context.Background(), thirdReq)\n  require.NoError(t, err)\n  assert.Equal(t, "3", thirdResp.Hello.Id)\n}\n';

const readmePartialMd =
  '## Getting Started\n\nPlugin structure:\n\n   ```\n    plugins/{originalPluginName}/\n    ├── go.mod                # Go module file with dependencies\n    ├── go.sum                # Go checksums file\n    ├── src/\n    │   ├── main.go           # Main plugin implementation\n    │   ├── main_test.go      # Tests for the plugin\n    │   └── schema.graphql    # GraphQL schema defining the API\n    ├── generated/            # Generated code (created during build)\n    └── bin/                  # Compiled binaries (created during build)\n        └── plugin            # The compiled plugin binary\n   ```';

export default {
  dockerfile,
  cursorRules,
  goMod,
  mainGo,
  mainTestGo,
  readmePartialMd,
};
