// Templates for go (templating is done by pupa)
// This file is auto-generated. Do not edit manually.
/* eslint-disable no-template-curly-in-string */

const dockerfileGo =
  'FROM --platform=$BUILDPLATFORM golang:1.25-alpine AS builder\n\n# Multi-platform build arguments\nARG TARGETOS\nARG TARGETARCH\n\nWORKDIR /build\n\n# Copy go mod files\nCOPY go.mod go.sum ./\nRUN go mod download\n\n# Copy source code\nCOPY . .\n\nRUN --mount=type=cache,target="/root/.cache/go-build" CGO_ENABLED=0 GOOS=$TARGETOS GOARCH=$TARGETARCH go build -o dist/plugin ./src\n\nFROM --platform=$BUILDPLATFORM scratch\n\nCOPY --from=builder /build/dist/plugin ./{originalPluginName}-plugin\n\nENTRYPOINT ["./{originalPluginName}-plugin"]\n\n';

const goMod =
  '\nmodule {modulePath}\n\ngo 1.25.1\n\nrequire (\n  github.com/stretchr/testify v1.10.0\n  github.com/wundergraph/cosmo/router-plugin v0.0.0-20250824152218-8eebc34c4995 // v0.4.1\n  google.golang.org/grpc v1.68.1\n  google.golang.org/protobuf v1.36.5\n)\n\n';

const goReadme =
  '## Getting Started\n\nPlugin structure:\n\n   ```\n    plugins/{originalPluginName}/\n    ├── go.mod                # Go module file with dependencies\n    ├── go.sum                # Go checksums file\n    ├── src/\n    │   ├── main.go           # Main plugin implementation\n    │   ├── main_test.go      # Tests for the plugin\n    │   └── schema.graphql    # GraphQL schema defining the API\n    ├── generated/            # Generated code (created during build)\n    └── bin/                  # Compiled binaries (created during build)\n        └── plugin            # The compiled plugin binary\n   ```\n';

const mainGo =
  'package main\n\nimport (\n  "context"\n  "log"\n  "strconv"\n\n  service "github.com/wundergraph/cosmo/plugin/generated"\n\n  routerplugin "github.com/wundergraph/cosmo/router-plugin"\n  "google.golang.org/grpc"\n)\n\nfunc main() {\n  pl, err := routerplugin.NewRouterPlugin(func(s *grpc.Server) {\n    s.RegisterService(&service.{serviceName}_ServiceDesc, &{serviceName}{\n      nextID: 1,\n    })\n  }, routerplugin.WithTracing())\n\n  if err != nil {\n    log.Fatalf("failed to create router plugin: %v", err)\n  }\n\n  pl.Serve()\n}\n\ntype {serviceName} struct {\n  service.Unimplemented{serviceName}Server\n  nextID int\n}\n\nfunc (s *{serviceName}) QueryHello(ctx context.Context, req *service.QueryHelloRequest) (*service.QueryHelloResponse, error) {\n  response := &service.QueryHelloResponse{\n    Hello: &service.World{\n      Id:   strconv.Itoa(s.nextID),\n      Name: req.Name,\n    },\n  }\n  s.nextID++\n  return response, nil\n}\n\n';

const mainGoTest =
  'package main\n\nimport (\n  "context"\n  "net"\n  "testing"\n\n  "github.com/stretchr/testify/assert"\n  "github.com/stretchr/testify/require"\n  service "github.com/wundergraph/cosmo/plugin/generated"\n  "google.golang.org/grpc"\n  "google.golang.org/grpc/credentials/insecure"\n  "google.golang.org/grpc/test/bufconn"\n)\n\nconst bufSize = 1024 * 1024\n\n// testService is a wrapper that holds the gRPC test components\ntype testService struct {\n  grpcConn  *grpc.ClientConn\n  client service.{serviceName}Client\n  cleanup   func()\n}\n\n// setupTestService creates a local gRPC server for testing\nfunc setupTestService(t *testing.T) *testService {\n  // Create a buffer for gRPC connections\n  lis := bufconn.Listen(bufSize)\n\n  // Create a new gRPC server\n  grpcServer := grpc.NewServer()\n\n  // Register our service\n  service.Register{serviceName}Server(grpcServer, &{serviceName}{\n    nextID: 1,\n  })\n\n  // Start the server\n  go func() {\n    if err := grpcServer.Serve(lis); err != nil {\n      t.Fatalf("failed to serve: %v", err)\n    }\n  }()\n\n  // Create a client connection\n  dialer := func(context.Context, string) (net.Conn, error) {\n    return lis.Dial()\n  }\n  conn, err := grpc.Dial(\n    "passthrough:///bufnet",\n    grpc.WithContextDialer(dialer),\n    grpc.WithTransportCredentials(insecure.NewCredentials()),\n  )\n  require.NoError(t, err)\n\n  // Create the service client\n  client := service.New{serviceName}Client(conn)\n\n  // Return cleanup function\n  cleanup := func() {\n    conn.Close()\n    grpcServer.Stop()\n  }\n\n  return &testService{\n    grpcConn:  conn,\n    client: client,\n    cleanup:   cleanup,\n  }\n}\n\nfunc TestQueryHello(t *testing.T) {\n  // Set up basic service\n  svc := setupTestService(t)\n  defer svc.cleanup()\n\n  tests := []struct {\n    name     string\n    userName string\n    wantId   string\n    wantName string\n    wantErr  bool\n  }{\n    {\n      name:     "valid hello",\n      userName: "Alice",\n      wantId:   "1",\n      wantName: "Alice",\n      wantErr:  false,\n    },\n    {\n      name:     "empty name",\n      userName: "",\n      wantId:   "2",\n      wantName: "", // Empty name should be preserved\n      wantErr:  false,\n    },\n    {\n      name:     "special characters",\n      userName: "John & Jane",\n      wantId:   "3",\n      wantName: "John & Jane",\n      wantErr:  false,\n    },\n  }\n\n  for _, tt := range tests {\n    t.Run(tt.name, func(t *testing.T) {\n      req := &service.QueryHelloRequest{\n        Name: tt.userName,\n      }\n\n      resp, err := svc.client.QueryHello(context.Background(), req)\n      if tt.wantErr {\n        assert.Error(t, err)\n        return\n      }\n\n      assert.NoError(t, err)\n      assert.NotNil(t, resp.Hello)\n      assert.Equal(t, tt.wantId, resp.Hello.Id)\n      assert.Equal(t, tt.wantName, resp.Hello.Name)\n    })\n  }\n}\n\nfunc TestSequentialIDs(t *testing.T) {\n  // Set up basic service\n  svc := setupTestService(t)\n  defer svc.cleanup()\n\n  // The first request should get ID "1"\n  firstReq := &service.QueryHelloRequest{Name: "First"}\n  firstResp, err := svc.client.QueryHello(context.Background(), firstReq)\n  require.NoError(t, err)\n  assert.Equal(t, "1", firstResp.Hello.Id)\n\n  // The second request should get ID "2"\n  secondReq := &service.QueryHelloRequest{Name: "Second"}\n  secondResp, err := svc.client.QueryHello(context.Background(), secondReq)\n  require.NoError(t, err)\n  assert.Equal(t, "2", secondResp.Hello.Id)\n\n  // The third request should get ID "3"\n  thirdReq := &service.QueryHelloRequest{Name: "Third"}\n  thirdResp, err := svc.client.QueryHello(context.Background(), thirdReq)\n  require.NoError(t, err)\n  assert.Equal(t, "3", thirdResp.Hello.Id)\n}\n\n';

export default {
  dockerfileGo,
  goMod,
  goReadme,
  mainGo,
  mainGoTest,
};
