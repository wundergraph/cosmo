// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file wg/cosmo/node/v1/node.proto (package wg.cosmo.node.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { EnumStatusCode, GraphQLSubscriptionProtocol, GraphQLWebsocketSubprotocol } from "../../common/common_pb.js";

/**
 * @generated from enum wg.cosmo.node.v1.ArgumentRenderConfiguration
 */
export enum ArgumentRenderConfiguration {
  /**
   * @generated from enum value: RENDER_ARGUMENT_DEFAULT = 0;
   */
  RENDER_ARGUMENT_DEFAULT = 0,

  /**
   * @generated from enum value: RENDER_ARGUMENT_AS_GRAPHQL_VALUE = 1;
   */
  RENDER_ARGUMENT_AS_GRAPHQL_VALUE = 1,

  /**
   * @generated from enum value: RENDER_ARGUMENT_AS_ARRAY_CSV = 2;
   */
  RENDER_ARGUMENT_AS_ARRAY_CSV = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ArgumentRenderConfiguration)
proto3.util.setEnumType(ArgumentRenderConfiguration, "wg.cosmo.node.v1.ArgumentRenderConfiguration", [
  { no: 0, name: "RENDER_ARGUMENT_DEFAULT" },
  { no: 1, name: "RENDER_ARGUMENT_AS_GRAPHQL_VALUE" },
  { no: 2, name: "RENDER_ARGUMENT_AS_ARRAY_CSV" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.ArgumentSource
 */
export enum ArgumentSource {
  /**
   * @generated from enum value: OBJECT_FIELD = 0;
   */
  OBJECT_FIELD = 0,

  /**
   * @generated from enum value: FIELD_ARGUMENT = 1;
   */
  FIELD_ARGUMENT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ArgumentSource)
proto3.util.setEnumType(ArgumentSource, "wg.cosmo.node.v1.ArgumentSource", [
  { no: 0, name: "OBJECT_FIELD" },
  { no: 1, name: "FIELD_ARGUMENT" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.DataSourceKind
 */
export enum DataSourceKind {
  /**
   * @generated from enum value: STATIC = 0;
   */
  STATIC = 0,

  /**
   * @generated from enum value: GRAPHQL = 1;
   */
  GRAPHQL = 1,

  /**
   * @generated from enum value: PUBSUB = 2;
   */
  PUBSUB = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(DataSourceKind)
proto3.util.setEnumType(DataSourceKind, "wg.cosmo.node.v1.DataSourceKind", [
  { no: 0, name: "STATIC" },
  { no: 1, name: "GRAPHQL" },
  { no: 2, name: "PUBSUB" },
]);

/**
 * Defines the type of GraphQL operation
 *
 * @generated from enum wg.cosmo.node.v1.OperationType
 */
export enum OperationType {
  /**
   * @generated from enum value: OPERATION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Query operation
   *
   * @generated from enum value: OPERATION_TYPE_QUERY = 1;
   */
  QUERY = 1,

  /**
   * Mutation operation
   *
   * @generated from enum value: OPERATION_TYPE_MUTATION = 2;
   */
  MUTATION = 2,

  /**
   * Subscription operation
   *
   * @generated from enum value: OPERATION_TYPE_SUBSCRIPTION = 3;
   */
  SUBSCRIPTION = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(OperationType)
proto3.util.setEnumType(OperationType, "wg.cosmo.node.v1.OperationType", [
  { no: 0, name: "OPERATION_TYPE_UNSPECIFIED" },
  { no: 1, name: "OPERATION_TYPE_QUERY" },
  { no: 2, name: "OPERATION_TYPE_MUTATION" },
  { no: 3, name: "OPERATION_TYPE_SUBSCRIPTION" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.EventType
 */
export enum EventType {
  /**
   * @generated from enum value: PUBLISH = 0;
   */
  PUBLISH = 0,

  /**
   * @generated from enum value: REQUEST = 1;
   */
  REQUEST = 1,

  /**
   * @generated from enum value: SUBSCRIBE = 2;
   */
  SUBSCRIBE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(EventType)
proto3.util.setEnumType(EventType, "wg.cosmo.node.v1.EventType", [
  { no: 0, name: "PUBLISH" },
  { no: 1, name: "REQUEST" },
  { no: 2, name: "SUBSCRIBE" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.ConfigurationVariableKind
 */
export enum ConfigurationVariableKind {
  /**
   * @generated from enum value: STATIC_CONFIGURATION_VARIABLE = 0;
   */
  STATIC_CONFIGURATION_VARIABLE = 0,

  /**
   * @generated from enum value: ENV_CONFIGURATION_VARIABLE = 1;
   */
  ENV_CONFIGURATION_VARIABLE = 1,

  /**
   * @generated from enum value: PLACEHOLDER_CONFIGURATION_VARIABLE = 2;
   */
  PLACEHOLDER_CONFIGURATION_VARIABLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConfigurationVariableKind)
proto3.util.setEnumType(ConfigurationVariableKind, "wg.cosmo.node.v1.ConfigurationVariableKind", [
  { no: 0, name: "STATIC_CONFIGURATION_VARIABLE" },
  { no: 1, name: "ENV_CONFIGURATION_VARIABLE" },
  { no: 2, name: "PLACEHOLDER_CONFIGURATION_VARIABLE" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.HTTPMethod
 */
export enum HTTPMethod {
  /**
   * @generated from enum value: GET = 0;
   */
  GET = 0,

  /**
   * @generated from enum value: POST = 1;
   */
  POST = 1,

  /**
   * @generated from enum value: PUT = 2;
   */
  PUT = 2,

  /**
   * @generated from enum value: DELETE = 3;
   */
  DELETE = 3,

  /**
   * @generated from enum value: OPTIONS = 4;
   */
  OPTIONS = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(HTTPMethod)
proto3.util.setEnumType(HTTPMethod, "wg.cosmo.node.v1.HTTPMethod", [
  { no: 0, name: "GET" },
  { no: 1, name: "POST" },
  { no: 2, name: "PUT" },
  { no: 3, name: "DELETE" },
  { no: 4, name: "OPTIONS" },
]);

/**
 * @generated from message wg.cosmo.node.v1.Subgraph
 */
export class Subgraph extends Message<Subgraph> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: string routing_url = 3;
   */
  routingUrl = "";

  constructor(data?: PartialMessage<Subgraph>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.Subgraph";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "routing_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subgraph {
    return new Subgraph().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subgraph {
    return new Subgraph().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subgraph {
    return new Subgraph().fromJsonString(jsonString, options);
  }

  static equals(a: Subgraph | PlainMessage<Subgraph> | undefined, b: Subgraph | PlainMessage<Subgraph> | undefined): boolean {
    return proto3.util.equals(Subgraph, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.FeatureFlagRouterExecutionConfigs
 */
export class FeatureFlagRouterExecutionConfigs extends Message<FeatureFlagRouterExecutionConfigs> {
  /**
   * @generated from field: map<string, wg.cosmo.node.v1.FeatureFlagRouterExecutionConfig> config_by_feature_flag_name = 1;
   */
  configByFeatureFlagName: { [key: string]: FeatureFlagRouterExecutionConfig } = {};

  constructor(data?: PartialMessage<FeatureFlagRouterExecutionConfigs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.FeatureFlagRouterExecutionConfigs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config_by_feature_flag_name", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: FeatureFlagRouterExecutionConfig} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeatureFlagRouterExecutionConfigs {
    return new FeatureFlagRouterExecutionConfigs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeatureFlagRouterExecutionConfigs {
    return new FeatureFlagRouterExecutionConfigs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeatureFlagRouterExecutionConfigs {
    return new FeatureFlagRouterExecutionConfigs().fromJsonString(jsonString, options);
  }

  static equals(a: FeatureFlagRouterExecutionConfigs | PlainMessage<FeatureFlagRouterExecutionConfigs> | undefined, b: FeatureFlagRouterExecutionConfigs | PlainMessage<FeatureFlagRouterExecutionConfigs> | undefined): boolean {
    return proto3.util.equals(FeatureFlagRouterExecutionConfigs, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.FeatureFlagRouterExecutionConfig
 */
export class FeatureFlagRouterExecutionConfig extends Message<FeatureFlagRouterExecutionConfig> {
  /**
   * @generated from field: wg.cosmo.node.v1.EngineConfiguration engine_config = 1;
   */
  engineConfig?: EngineConfiguration;

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.Subgraph subgraphs = 3;
   */
  subgraphs: Subgraph[] = [];

  constructor(data?: PartialMessage<FeatureFlagRouterExecutionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.FeatureFlagRouterExecutionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "engine_config", kind: "message", T: EngineConfiguration },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subgraphs", kind: "message", T: Subgraph, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeatureFlagRouterExecutionConfig {
    return new FeatureFlagRouterExecutionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeatureFlagRouterExecutionConfig {
    return new FeatureFlagRouterExecutionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeatureFlagRouterExecutionConfig {
    return new FeatureFlagRouterExecutionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: FeatureFlagRouterExecutionConfig | PlainMessage<FeatureFlagRouterExecutionConfig> | undefined, b: FeatureFlagRouterExecutionConfig | PlainMessage<FeatureFlagRouterExecutionConfig> | undefined): boolean {
    return proto3.util.equals(FeatureFlagRouterExecutionConfig, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.RouterConfig
 */
export class RouterConfig extends Message<RouterConfig> {
  /**
   * @generated from field: wg.cosmo.node.v1.EngineConfiguration engine_config = 1;
   */
  engineConfig?: EngineConfiguration;

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.Subgraph subgraphs = 3;
   */
  subgraphs: Subgraph[] = [];

  /**
   * The map of feature flag router execution configs requires a wrapper to be non-breaking
   *
   * @generated from field: optional wg.cosmo.node.v1.FeatureFlagRouterExecutionConfigs feature_flag_configs = 4;
   */
  featureFlagConfigs?: FeatureFlagRouterExecutionConfigs;

  /**
   * @generated from field: string compatibility_version = 5;
   */
  compatibilityVersion = "";

  constructor(data?: PartialMessage<RouterConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.RouterConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "engine_config", kind: "message", T: EngineConfiguration },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subgraphs", kind: "message", T: Subgraph, repeated: true },
    { no: 4, name: "feature_flag_configs", kind: "message", T: FeatureFlagRouterExecutionConfigs, opt: true },
    { no: 5, name: "compatibility_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouterConfig {
    return new RouterConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouterConfig {
    return new RouterConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouterConfig {
    return new RouterConfig().fromJsonString(jsonString, options);
  }

  static equals(a: RouterConfig | PlainMessage<RouterConfig> | undefined, b: RouterConfig | PlainMessage<RouterConfig> | undefined): boolean {
    return proto3.util.equals(RouterConfig, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.Response
 */
export class Response extends Message<Response> {
  /**
   * @generated from field: wg.cosmo.common.EnumStatusCode code = 1;
   */
  code = EnumStatusCode.OK;

  /**
   * details is an optional field which can be used to provide more details about the error.
   *
   * @generated from field: optional string details = 2;
   */
  details?: string;

  constructor(data?: PartialMessage<Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(EnumStatusCode) },
    { no: 2, name: "details", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Response {
    return new Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJsonString(jsonString, options);
  }

  static equals(a: Response | PlainMessage<Response> | undefined, b: Response | PlainMessage<Response> | undefined): boolean {
    return proto3.util.equals(Response, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.ResponseStatus
 */
export class ResponseStatus extends Message<ResponseStatus> {
  /**
   * @generated from field: int32 code = 1;
   */
  code = 0;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<ResponseStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ResponseStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponseStatus {
    return new ResponseStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponseStatus {
    return new ResponseStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponseStatus {
    return new ResponseStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ResponseStatus | PlainMessage<ResponseStatus> | undefined, b: ResponseStatus | PlainMessage<ResponseStatus> | undefined): boolean {
    return proto3.util.equals(ResponseStatus, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.RegistrationInfo
 */
export class RegistrationInfo extends Message<RegistrationInfo> {
  /**
   * @generated from field: wg.cosmo.node.v1.AccountLimits account_limits = 1;
   */
  accountLimits?: AccountLimits;

  /**
   * @generated from field: string graph_public_key = 2;
   */
  graphPublicKey = "";

  constructor(data?: PartialMessage<RegistrationInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.RegistrationInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_limits", kind: "message", T: AccountLimits },
    { no: 2, name: "graph_public_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegistrationInfo {
    return new RegistrationInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegistrationInfo {
    return new RegistrationInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegistrationInfo {
    return new RegistrationInfo().fromJsonString(jsonString, options);
  }

  static equals(a: RegistrationInfo | PlainMessage<RegistrationInfo> | undefined, b: RegistrationInfo | PlainMessage<RegistrationInfo> | undefined): boolean {
    return proto3.util.equals(RegistrationInfo, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.AccountLimits
 */
export class AccountLimits extends Message<AccountLimits> {
  /**
   * The maximum sampling rate for traces. Must be between 0 and 1.
   * 0 means no traces will be sampled and 1 means all traces will be sampled.
   *
   * @generated from field: float trace_sampling_rate = 1;
   */
  traceSamplingRate = 0;

  constructor(data?: PartialMessage<AccountLimits>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.AccountLimits";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trace_sampling_rate", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountLimits {
    return new AccountLimits().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountLimits {
    return new AccountLimits().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountLimits {
    return new AccountLimits().fromJsonString(jsonString, options);
  }

  static equals(a: AccountLimits | PlainMessage<AccountLimits> | undefined, b: AccountLimits | PlainMessage<AccountLimits> | undefined): boolean {
    return proto3.util.equals(AccountLimits, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SelfRegisterRequest
 */
export class SelfRegisterRequest extends Message<SelfRegisterRequest> {
  constructor(data?: PartialMessage<SelfRegisterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SelfRegisterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SelfRegisterRequest {
    return new SelfRegisterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SelfRegisterRequest {
    return new SelfRegisterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SelfRegisterRequest {
    return new SelfRegisterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SelfRegisterRequest | PlainMessage<SelfRegisterRequest> | undefined, b: SelfRegisterRequest | PlainMessage<SelfRegisterRequest> | undefined): boolean {
    return proto3.util.equals(SelfRegisterRequest, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SelfRegisterResponse
 */
export class SelfRegisterResponse extends Message<SelfRegisterResponse> {
  /**
   * @generated from field: wg.cosmo.node.v1.Response response = 1;
   */
  response?: Response;

  /**
   * @generated from field: optional wg.cosmo.node.v1.RegistrationInfo registrationInfo = 2;
   */
  registrationInfo?: RegistrationInfo;

  constructor(data?: PartialMessage<SelfRegisterResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SelfRegisterResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "message", T: Response },
    { no: 2, name: "registrationInfo", kind: "message", T: RegistrationInfo, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SelfRegisterResponse {
    return new SelfRegisterResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SelfRegisterResponse {
    return new SelfRegisterResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SelfRegisterResponse {
    return new SelfRegisterResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SelfRegisterResponse | PlainMessage<SelfRegisterResponse> | undefined, b: SelfRegisterResponse | PlainMessage<SelfRegisterResponse> | undefined): boolean {
    return proto3.util.equals(SelfRegisterResponse, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.EngineConfiguration
 */
export class EngineConfiguration extends Message<EngineConfiguration> {
  /**
   * @generated from field: int64 defaultFlushInterval = 1;
   */
  defaultFlushInterval = protoInt64.zero;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.DataSourceConfiguration datasource_configurations = 2;
   */
  datasourceConfigurations: DataSourceConfiguration[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.FieldConfiguration field_configurations = 3;
   */
  fieldConfigurations: FieldConfiguration[] = [];

  /**
   * @generated from field: string graphqlSchema = 4;
   */
  graphqlSchema = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.TypeConfiguration type_configurations = 5;
   */
  typeConfigurations: TypeConfiguration[] = [];

  /**
   * @generated from field: map<string, string> string_storage = 6;
   */
  stringStorage: { [key: string]: string } = {};

  /**
   * @generated from field: optional string graphql_client_schema = 7;
   */
  graphqlClientSchema?: string;

  constructor(data?: PartialMessage<EngineConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.EngineConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "defaultFlushInterval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "datasource_configurations", kind: "message", T: DataSourceConfiguration, repeated: true },
    { no: 3, name: "field_configurations", kind: "message", T: FieldConfiguration, repeated: true },
    { no: 4, name: "graphqlSchema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "type_configurations", kind: "message", T: TypeConfiguration, repeated: true },
    { no: 6, name: "string_storage", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 7, name: "graphql_client_schema", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EngineConfiguration {
    return new EngineConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EngineConfiguration {
    return new EngineConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EngineConfiguration {
    return new EngineConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: EngineConfiguration | PlainMessage<EngineConfiguration> | undefined, b: EngineConfiguration | PlainMessage<EngineConfiguration> | undefined): boolean {
    return proto3.util.equals(EngineConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceConfiguration
 */
export class DataSourceConfiguration extends Message<DataSourceConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceKind kind = 1;
   */
  kind = DataSourceKind.STATIC;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.TypeField root_nodes = 2;
   */
  rootNodes: TypeField[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.TypeField child_nodes = 3;
   */
  childNodes: TypeField[] = [];

  /**
   * @generated from field: bool override_field_path_from_alias = 4;
   */
  overrideFieldPathFromAlias = false;

  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceCustom_GraphQL custom_graphql = 5;
   */
  customGraphql?: DataSourceCustom_GraphQL;

  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceCustom_Static custom_static = 6;
   */
  customStatic?: DataSourceCustom_Static;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.DirectiveConfiguration directives = 7;
   */
  directives: DirectiveConfiguration[] = [];

  /**
   * @generated from field: int64 request_timeout_seconds = 8;
   */
  requestTimeoutSeconds = protoInt64.zero;

  /**
   * @generated from field: string id = 9;
   */
  id = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.RequiredField keys = 10;
   */
  keys: RequiredField[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.RequiredField provides = 11;
   */
  provides: RequiredField[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.RequiredField requires = 12;
   */
  requires: RequiredField[] = [];

  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceCustomEvents custom_events = 13;
   */
  customEvents?: DataSourceCustomEvents;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.EntityInterfaceConfiguration entity_interfaces = 14;
   */
  entityInterfaces: EntityInterfaceConfiguration[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.EntityInterfaceConfiguration interface_objects = 15;
   */
  interfaceObjects: EntityInterfaceConfiguration[] = [];

  constructor(data?: PartialMessage<DataSourceConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(DataSourceKind) },
    { no: 2, name: "root_nodes", kind: "message", T: TypeField, repeated: true },
    { no: 3, name: "child_nodes", kind: "message", T: TypeField, repeated: true },
    { no: 4, name: "override_field_path_from_alias", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "custom_graphql", kind: "message", T: DataSourceCustom_GraphQL },
    { no: 6, name: "custom_static", kind: "message", T: DataSourceCustom_Static },
    { no: 7, name: "directives", kind: "message", T: DirectiveConfiguration, repeated: true },
    { no: 8, name: "request_timeout_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "keys", kind: "message", T: RequiredField, repeated: true },
    { no: 11, name: "provides", kind: "message", T: RequiredField, repeated: true },
    { no: 12, name: "requires", kind: "message", T: RequiredField, repeated: true },
    { no: 13, name: "custom_events", kind: "message", T: DataSourceCustomEvents },
    { no: 14, name: "entity_interfaces", kind: "message", T: EntityInterfaceConfiguration, repeated: true },
    { no: 15, name: "interface_objects", kind: "message", T: EntityInterfaceConfiguration, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceConfiguration {
    return new DataSourceConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceConfiguration {
    return new DataSourceConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceConfiguration {
    return new DataSourceConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceConfiguration | PlainMessage<DataSourceConfiguration> | undefined, b: DataSourceConfiguration | PlainMessage<DataSourceConfiguration> | undefined): boolean {
    return proto3.util.equals(DataSourceConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.ArgumentConfiguration
 */
export class ArgumentConfiguration extends Message<ArgumentConfiguration> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: wg.cosmo.node.v1.ArgumentSource source_type = 2;
   */
  sourceType = ArgumentSource.OBJECT_FIELD;

  constructor(data?: PartialMessage<ArgumentConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ArgumentConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source_type", kind: "enum", T: proto3.getEnumType(ArgumentSource) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgumentConfiguration {
    return new ArgumentConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgumentConfiguration {
    return new ArgumentConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgumentConfiguration {
    return new ArgumentConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: ArgumentConfiguration | PlainMessage<ArgumentConfiguration> | undefined, b: ArgumentConfiguration | PlainMessage<ArgumentConfiguration> | undefined): boolean {
    return proto3.util.equals(ArgumentConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.Scopes
 */
export class Scopes extends Message<Scopes> {
  /**
   * @generated from field: repeated string required_and_scopes = 1;
   */
  requiredAndScopes: string[] = [];

  constructor(data?: PartialMessage<Scopes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.Scopes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "required_and_scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Scopes {
    return new Scopes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Scopes {
    return new Scopes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Scopes {
    return new Scopes().fromJsonString(jsonString, options);
  }

  static equals(a: Scopes | PlainMessage<Scopes> | undefined, b: Scopes | PlainMessage<Scopes> | undefined): boolean {
    return proto3.util.equals(Scopes, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.AuthorizationConfiguration
 */
export class AuthorizationConfiguration extends Message<AuthorizationConfiguration> {
  /**
   * @generated from field: bool requires_authentication = 1;
   */
  requiresAuthentication = false;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.Scopes required_or_scopes = 2;
   */
  requiredOrScopes: Scopes[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.Scopes required_or_scopes_by_or = 3;
   */
  requiredOrScopesByOr: Scopes[] = [];

  constructor(data?: PartialMessage<AuthorizationConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.AuthorizationConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requires_authentication", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "required_or_scopes", kind: "message", T: Scopes, repeated: true },
    { no: 3, name: "required_or_scopes_by_or", kind: "message", T: Scopes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthorizationConfiguration {
    return new AuthorizationConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthorizationConfiguration {
    return new AuthorizationConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthorizationConfiguration {
    return new AuthorizationConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: AuthorizationConfiguration | PlainMessage<AuthorizationConfiguration> | undefined, b: AuthorizationConfiguration | PlainMessage<AuthorizationConfiguration> | undefined): boolean {
    return proto3.util.equals(AuthorizationConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.FieldConfiguration
 */
export class FieldConfiguration extends Message<FieldConfiguration> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 2;
   */
  fieldName = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.ArgumentConfiguration arguments_configuration = 3;
   */
  argumentsConfiguration: ArgumentConfiguration[] = [];

  /**
   * @generated from field: wg.cosmo.node.v1.AuthorizationConfiguration authorization_configuration = 4;
   */
  authorizationConfiguration?: AuthorizationConfiguration;

  /**
   * @generated from field: optional wg.cosmo.node.v1.SubscriptionFilterCondition subscription_filter_condition = 5;
   */
  subscriptionFilterCondition?: SubscriptionFilterCondition;

  constructor(data?: PartialMessage<FieldConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.FieldConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "arguments_configuration", kind: "message", T: ArgumentConfiguration, repeated: true },
    { no: 4, name: "authorization_configuration", kind: "message", T: AuthorizationConfiguration },
    { no: 5, name: "subscription_filter_condition", kind: "message", T: SubscriptionFilterCondition, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldConfiguration {
    return new FieldConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldConfiguration {
    return new FieldConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldConfiguration {
    return new FieldConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: FieldConfiguration | PlainMessage<FieldConfiguration> | undefined, b: FieldConfiguration | PlainMessage<FieldConfiguration> | undefined): boolean {
    return proto3.util.equals(FieldConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.TypeConfiguration
 */
export class TypeConfiguration extends Message<TypeConfiguration> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string rename_to = 2;
   */
  renameTo = "";

  constructor(data?: PartialMessage<TypeConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.TypeConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rename_to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypeConfiguration {
    return new TypeConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypeConfiguration {
    return new TypeConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypeConfiguration {
    return new TypeConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: TypeConfiguration | PlainMessage<TypeConfiguration> | undefined, b: TypeConfiguration | PlainMessage<TypeConfiguration> | undefined): boolean {
    return proto3.util.equals(TypeConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.TypeField
 */
export class TypeField extends Message<TypeField> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: repeated string field_names = 2;
   */
  fieldNames: string[] = [];

  /**
   * @generated from field: repeated string external_field_names = 3;
   */
  externalFieldNames: string[] = [];

  /**
   * @generated from field: repeated string require_fetch_reasons_field_names = 4;
   */
  requireFetchReasonsFieldNames: string[] = [];

  constructor(data?: PartialMessage<TypeField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.TypeField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "external_field_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "require_fetch_reasons_field_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypeField {
    return new TypeField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypeField {
    return new TypeField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypeField {
    return new TypeField().fromJsonString(jsonString, options);
  }

  static equals(a: TypeField | PlainMessage<TypeField> | undefined, b: TypeField | PlainMessage<TypeField> | undefined): boolean {
    return proto3.util.equals(TypeField, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.FieldCoordinates
 */
export class FieldCoordinates extends Message<FieldCoordinates> {
  /**
   * @generated from field: string field_name = 1;
   */
  fieldName = "";

  /**
   * @generated from field: string type_name = 2;
   */
  typeName = "";

  constructor(data?: PartialMessage<FieldCoordinates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.FieldCoordinates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldCoordinates {
    return new FieldCoordinates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldCoordinates {
    return new FieldCoordinates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldCoordinates {
    return new FieldCoordinates().fromJsonString(jsonString, options);
  }

  static equals(a: FieldCoordinates | PlainMessage<FieldCoordinates> | undefined, b: FieldCoordinates | PlainMessage<FieldCoordinates> | undefined): boolean {
    return proto3.util.equals(FieldCoordinates, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.FieldSetCondition
 */
export class FieldSetCondition extends Message<FieldSetCondition> {
  /**
   * @generated from field: repeated wg.cosmo.node.v1.FieldCoordinates field_coordinates_path = 1;
   */
  fieldCoordinatesPath: FieldCoordinates[] = [];

  /**
   * @generated from field: repeated string field_path = 2;
   */
  fieldPath: string[] = [];

  constructor(data?: PartialMessage<FieldSetCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.FieldSetCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_coordinates_path", kind: "message", T: FieldCoordinates, repeated: true },
    { no: 2, name: "field_path", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldSetCondition {
    return new FieldSetCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldSetCondition {
    return new FieldSetCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldSetCondition {
    return new FieldSetCondition().fromJsonString(jsonString, options);
  }

  static equals(a: FieldSetCondition | PlainMessage<FieldSetCondition> | undefined, b: FieldSetCondition | PlainMessage<FieldSetCondition> | undefined): boolean {
    return proto3.util.equals(FieldSetCondition, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.RequiredField
 */
export class RequiredField extends Message<RequiredField> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 2;
   */
  fieldName = "";

  /**
   * @generated from field: string selection_set = 3;
   */
  selectionSet = "";

  /**
   * @generated from field: bool disable_entity_resolver = 4;
   */
  disableEntityResolver = false;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.FieldSetCondition conditions = 5;
   */
  conditions: FieldSetCondition[] = [];

  constructor(data?: PartialMessage<RequiredField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.RequiredField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "selection_set", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "disable_entity_resolver", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "conditions", kind: "message", T: FieldSetCondition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequiredField {
    return new RequiredField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequiredField {
    return new RequiredField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequiredField {
    return new RequiredField().fromJsonString(jsonString, options);
  }

  static equals(a: RequiredField | PlainMessage<RequiredField> | undefined, b: RequiredField | PlainMessage<RequiredField> | undefined): boolean {
    return proto3.util.equals(RequiredField, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.EntityInterfaceConfiguration
 */
export class EntityInterfaceConfiguration extends Message<EntityInterfaceConfiguration> {
  /**
   * @generated from field: string interface_type_name = 1;
   */
  interfaceTypeName = "";

  /**
   * @generated from field: repeated string concrete_type_names = 2;
   */
  concreteTypeNames: string[] = [];

  constructor(data?: PartialMessage<EntityInterfaceConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.EntityInterfaceConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interface_type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "concrete_type_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntityInterfaceConfiguration {
    return new EntityInterfaceConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntityInterfaceConfiguration {
    return new EntityInterfaceConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntityInterfaceConfiguration {
    return new EntityInterfaceConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: EntityInterfaceConfiguration | PlainMessage<EntityInterfaceConfiguration> | undefined, b: EntityInterfaceConfiguration | PlainMessage<EntityInterfaceConfiguration> | undefined): boolean {
    return proto3.util.equals(EntityInterfaceConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.FetchConfiguration
 */
export class FetchConfiguration extends Message<FetchConfiguration> {
  /**
   * You should either configure url OR a combination of baseURL and path
   * If url resolves to a non empty string, it takes precedence over baseURL and path
   * If url resolves to an empty string, the url will be configured as "{{baseURL}}{{path}}"
   *
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable url = 1;
   */
  url?: ConfigurationVariable;

  /**
   * @generated from field: wg.cosmo.node.v1.HTTPMethod method = 2;
   */
  method = HTTPMethod.GET;

  /**
   * @generated from field: map<string, wg.cosmo.node.v1.HTTPHeader> header = 3;
   */
  header: { [key: string]: HTTPHeader } = {};

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable body = 4;
   */
  body?: ConfigurationVariable;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.URLQueryConfiguration query = 5;
   */
  query: URLQueryConfiguration[] = [];

  /**
   * urlEncodeBody defines whether the body should be URL encoded or not
   * by default, the body will be JSON encoded
   * setting urlEncodeBody to true will render the body empty,
   * the Header Content-Type will be set to application/x-www-form-urlencoded,
   * and the body will be URL encoded and set as the URL Query String
   *
   * @generated from field: bool url_encode_body = 7;
   */
  urlEncodeBody = false;

  /**
   * @generated from field: wg.cosmo.node.v1.MTLSConfiguration mtls = 8;
   */
  mtls?: MTLSConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable base_url = 9;
   */
  baseUrl?: ConfigurationVariable;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable path = 10;
   */
  path?: ConfigurationVariable;

  /**
   * @generated from field: optional wg.cosmo.node.v1.ConfigurationVariable http_proxy_url = 11;
   */
  httpProxyUrl?: ConfigurationVariable;

  constructor(data?: PartialMessage<FetchConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.FetchConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "message", T: ConfigurationVariable },
    { no: 2, name: "method", kind: "enum", T: proto3.getEnumType(HTTPMethod) },
    { no: 3, name: "header", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: HTTPHeader} },
    { no: 4, name: "body", kind: "message", T: ConfigurationVariable },
    { no: 5, name: "query", kind: "message", T: URLQueryConfiguration, repeated: true },
    { no: 7, name: "url_encode_body", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "mtls", kind: "message", T: MTLSConfiguration },
    { no: 9, name: "base_url", kind: "message", T: ConfigurationVariable },
    { no: 10, name: "path", kind: "message", T: ConfigurationVariable },
    { no: 11, name: "http_proxy_url", kind: "message", T: ConfigurationVariable, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchConfiguration {
    return new FetchConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchConfiguration {
    return new FetchConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchConfiguration {
    return new FetchConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: FetchConfiguration | PlainMessage<FetchConfiguration> | undefined, b: FetchConfiguration | PlainMessage<FetchConfiguration> | undefined): boolean {
    return proto3.util.equals(FetchConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.StatusCodeTypeMapping
 */
export class StatusCodeTypeMapping extends Message<StatusCodeTypeMapping> {
  /**
   * @generated from field: int64 status_code = 1;
   */
  statusCode = protoInt64.zero;

  /**
   * @generated from field: string type_name = 2;
   */
  typeName = "";

  /**
   * @generated from field: bool inject_status_code_into_body = 3;
   */
  injectStatusCodeIntoBody = false;

  constructor(data?: PartialMessage<StatusCodeTypeMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.StatusCodeTypeMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status_code", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "inject_status_code_into_body", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusCodeTypeMapping {
    return new StatusCodeTypeMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusCodeTypeMapping {
    return new StatusCodeTypeMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusCodeTypeMapping {
    return new StatusCodeTypeMapping().fromJsonString(jsonString, options);
  }

  static equals(a: StatusCodeTypeMapping | PlainMessage<StatusCodeTypeMapping> | undefined, b: StatusCodeTypeMapping | PlainMessage<StatusCodeTypeMapping> | undefined): boolean {
    return proto3.util.equals(StatusCodeTypeMapping, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceCustom_GraphQL
 */
export class DataSourceCustom_GraphQL extends Message<DataSourceCustom_GraphQL> {
  /**
   * @generated from field: wg.cosmo.node.v1.FetchConfiguration fetch = 1;
   */
  fetch?: FetchConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.GraphQLSubscriptionConfiguration subscription = 2;
   */
  subscription?: GraphQLSubscriptionConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.GraphQLFederationConfiguration federation = 3;
   */
  federation?: GraphQLFederationConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.InternedString upstream_schema = 4;
   */
  upstreamSchema?: InternedString;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.SingleTypeField custom_scalar_type_fields = 6;
   */
  customScalarTypeFields: SingleTypeField[] = [];

  /**
   * @generated from field: wg.cosmo.node.v1.GRPCConfiguration grpc = 7;
   */
  grpc?: GRPCConfiguration;

  constructor(data?: PartialMessage<DataSourceCustom_GraphQL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceCustom_GraphQL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fetch", kind: "message", T: FetchConfiguration },
    { no: 2, name: "subscription", kind: "message", T: GraphQLSubscriptionConfiguration },
    { no: 3, name: "federation", kind: "message", T: GraphQLFederationConfiguration },
    { no: 4, name: "upstream_schema", kind: "message", T: InternedString },
    { no: 6, name: "custom_scalar_type_fields", kind: "message", T: SingleTypeField, repeated: true },
    { no: 7, name: "grpc", kind: "message", T: GRPCConfiguration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceCustom_GraphQL {
    return new DataSourceCustom_GraphQL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceCustom_GraphQL {
    return new DataSourceCustom_GraphQL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceCustom_GraphQL {
    return new DataSourceCustom_GraphQL().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceCustom_GraphQL | PlainMessage<DataSourceCustom_GraphQL> | undefined, b: DataSourceCustom_GraphQL | PlainMessage<DataSourceCustom_GraphQL> | undefined): boolean {
    return proto3.util.equals(DataSourceCustom_GraphQL, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GRPCConfiguration
 */
export class GRPCConfiguration extends Message<GRPCConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.GRPCMapping mapping = 1;
   */
  mapping?: GRPCMapping;

  /**
   * @generated from field: string proto_schema = 2;
   */
  protoSchema = "";

  /**
   * @generated from field: wg.cosmo.node.v1.PluginConfiguration plugin = 3;
   */
  plugin?: PluginConfiguration;

  constructor(data?: PartialMessage<GRPCConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GRPCConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapping", kind: "message", T: GRPCMapping },
    { no: 2, name: "proto_schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "plugin", kind: "message", T: PluginConfiguration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GRPCConfiguration {
    return new GRPCConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GRPCConfiguration {
    return new GRPCConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GRPCConfiguration {
    return new GRPCConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: GRPCConfiguration | PlainMessage<GRPCConfiguration> | undefined, b: GRPCConfiguration | PlainMessage<GRPCConfiguration> | undefined): boolean {
    return proto3.util.equals(GRPCConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.ImageReference
 */
export class ImageReference extends Message<ImageReference> {
  /**
   * {organization_id}/{subgraph_id}
   *
   * @generated from field: string repository = 1;
   */
  repository = "";

  /**
   * v1
   *
   * @generated from field: string reference = 2;
   */
  reference = "";

  constructor(data?: PartialMessage<ImageReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ImageReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "reference", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageReference {
    return new ImageReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageReference {
    return new ImageReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageReference {
    return new ImageReference().fromJsonString(jsonString, options);
  }

  static equals(a: ImageReference | PlainMessage<ImageReference> | undefined, b: ImageReference | PlainMessage<ImageReference> | undefined): boolean {
    return proto3.util.equals(ImageReference, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.PluginConfiguration
 */
export class PluginConfiguration extends Message<PluginConfiguration> {
  /**
   * Plugin name
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Plugin version
   *
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: optional wg.cosmo.node.v1.ImageReference image_reference = 3;
   */
  imageReference?: ImageReference;

  constructor(data?: PartialMessage<PluginConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.PluginConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "image_reference", kind: "message", T: ImageReference, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginConfiguration {
    return new PluginConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginConfiguration {
    return new PluginConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginConfiguration {
    return new PluginConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: PluginConfiguration | PlainMessage<PluginConfiguration> | undefined, b: PluginConfiguration | PlainMessage<PluginConfiguration> | undefined): boolean {
    return proto3.util.equals(PluginConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SSLConfiguration
 */
export class SSLConfiguration extends Message<SSLConfiguration> {
  /**
   * Whether SSL is enabled
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  constructor(data?: PartialMessage<SSLConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SSLConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSLConfiguration {
    return new SSLConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSLConfiguration {
    return new SSLConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSLConfiguration {
    return new SSLConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: SSLConfiguration | PlainMessage<SSLConfiguration> | undefined, b: SSLConfiguration | PlainMessage<SSLConfiguration> | undefined): boolean {
    return proto3.util.equals(SSLConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GRPCMapping
 */
export class GRPCMapping extends Message<GRPCMapping> {
  /**
   * Version of the mapping format
   *
   * @generated from field: int32 version = 1;
   */
  version = 0;

  /**
   * The main gRPC service name
   *
   * @generated from field: string service = 2;
   */
  service = "";

  /**
   * Mappings for GraphQL operations to gRPC RPCs
   *
   * @generated from field: repeated wg.cosmo.node.v1.OperationMapping operation_mappings = 3;
   */
  operationMappings: OperationMapping[] = [];

  /**
   * Mappings for GraphQL entities to gRPC service methods
   *
   * @generated from field: repeated wg.cosmo.node.v1.EntityMapping entity_mappings = 4;
   */
  entityMappings: EntityMapping[] = [];

  /**
   * Mappings for GraphQL type fields to gRPC message fields
   *
   * @generated from field: repeated wg.cosmo.node.v1.TypeFieldMapping type_field_mappings = 5;
   */
  typeFieldMappings: TypeFieldMapping[] = [];

  /**
   * Mappings for GraphQL enum values to gRPC enum values
   *
   * @generated from field: repeated wg.cosmo.node.v1.EnumMapping enum_mappings = 6;
   */
  enumMappings: EnumMapping[] = [];

  constructor(data?: PartialMessage<GRPCMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GRPCMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "operation_mappings", kind: "message", T: OperationMapping, repeated: true },
    { no: 4, name: "entity_mappings", kind: "message", T: EntityMapping, repeated: true },
    { no: 5, name: "type_field_mappings", kind: "message", T: TypeFieldMapping, repeated: true },
    { no: 6, name: "enum_mappings", kind: "message", T: EnumMapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GRPCMapping {
    return new GRPCMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GRPCMapping {
    return new GRPCMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GRPCMapping {
    return new GRPCMapping().fromJsonString(jsonString, options);
  }

  static equals(a: GRPCMapping | PlainMessage<GRPCMapping> | undefined, b: GRPCMapping | PlainMessage<GRPCMapping> | undefined): boolean {
    return proto3.util.equals(GRPCMapping, a, b);
  }
}

/**
 * Defines mapping between a GraphQL operation and a gRPC method
 *
 * @generated from message wg.cosmo.node.v1.OperationMapping
 */
export class OperationMapping extends Message<OperationMapping> {
  /**
   * GraphQL operation type: Query, Mutation, or Subscription
   *
   * @generated from field: wg.cosmo.node.v1.OperationType type = 1;
   */
  type = OperationType.UNSPECIFIED;

  /**
   * Original GraphQL field name
   *
   * @generated from field: string original = 2;
   */
  original = "";

  /**
   * Mapped gRPC method name
   *
   * @generated from field: string mapped = 3;
   */
  mapped = "";

  /**
   * gRPC request message type name
   *
   * @generated from field: string request = 4;
   */
  request = "";

  /**
   * gRPC response message type name
   *
   * @generated from field: string response = 5;
   */
  response = "";

  constructor(data?: PartialMessage<OperationMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.OperationMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(OperationType) },
    { no: 2, name: "original", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "mapped", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "request", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OperationMapping {
    return new OperationMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OperationMapping {
    return new OperationMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OperationMapping {
    return new OperationMapping().fromJsonString(jsonString, options);
  }

  static equals(a: OperationMapping | PlainMessage<OperationMapping> | undefined, b: OperationMapping | PlainMessage<OperationMapping> | undefined): boolean {
    return proto3.util.equals(OperationMapping, a, b);
  }
}

/**
 * Defines mapping for entity resolution
 *
 * @generated from message wg.cosmo.node.v1.EntityMapping
 */
export class EntityMapping extends Message<EntityMapping> {
  /**
   * GraphQL type name
   *
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * Kind of entity mapping: "entity", "requires", or "with_arguments"
   *
   * @generated from field: string kind = 2;
   */
  kind = "";

  /**
   * Key field that uniquely identifies the entity
   *
   * @generated from field: string key = 3;
   */
  key = "";

  /**
   * gRPC method name for entity resolution
   *
   * @generated from field: string rpc = 4;
   */
  rpc = "";

  /**
   * gRPC request message type name
   *
   * @generated from field: string request = 5;
   */
  request = "";

  /**
   * gRPC response message type name
   *
   * @generated from field: string response = 6;
   */
  response = "";

  constructor(data?: PartialMessage<EntityMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.EntityMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "rpc", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "request", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "response", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntityMapping {
    return new EntityMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntityMapping {
    return new EntityMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntityMapping {
    return new EntityMapping().fromJsonString(jsonString, options);
  }

  static equals(a: EntityMapping | PlainMessage<EntityMapping> | undefined, b: EntityMapping | PlainMessage<EntityMapping> | undefined): boolean {
    return proto3.util.equals(EntityMapping, a, b);
  }
}

/**
 * Defines mapping between GraphQL type fields and gRPC message fields
 *
 * @generated from message wg.cosmo.node.v1.TypeFieldMapping
 */
export class TypeFieldMapping extends Message<TypeFieldMapping> {
  /**
   * GraphQL type name
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * Mappings for each field in the type
   *
   * @generated from field: repeated wg.cosmo.node.v1.FieldMapping field_mappings = 2;
   */
  fieldMappings: FieldMapping[] = [];

  constructor(data?: PartialMessage<TypeFieldMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.TypeFieldMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_mappings", kind: "message", T: FieldMapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypeFieldMapping {
    return new TypeFieldMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypeFieldMapping {
    return new TypeFieldMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypeFieldMapping {
    return new TypeFieldMapping().fromJsonString(jsonString, options);
  }

  static equals(a: TypeFieldMapping | PlainMessage<TypeFieldMapping> | undefined, b: TypeFieldMapping | PlainMessage<TypeFieldMapping> | undefined): boolean {
    return proto3.util.equals(TypeFieldMapping, a, b);
  }
}

/**
 * Defines mapping for a single field
 *
 * @generated from message wg.cosmo.node.v1.FieldMapping
 */
export class FieldMapping extends Message<FieldMapping> {
  /**
   * Original GraphQL field name
   *
   * @generated from field: string original = 1;
   */
  original = "";

  /**
   * Mapped gRPC field name
   *
   * @generated from field: string mapped = 2;
   */
  mapped = "";

  /**
   * Mappings for field arguments
   *
   * @generated from field: repeated wg.cosmo.node.v1.ArgumentMapping argument_mappings = 3;
   */
  argumentMappings: ArgumentMapping[] = [];

  constructor(data?: PartialMessage<FieldMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.FieldMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "original", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mapped", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "argument_mappings", kind: "message", T: ArgumentMapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldMapping {
    return new FieldMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldMapping {
    return new FieldMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldMapping {
    return new FieldMapping().fromJsonString(jsonString, options);
  }

  static equals(a: FieldMapping | PlainMessage<FieldMapping> | undefined, b: FieldMapping | PlainMessage<FieldMapping> | undefined): boolean {
    return proto3.util.equals(FieldMapping, a, b);
  }
}

/**
 * Defines mapping for a field argument
 *
 * @generated from message wg.cosmo.node.v1.ArgumentMapping
 */
export class ArgumentMapping extends Message<ArgumentMapping> {
  /**
   * Original GraphQL argument name
   *
   * @generated from field: string original = 1;
   */
  original = "";

  /**
   * Mapped gRPC field name
   *
   * @generated from field: string mapped = 2;
   */
  mapped = "";

  constructor(data?: PartialMessage<ArgumentMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ArgumentMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "original", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mapped", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgumentMapping {
    return new ArgumentMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgumentMapping {
    return new ArgumentMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgumentMapping {
    return new ArgumentMapping().fromJsonString(jsonString, options);
  }

  static equals(a: ArgumentMapping | PlainMessage<ArgumentMapping> | undefined, b: ArgumentMapping | PlainMessage<ArgumentMapping> | undefined): boolean {
    return proto3.util.equals(ArgumentMapping, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.EnumMapping
 */
export class EnumMapping extends Message<EnumMapping> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.EnumValueMapping values = 2;
   */
  values: EnumValueMapping[] = [];

  constructor(data?: PartialMessage<EnumMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.EnumMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "values", kind: "message", T: EnumValueMapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnumMapping {
    return new EnumMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnumMapping {
    return new EnumMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnumMapping {
    return new EnumMapping().fromJsonString(jsonString, options);
  }

  static equals(a: EnumMapping | PlainMessage<EnumMapping> | undefined, b: EnumMapping | PlainMessage<EnumMapping> | undefined): boolean {
    return proto3.util.equals(EnumMapping, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.EnumValueMapping
 */
export class EnumValueMapping extends Message<EnumValueMapping> {
  /**
   * @generated from field: string original = 1;
   */
  original = "";

  /**
   * @generated from field: string mapped = 2;
   */
  mapped = "";

  constructor(data?: PartialMessage<EnumValueMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.EnumValueMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "original", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mapped", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnumValueMapping {
    return new EnumValueMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnumValueMapping {
    return new EnumValueMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnumValueMapping {
    return new EnumValueMapping().fromJsonString(jsonString, options);
  }

  static equals(a: EnumValueMapping | PlainMessage<EnumValueMapping> | undefined, b: EnumValueMapping | PlainMessage<EnumValueMapping> | undefined): boolean {
    return proto3.util.equals(EnumValueMapping, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.NatsStreamConfiguration
 */
export class NatsStreamConfiguration extends Message<NatsStreamConfiguration> {
  /**
   * @generated from field: string consumer_name = 1;
   */
  consumerName = "";

  /**
   * @generated from field: string stream_name = 2;
   */
  streamName = "";

  /**
   * @generated from field: int32 consumer_inactive_threshold = 3;
   */
  consumerInactiveThreshold = 0;

  constructor(data?: PartialMessage<NatsStreamConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.NatsStreamConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consumer_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "stream_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "consumer_inactive_threshold", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NatsStreamConfiguration {
    return new NatsStreamConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NatsStreamConfiguration {
    return new NatsStreamConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NatsStreamConfiguration {
    return new NatsStreamConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: NatsStreamConfiguration | PlainMessage<NatsStreamConfiguration> | undefined, b: NatsStreamConfiguration | PlainMessage<NatsStreamConfiguration> | undefined): boolean {
    return proto3.util.equals(NatsStreamConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.NatsEventConfiguration
 */
export class NatsEventConfiguration extends Message<NatsEventConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.EngineEventConfiguration engine_event_configuration = 1;
   */
  engineEventConfiguration?: EngineEventConfiguration;

  /**
   * @generated from field: repeated string subjects = 2;
   */
  subjects: string[] = [];

  /**
   * @generated from field: wg.cosmo.node.v1.NatsStreamConfiguration stream_configuration = 3;
   */
  streamConfiguration?: NatsStreamConfiguration;

  constructor(data?: PartialMessage<NatsEventConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.NatsEventConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "engine_event_configuration", kind: "message", T: EngineEventConfiguration },
    { no: 2, name: "subjects", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "stream_configuration", kind: "message", T: NatsStreamConfiguration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NatsEventConfiguration {
    return new NatsEventConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NatsEventConfiguration {
    return new NatsEventConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NatsEventConfiguration {
    return new NatsEventConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: NatsEventConfiguration | PlainMessage<NatsEventConfiguration> | undefined, b: NatsEventConfiguration | PlainMessage<NatsEventConfiguration> | undefined): boolean {
    return proto3.util.equals(NatsEventConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.KafkaEventConfiguration
 */
export class KafkaEventConfiguration extends Message<KafkaEventConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.EngineEventConfiguration engine_event_configuration = 1;
   */
  engineEventConfiguration?: EngineEventConfiguration;

  /**
   * @generated from field: repeated string topics = 2;
   */
  topics: string[] = [];

  constructor(data?: PartialMessage<KafkaEventConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.KafkaEventConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "engine_event_configuration", kind: "message", T: EngineEventConfiguration },
    { no: 2, name: "topics", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KafkaEventConfiguration {
    return new KafkaEventConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KafkaEventConfiguration {
    return new KafkaEventConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KafkaEventConfiguration {
    return new KafkaEventConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: KafkaEventConfiguration | PlainMessage<KafkaEventConfiguration> | undefined, b: KafkaEventConfiguration | PlainMessage<KafkaEventConfiguration> | undefined): boolean {
    return proto3.util.equals(KafkaEventConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.RedisEventConfiguration
 */
export class RedisEventConfiguration extends Message<RedisEventConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.EngineEventConfiguration engine_event_configuration = 1;
   */
  engineEventConfiguration?: EngineEventConfiguration;

  /**
   * @generated from field: repeated string channels = 2;
   */
  channels: string[] = [];

  constructor(data?: PartialMessage<RedisEventConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.RedisEventConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "engine_event_configuration", kind: "message", T: EngineEventConfiguration },
    { no: 2, name: "channels", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedisEventConfiguration {
    return new RedisEventConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedisEventConfiguration {
    return new RedisEventConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedisEventConfiguration {
    return new RedisEventConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: RedisEventConfiguration | PlainMessage<RedisEventConfiguration> | undefined, b: RedisEventConfiguration | PlainMessage<RedisEventConfiguration> | undefined): boolean {
    return proto3.util.equals(RedisEventConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.EngineEventConfiguration
 */
export class EngineEventConfiguration extends Message<EngineEventConfiguration> {
  /**
   * @generated from field: string provider_id = 1;
   */
  providerId = "";

  /**
   * @generated from field: wg.cosmo.node.v1.EventType type = 2;
   */
  type = EventType.PUBLISH;

  /**
   * @generated from field: string type_name = 3;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 4;
   */
  fieldName = "";

  constructor(data?: PartialMessage<EngineEventConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.EngineEventConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(EventType) },
    { no: 3, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EngineEventConfiguration {
    return new EngineEventConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EngineEventConfiguration {
    return new EngineEventConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EngineEventConfiguration {
    return new EngineEventConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: EngineEventConfiguration | PlainMessage<EngineEventConfiguration> | undefined, b: EngineEventConfiguration | PlainMessage<EngineEventConfiguration> | undefined): boolean {
    return proto3.util.equals(EngineEventConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceCustomEvents
 */
export class DataSourceCustomEvents extends Message<DataSourceCustomEvents> {
  /**
   * @generated from field: repeated wg.cosmo.node.v1.NatsEventConfiguration nats = 1;
   */
  nats: NatsEventConfiguration[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.KafkaEventConfiguration kafka = 2;
   */
  kafka: KafkaEventConfiguration[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.RedisEventConfiguration redis = 3;
   */
  redis: RedisEventConfiguration[] = [];

  constructor(data?: PartialMessage<DataSourceCustomEvents>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceCustomEvents";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nats", kind: "message", T: NatsEventConfiguration, repeated: true },
    { no: 2, name: "kafka", kind: "message", T: KafkaEventConfiguration, repeated: true },
    { no: 3, name: "redis", kind: "message", T: RedisEventConfiguration, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceCustomEvents {
    return new DataSourceCustomEvents().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceCustomEvents {
    return new DataSourceCustomEvents().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceCustomEvents {
    return new DataSourceCustomEvents().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceCustomEvents | PlainMessage<DataSourceCustomEvents> | undefined, b: DataSourceCustomEvents | PlainMessage<DataSourceCustomEvents> | undefined): boolean {
    return proto3.util.equals(DataSourceCustomEvents, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceCustom_Static
 */
export class DataSourceCustom_Static extends Message<DataSourceCustom_Static> {
  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable data = 1;
   */
  data?: ConfigurationVariable;

  constructor(data?: PartialMessage<DataSourceCustom_Static>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceCustom_Static";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: ConfigurationVariable },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceCustom_Static {
    return new DataSourceCustom_Static().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceCustom_Static {
    return new DataSourceCustom_Static().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceCustom_Static {
    return new DataSourceCustom_Static().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceCustom_Static | PlainMessage<DataSourceCustom_Static> | undefined, b: DataSourceCustom_Static | PlainMessage<DataSourceCustom_Static> | undefined): boolean {
    return proto3.util.equals(DataSourceCustom_Static, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.ConfigurationVariable
 */
export class ConfigurationVariable extends Message<ConfigurationVariable> {
  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariableKind kind = 1;
   */
  kind = ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE;

  /**
   * @generated from field: string static_variable_content = 2;
   */
  staticVariableContent = "";

  /**
   * @generated from field: string environment_variable_name = 3;
   */
  environmentVariableName = "";

  /**
   * @generated from field: string environment_variable_default_value = 4;
   */
  environmentVariableDefaultValue = "";

  /**
   * @generated from field: string placeholder_variable_name = 5;
   */
  placeholderVariableName = "";

  constructor(data?: PartialMessage<ConfigurationVariable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ConfigurationVariable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(ConfigurationVariableKind) },
    { no: 2, name: "static_variable_content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "environment_variable_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "environment_variable_default_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "placeholder_variable_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigurationVariable {
    return new ConfigurationVariable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigurationVariable {
    return new ConfigurationVariable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigurationVariable {
    return new ConfigurationVariable().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigurationVariable | PlainMessage<ConfigurationVariable> | undefined, b: ConfigurationVariable | PlainMessage<ConfigurationVariable> | undefined): boolean {
    return proto3.util.equals(ConfigurationVariable, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DirectiveConfiguration
 */
export class DirectiveConfiguration extends Message<DirectiveConfiguration> {
  /**
   * @generated from field: string directive_name = 1;
   */
  directiveName = "";

  /**
   * @generated from field: string rename_to = 2;
   */
  renameTo = "";

  constructor(data?: PartialMessage<DirectiveConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DirectiveConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "directive_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rename_to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DirectiveConfiguration {
    return new DirectiveConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DirectiveConfiguration {
    return new DirectiveConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DirectiveConfiguration {
    return new DirectiveConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: DirectiveConfiguration | PlainMessage<DirectiveConfiguration> | undefined, b: DirectiveConfiguration | PlainMessage<DirectiveConfiguration> | undefined): boolean {
    return proto3.util.equals(DirectiveConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.URLQueryConfiguration
 */
export class URLQueryConfiguration extends Message<URLQueryConfiguration> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<URLQueryConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.URLQueryConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): URLQueryConfiguration {
    return new URLQueryConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): URLQueryConfiguration {
    return new URLQueryConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): URLQueryConfiguration {
    return new URLQueryConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: URLQueryConfiguration | PlainMessage<URLQueryConfiguration> | undefined, b: URLQueryConfiguration | PlainMessage<URLQueryConfiguration> | undefined): boolean {
    return proto3.util.equals(URLQueryConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.HTTPHeader
 */
export class HTTPHeader extends Message<HTTPHeader> {
  /**
   * @generated from field: repeated wg.cosmo.node.v1.ConfigurationVariable values = 1;
   */
  values: ConfigurationVariable[] = [];

  constructor(data?: PartialMessage<HTTPHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.HTTPHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "message", T: ConfigurationVariable, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPHeader {
    return new HTTPHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPHeader {
    return new HTTPHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPHeader {
    return new HTTPHeader().fromJsonString(jsonString, options);
  }

  static equals(a: HTTPHeader | PlainMessage<HTTPHeader> | undefined, b: HTTPHeader | PlainMessage<HTTPHeader> | undefined): boolean {
    return proto3.util.equals(HTTPHeader, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.MTLSConfiguration
 */
export class MTLSConfiguration extends Message<MTLSConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable key = 1;
   */
  key?: ConfigurationVariable;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable cert = 2;
   */
  cert?: ConfigurationVariable;

  /**
   * @generated from field: bool insecureSkipVerify = 3;
   */
  insecureSkipVerify = false;

  constructor(data?: PartialMessage<MTLSConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.MTLSConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: ConfigurationVariable },
    { no: 2, name: "cert", kind: "message", T: ConfigurationVariable },
    { no: 3, name: "insecureSkipVerify", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MTLSConfiguration {
    return new MTLSConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MTLSConfiguration {
    return new MTLSConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MTLSConfiguration {
    return new MTLSConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: MTLSConfiguration | PlainMessage<MTLSConfiguration> | undefined, b: MTLSConfiguration | PlainMessage<MTLSConfiguration> | undefined): boolean {
    return proto3.util.equals(MTLSConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GraphQLSubscriptionConfiguration
 */
export class GraphQLSubscriptionConfiguration extends Message<GraphQLSubscriptionConfiguration> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable url = 2;
   */
  url?: ConfigurationVariable;

  /**
   * @deprecated - Kept for backwards compatibility when decoding. Use protocol instead. 
   *
   * @generated from field: optional bool useSSE = 3;
   */
  useSSE?: boolean;

  /**
   * @generated from field: optional wg.cosmo.common.GraphQLSubscriptionProtocol protocol = 4;
   */
  protocol?: GraphQLSubscriptionProtocol;

  /**
   * @generated from field: optional wg.cosmo.common.GraphQLWebsocketSubprotocol websocketSubprotocol = 5;
   */
  websocketSubprotocol?: GraphQLWebsocketSubprotocol;

  constructor(data?: PartialMessage<GraphQLSubscriptionConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GraphQLSubscriptionConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "url", kind: "message", T: ConfigurationVariable },
    { no: 3, name: "useSSE", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "protocol", kind: "enum", T: proto3.getEnumType(GraphQLSubscriptionProtocol), opt: true },
    { no: 5, name: "websocketSubprotocol", kind: "enum", T: proto3.getEnumType(GraphQLWebsocketSubprotocol), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GraphQLSubscriptionConfiguration {
    return new GraphQLSubscriptionConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GraphQLSubscriptionConfiguration {
    return new GraphQLSubscriptionConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GraphQLSubscriptionConfiguration {
    return new GraphQLSubscriptionConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: GraphQLSubscriptionConfiguration | PlainMessage<GraphQLSubscriptionConfiguration> | undefined, b: GraphQLSubscriptionConfiguration | PlainMessage<GraphQLSubscriptionConfiguration> | undefined): boolean {
    return proto3.util.equals(GraphQLSubscriptionConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GraphQLFederationConfiguration
 */
export class GraphQLFederationConfiguration extends Message<GraphQLFederationConfiguration> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * @generated from field: string serviceSdl = 2;
   */
  serviceSdl = "";

  constructor(data?: PartialMessage<GraphQLFederationConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GraphQLFederationConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "serviceSdl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GraphQLFederationConfiguration {
    return new GraphQLFederationConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GraphQLFederationConfiguration {
    return new GraphQLFederationConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GraphQLFederationConfiguration {
    return new GraphQLFederationConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: GraphQLFederationConfiguration | PlainMessage<GraphQLFederationConfiguration> | undefined, b: GraphQLFederationConfiguration | PlainMessage<GraphQLFederationConfiguration> | undefined): boolean {
    return proto3.util.equals(GraphQLFederationConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.InternedString
 */
export class InternedString extends Message<InternedString> {
  /**
   * key to index into EngineConfiguration.stringStorage
   *
   * @generated from field: string key = 1;
   */
  key = "";

  constructor(data?: PartialMessage<InternedString>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.InternedString";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InternedString {
    return new InternedString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InternedString {
    return new InternedString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InternedString {
    return new InternedString().fromJsonString(jsonString, options);
  }

  static equals(a: InternedString | PlainMessage<InternedString> | undefined, b: InternedString | PlainMessage<InternedString> | undefined): boolean {
    return proto3.util.equals(InternedString, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SingleTypeField
 */
export class SingleTypeField extends Message<SingleTypeField> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 2;
   */
  fieldName = "";

  constructor(data?: PartialMessage<SingleTypeField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SingleTypeField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SingleTypeField {
    return new SingleTypeField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SingleTypeField {
    return new SingleTypeField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SingleTypeField {
    return new SingleTypeField().fromJsonString(jsonString, options);
  }

  static equals(a: SingleTypeField | PlainMessage<SingleTypeField> | undefined, b: SingleTypeField | PlainMessage<SingleTypeField> | undefined): boolean {
    return proto3.util.equals(SingleTypeField, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SubscriptionFieldCondition
 */
export class SubscriptionFieldCondition extends Message<SubscriptionFieldCondition> {
  /**
   * @generated from field: repeated string field_path = 1;
   */
  fieldPath: string[] = [];

  /**
   * @generated from field: string json = 2;
   */
  json = "";

  constructor(data?: PartialMessage<SubscriptionFieldCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SubscriptionFieldCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_path", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "json", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubscriptionFieldCondition {
    return new SubscriptionFieldCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubscriptionFieldCondition {
    return new SubscriptionFieldCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubscriptionFieldCondition {
    return new SubscriptionFieldCondition().fromJsonString(jsonString, options);
  }

  static equals(a: SubscriptionFieldCondition | PlainMessage<SubscriptionFieldCondition> | undefined, b: SubscriptionFieldCondition | PlainMessage<SubscriptionFieldCondition> | undefined): boolean {
    return proto3.util.equals(SubscriptionFieldCondition, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SubscriptionFilterCondition
 */
export class SubscriptionFilterCondition extends Message<SubscriptionFilterCondition> {
  /**
   * @generated from field: repeated wg.cosmo.node.v1.SubscriptionFilterCondition and = 1;
   */
  and: SubscriptionFilterCondition[] = [];

  /**
   * @generated from field: optional wg.cosmo.node.v1.SubscriptionFieldCondition in = 2;
   */
  in?: SubscriptionFieldCondition;

  /**
   * @generated from field: optional wg.cosmo.node.v1.SubscriptionFilterCondition not = 3;
   */
  not?: SubscriptionFilterCondition;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.SubscriptionFilterCondition or = 4;
   */
  or: SubscriptionFilterCondition[] = [];

  constructor(data?: PartialMessage<SubscriptionFilterCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SubscriptionFilterCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "and", kind: "message", T: SubscriptionFilterCondition, repeated: true },
    { no: 2, name: "in", kind: "message", T: SubscriptionFieldCondition, opt: true },
    { no: 3, name: "not", kind: "message", T: SubscriptionFilterCondition, opt: true },
    { no: 4, name: "or", kind: "message", T: SubscriptionFilterCondition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubscriptionFilterCondition {
    return new SubscriptionFilterCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubscriptionFilterCondition {
    return new SubscriptionFilterCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubscriptionFilterCondition {
    return new SubscriptionFilterCondition().fromJsonString(jsonString, options);
  }

  static equals(a: SubscriptionFilterCondition | PlainMessage<SubscriptionFilterCondition> | undefined, b: SubscriptionFilterCondition | PlainMessage<SubscriptionFilterCondition> | undefined): boolean {
    return proto3.util.equals(SubscriptionFilterCondition, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.CacheWarmerOperations
 */
export class CacheWarmerOperations extends Message<CacheWarmerOperations> {
  /**
   * @generated from field: repeated wg.cosmo.node.v1.Operation operations = 1;
   */
  operations: Operation[] = [];

  constructor(data?: PartialMessage<CacheWarmerOperations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.CacheWarmerOperations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operations", kind: "message", T: Operation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CacheWarmerOperations {
    return new CacheWarmerOperations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CacheWarmerOperations {
    return new CacheWarmerOperations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CacheWarmerOperations {
    return new CacheWarmerOperations().fromJsonString(jsonString, options);
  }

  static equals(a: CacheWarmerOperations | PlainMessage<CacheWarmerOperations> | undefined, b: CacheWarmerOperations | PlainMessage<CacheWarmerOperations> | undefined): boolean {
    return proto3.util.equals(CacheWarmerOperations, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.Operation
 */
export class Operation extends Message<Operation> {
  /**
   * @generated from field: wg.cosmo.node.v1.OperationRequest request = 1;
   */
  request?: OperationRequest;

  /**
   * @generated from field: wg.cosmo.node.v1.ClientInfo client = 2;
   */
  client?: ClientInfo;

  constructor(data?: PartialMessage<Operation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.Operation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request", kind: "message", T: OperationRequest },
    { no: 2, name: "client", kind: "message", T: ClientInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation {
    return new Operation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJsonString(jsonString, options);
  }

  static equals(a: Operation | PlainMessage<Operation> | undefined, b: Operation | PlainMessage<Operation> | undefined): boolean {
    return proto3.util.equals(Operation, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.OperationRequest
 */
export class OperationRequest extends Message<OperationRequest> {
  /**
   * @generated from field: string operation_name = 1;
   */
  operationName = "";

  /**
   * @generated from field: string query = 2;
   */
  query = "";

  /**
   * @generated from field: wg.cosmo.node.v1.Extension extensions = 3;
   */
  extensions?: Extension;

  constructor(data?: PartialMessage<OperationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.OperationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "extensions", kind: "message", T: Extension },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OperationRequest {
    return new OperationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OperationRequest {
    return new OperationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OperationRequest {
    return new OperationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: OperationRequest | PlainMessage<OperationRequest> | undefined, b: OperationRequest | PlainMessage<OperationRequest> | undefined): boolean {
    return proto3.util.equals(OperationRequest, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.Extension
 */
export class Extension extends Message<Extension> {
  /**
   * @generated from field: wg.cosmo.node.v1.PersistedQuery persisted_query = 1;
   */
  persistedQuery?: PersistedQuery;

  constructor(data?: PartialMessage<Extension>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.Extension";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "persisted_query", kind: "message", T: PersistedQuery },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Extension {
    return new Extension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Extension {
    return new Extension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Extension {
    return new Extension().fromJsonString(jsonString, options);
  }

  static equals(a: Extension | PlainMessage<Extension> | undefined, b: Extension | PlainMessage<Extension> | undefined): boolean {
    return proto3.util.equals(Extension, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.PersistedQuery
 */
export class PersistedQuery extends Message<PersistedQuery> {
  /**
   * @generated from field: string sha256_hash = 1;
   */
  sha256Hash = "";

  /**
   * @generated from field: int32 version = 2;
   */
  version = 0;

  constructor(data?: PartialMessage<PersistedQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.PersistedQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sha256_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PersistedQuery {
    return new PersistedQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PersistedQuery {
    return new PersistedQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PersistedQuery {
    return new PersistedQuery().fromJsonString(jsonString, options);
  }

  static equals(a: PersistedQuery | PlainMessage<PersistedQuery> | undefined, b: PersistedQuery | PlainMessage<PersistedQuery> | undefined): boolean {
    return proto3.util.equals(PersistedQuery, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.ClientInfo
 */
export class ClientInfo extends Message<ClientInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  constructor(data?: PartialMessage<ClientInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ClientInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientInfo {
    return new ClientInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientInfo {
    return new ClientInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientInfo {
    return new ClientInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ClientInfo | PlainMessage<ClientInfo> | undefined, b: ClientInfo | PlainMessage<ClientInfo> | undefined): boolean {
    return proto3.util.equals(ClientInfo, a, b);
  }
}

