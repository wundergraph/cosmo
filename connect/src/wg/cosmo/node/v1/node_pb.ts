// @generated by protoc-gen-es v1.4.1 with parameter "target=ts"
// @generated from file wg/cosmo/node/v1/node.proto (package wg.cosmo.node.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { EnumStatusCode, GraphQLSubscriptionProtocol } from "../../common/common_pb.js";

/**
 * @generated from enum wg.cosmo.node.v1.ArgumentRenderConfiguration
 */
export enum ArgumentRenderConfiguration {
  /**
   * @generated from enum value: RENDER_ARGUMENT_DEFAULT = 0;
   */
  RENDER_ARGUMENT_DEFAULT = 0,

  /**
   * @generated from enum value: RENDER_ARGUMENT_AS_GRAPHQL_VALUE = 1;
   */
  RENDER_ARGUMENT_AS_GRAPHQL_VALUE = 1,

  /**
   * @generated from enum value: RENDER_ARGUMENT_AS_ARRAY_CSV = 2;
   */
  RENDER_ARGUMENT_AS_ARRAY_CSV = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ArgumentRenderConfiguration)
proto3.util.setEnumType(ArgumentRenderConfiguration, "wg.cosmo.node.v1.ArgumentRenderConfiguration", [
  { no: 0, name: "RENDER_ARGUMENT_DEFAULT" },
  { no: 1, name: "RENDER_ARGUMENT_AS_GRAPHQL_VALUE" },
  { no: 2, name: "RENDER_ARGUMENT_AS_ARRAY_CSV" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.ArgumentSource
 */
export enum ArgumentSource {
  /**
   * @generated from enum value: OBJECT_FIELD = 0;
   */
  OBJECT_FIELD = 0,

  /**
   * @generated from enum value: FIELD_ARGUMENT = 1;
   */
  FIELD_ARGUMENT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ArgumentSource)
proto3.util.setEnumType(ArgumentSource, "wg.cosmo.node.v1.ArgumentSource", [
  { no: 0, name: "OBJECT_FIELD" },
  { no: 1, name: "FIELD_ARGUMENT" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.DataSourceKind
 */
export enum DataSourceKind {
  /**
   * @generated from enum value: STATIC = 0;
   */
  STATIC = 0,

  /**
   * @generated from enum value: GRAPHQL = 1;
   */
  GRAPHQL = 1,

  /**
   * @generated from enum value: PUBSUB = 2;
   */
  PUBSUB = 2,

  /**
   * @generated from enum value: HTTP = 3;
   */
  HTTP = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(DataSourceKind)
proto3.util.setEnumType(DataSourceKind, "wg.cosmo.node.v1.DataSourceKind", [
  { no: 0, name: "STATIC" },
  { no: 1, name: "GRAPHQL" },
  { no: 2, name: "PUBSUB" },
  { no: 3, name: "HTTP" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.EventType
 */
export enum EventType {
  /**
   * @generated from enum value: PUBLISH = 0;
   */
  PUBLISH = 0,

  /**
   * @generated from enum value: REQUEST = 1;
   */
  REQUEST = 1,

  /**
   * @generated from enum value: SUBSCRIBE = 2;
   */
  SUBSCRIBE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(EventType)
proto3.util.setEnumType(EventType, "wg.cosmo.node.v1.EventType", [
  { no: 0, name: "PUBLISH" },
  { no: 1, name: "REQUEST" },
  { no: 2, name: "SUBSCRIBE" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.ConfigurationVariableKind
 */
export enum ConfigurationVariableKind {
  /**
   * @generated from enum value: STATIC_CONFIGURATION_VARIABLE = 0;
   */
  STATIC_CONFIGURATION_VARIABLE = 0,

  /**
   * @generated from enum value: ENV_CONFIGURATION_VARIABLE = 1;
   */
  ENV_CONFIGURATION_VARIABLE = 1,

  /**
   * @generated from enum value: PLACEHOLDER_CONFIGURATION_VARIABLE = 2;
   */
  PLACEHOLDER_CONFIGURATION_VARIABLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConfigurationVariableKind)
proto3.util.setEnumType(ConfigurationVariableKind, "wg.cosmo.node.v1.ConfigurationVariableKind", [
  { no: 0, name: "STATIC_CONFIGURATION_VARIABLE" },
  { no: 1, name: "ENV_CONFIGURATION_VARIABLE" },
  { no: 2, name: "PLACEHOLDER_CONFIGURATION_VARIABLE" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.HTTPMethod
 */
export enum HTTPMethod {
  /**
   * @generated from enum value: GET = 0;
   */
  GET = 0,

  /**
   * @generated from enum value: POST = 1;
   */
  POST = 1,

  /**
   * @generated from enum value: PUT = 2;
   */
  PUT = 2,

  /**
   * @generated from enum value: DELETE = 3;
   */
  DELETE = 3,

  /**
   * @generated from enum value: OPTIONS = 4;
   */
  OPTIONS = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(HTTPMethod)
proto3.util.setEnumType(HTTPMethod, "wg.cosmo.node.v1.HTTPMethod", [
  { no: 0, name: "GET" },
  { no: 1, name: "POST" },
  { no: 2, name: "PUT" },
  { no: 3, name: "DELETE" },
  { no: 4, name: "OPTIONS" },
]);

/**
 * @generated from message wg.cosmo.node.v1.Subgraph
 */
export class Subgraph extends Message<Subgraph> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: string routing_url = 3;
   */
  routingUrl = "";

  constructor(data?: PartialMessage<Subgraph>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.Subgraph";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "routing_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subgraph {
    return new Subgraph().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subgraph {
    return new Subgraph().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subgraph {
    return new Subgraph().fromJsonString(jsonString, options);
  }

  static equals(a: Subgraph | PlainMessage<Subgraph> | undefined, b: Subgraph | PlainMessage<Subgraph> | undefined): boolean {
    return proto3.util.equals(Subgraph, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.RouterConfig
 */
export class RouterConfig extends Message<RouterConfig> {
  /**
   * @generated from field: wg.cosmo.node.v1.EngineConfiguration engine_config = 1;
   */
  engineConfig?: EngineConfiguration;

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.Subgraph subgraphs = 3;
   */
  subgraphs: Subgraph[] = [];

  constructor(data?: PartialMessage<RouterConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.RouterConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "engine_config", kind: "message", T: EngineConfiguration },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subgraphs", kind: "message", T: Subgraph, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouterConfig {
    return new RouterConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouterConfig {
    return new RouterConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouterConfig {
    return new RouterConfig().fromJsonString(jsonString, options);
  }

  static equals(a: RouterConfig | PlainMessage<RouterConfig> | undefined, b: RouterConfig | PlainMessage<RouterConfig> | undefined): boolean {
    return proto3.util.equals(RouterConfig, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.Response
 */
export class Response extends Message<Response> {
  /**
   * @generated from field: wg.cosmo.common.EnumStatusCode code = 1;
   */
  code = EnumStatusCode.OK;

  /**
   * details is an optional field which can be used to provide more details about the error.
   *
   * @generated from field: optional string details = 2;
   */
  details?: string;

  constructor(data?: PartialMessage<Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(EnumStatusCode) },
    { no: 2, name: "details", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Response {
    return new Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJsonString(jsonString, options);
  }

  static equals(a: Response | PlainMessage<Response> | undefined, b: Response | PlainMessage<Response> | undefined): boolean {
    return proto3.util.equals(Response, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.ResponseStatus
 */
export class ResponseStatus extends Message<ResponseStatus> {
  /**
   * @generated from field: int32 code = 1;
   */
  code = 0;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<ResponseStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ResponseStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponseStatus {
    return new ResponseStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponseStatus {
    return new ResponseStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponseStatus {
    return new ResponseStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ResponseStatus | PlainMessage<ResponseStatus> | undefined, b: ResponseStatus | PlainMessage<ResponseStatus> | undefined): boolean {
    return proto3.util.equals(ResponseStatus, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GetConfigRequest
 */
export class GetConfigRequest extends Message<GetConfigRequest> {
  /**
   * The FQDN of the graph to get the config for e.g. "wg.production"
   *
   * @generated from field: string graph_name = 1;
   */
  graphName = "";

  /**
   * The version to check for. If the version is not specified, the latest router config version will be returned.
   * Otherwise, the version will be used to check if a newer version of the router config is available.
   * That allow us to not send the router config if the version is the same.
   *
   * @generated from field: optional string version = 2;
   */
  version?: string;

  constructor(data?: PartialMessage<GetConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GetConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "graph_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigRequest | PlainMessage<GetConfigRequest> | undefined, b: GetConfigRequest | PlainMessage<GetConfigRequest> | undefined): boolean {
    return proto3.util.equals(GetConfigRequest, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GetConfigResponse
 */
export class GetConfigResponse extends Message<GetConfigResponse> {
  /**
   * @generated from field: wg.cosmo.node.v1.Response response = 1;
   */
  response?: Response;

  /**
   * RouterConfig is the router config for the graph. It can be nil when a version is specified and the version is the same as the latest version.
   *
   * @generated from field: optional wg.cosmo.node.v1.RouterConfig config = 2;
   */
  config?: RouterConfig;

  constructor(data?: PartialMessage<GetConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GetConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "message", T: Response },
    { no: 2, name: "config", kind: "message", T: RouterConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined, b: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetConfigResponse, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.RegistrationInfo
 */
export class RegistrationInfo extends Message<RegistrationInfo> {
  /**
   * @generated from field: wg.cosmo.node.v1.AccountLimits account_limits = 1;
   */
  accountLimits?: AccountLimits;

  /**
   * @generated from field: string graph_public_key = 2;
   */
  graphPublicKey = "";

  constructor(data?: PartialMessage<RegistrationInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.RegistrationInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_limits", kind: "message", T: AccountLimits },
    { no: 2, name: "graph_public_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegistrationInfo {
    return new RegistrationInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegistrationInfo {
    return new RegistrationInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegistrationInfo {
    return new RegistrationInfo().fromJsonString(jsonString, options);
  }

  static equals(a: RegistrationInfo | PlainMessage<RegistrationInfo> | undefined, b: RegistrationInfo | PlainMessage<RegistrationInfo> | undefined): boolean {
    return proto3.util.equals(RegistrationInfo, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.AccountLimits
 */
export class AccountLimits extends Message<AccountLimits> {
  /**
   * The maximum sampling rate for traces. Must be between 0 and 1.
   * 0 means no traces will be sampled and 1 means all traces will be sampled.
   *
   * @generated from field: float trace_sampling_rate = 1;
   */
  traceSamplingRate = 0;

  constructor(data?: PartialMessage<AccountLimits>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.AccountLimits";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trace_sampling_rate", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountLimits {
    return new AccountLimits().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountLimits {
    return new AccountLimits().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountLimits {
    return new AccountLimits().fromJsonString(jsonString, options);
  }

  static equals(a: AccountLimits | PlainMessage<AccountLimits> | undefined, b: AccountLimits | PlainMessage<AccountLimits> | undefined): boolean {
    return proto3.util.equals(AccountLimits, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SelfRegisterRequest
 */
export class SelfRegisterRequest extends Message<SelfRegisterRequest> {
  constructor(data?: PartialMessage<SelfRegisterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SelfRegisterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SelfRegisterRequest {
    return new SelfRegisterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SelfRegisterRequest {
    return new SelfRegisterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SelfRegisterRequest {
    return new SelfRegisterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SelfRegisterRequest | PlainMessage<SelfRegisterRequest> | undefined, b: SelfRegisterRequest | PlainMessage<SelfRegisterRequest> | undefined): boolean {
    return proto3.util.equals(SelfRegisterRequest, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SelfRegisterResponse
 */
export class SelfRegisterResponse extends Message<SelfRegisterResponse> {
  /**
   * @generated from field: wg.cosmo.node.v1.Response response = 1;
   */
  response?: Response;

  /**
   * @generated from field: optional wg.cosmo.node.v1.RegistrationInfo registrationInfo = 2;
   */
  registrationInfo?: RegistrationInfo;

  constructor(data?: PartialMessage<SelfRegisterResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SelfRegisterResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "message", T: Response },
    { no: 2, name: "registrationInfo", kind: "message", T: RegistrationInfo, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SelfRegisterResponse {
    return new SelfRegisterResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SelfRegisterResponse {
    return new SelfRegisterResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SelfRegisterResponse {
    return new SelfRegisterResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SelfRegisterResponse | PlainMessage<SelfRegisterResponse> | undefined, b: SelfRegisterResponse | PlainMessage<SelfRegisterResponse> | undefined): boolean {
    return proto3.util.equals(SelfRegisterResponse, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.EngineConfiguration
 */
export class EngineConfiguration extends Message<EngineConfiguration> {
  /**
   * @generated from field: int64 defaultFlushInterval = 1;
   */
  defaultFlushInterval = protoInt64.zero;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.DataSourceConfiguration datasource_configurations = 2;
   */
  datasourceConfigurations: DataSourceConfiguration[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.FieldConfiguration field_configurations = 3;
   */
  fieldConfigurations: FieldConfiguration[] = [];

  /**
   * @generated from field: string graphqlSchema = 4;
   */
  graphqlSchema = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.TypeConfiguration type_configurations = 5;
   */
  typeConfigurations: TypeConfiguration[] = [];

  /**
   * @generated from field: map<string, string> string_storage = 6;
   */
  stringStorage: { [key: string]: string } = {};

  constructor(data?: PartialMessage<EngineConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.EngineConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "defaultFlushInterval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "datasource_configurations", kind: "message", T: DataSourceConfiguration, repeated: true },
    { no: 3, name: "field_configurations", kind: "message", T: FieldConfiguration, repeated: true },
    { no: 4, name: "graphqlSchema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "type_configurations", kind: "message", T: TypeConfiguration, repeated: true },
    { no: 6, name: "string_storage", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EngineConfiguration {
    return new EngineConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EngineConfiguration {
    return new EngineConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EngineConfiguration {
    return new EngineConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: EngineConfiguration | PlainMessage<EngineConfiguration> | undefined, b: EngineConfiguration | PlainMessage<EngineConfiguration> | undefined): boolean {
    return proto3.util.equals(EngineConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceConfiguration
 */
export class DataSourceConfiguration extends Message<DataSourceConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceKind kind = 1;
   */
  kind = DataSourceKind.STATIC;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.TypeField root_nodes = 2;
   */
  rootNodes: TypeField[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.TypeField child_nodes = 3;
   */
  childNodes: TypeField[] = [];

  /**
   * @generated from field: bool override_field_path_from_alias = 4;
   */
  overrideFieldPathFromAlias = false;

  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceCustom_GraphQL custom_graphql = 5;
   */
  customGraphql?: DataSourceCustom_GraphQL;

  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceCustom_Static custom_static = 6;
   */
  customStatic?: DataSourceCustom_Static;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.DirectiveConfiguration directives = 7;
   */
  directives: DirectiveConfiguration[] = [];

  /**
   * @generated from field: int64 request_timeout_seconds = 8;
   */
  requestTimeoutSeconds = protoInt64.zero;

  /**
   * @generated from field: string id = 9;
   */
  id = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.RequiredField keys = 10;
   */
  keys: RequiredField[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.RequiredField provides = 11;
   */
  provides: RequiredField[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.RequiredField requires = 12;
   */
  requires: RequiredField[] = [];

  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceCustom_Events custom_events = 13;
   */
  customEvents?: DataSourceCustom_Events;

  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceCustom_HTTP custom_http = 14;
   */
  customHttp?: DataSourceCustom_HTTP;

  constructor(data?: PartialMessage<DataSourceConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(DataSourceKind) },
    { no: 2, name: "root_nodes", kind: "message", T: TypeField, repeated: true },
    { no: 3, name: "child_nodes", kind: "message", T: TypeField, repeated: true },
    { no: 4, name: "override_field_path_from_alias", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "custom_graphql", kind: "message", T: DataSourceCustom_GraphQL },
    { no: 6, name: "custom_static", kind: "message", T: DataSourceCustom_Static },
    { no: 7, name: "directives", kind: "message", T: DirectiveConfiguration, repeated: true },
    { no: 8, name: "request_timeout_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "keys", kind: "message", T: RequiredField, repeated: true },
    { no: 11, name: "provides", kind: "message", T: RequiredField, repeated: true },
    { no: 12, name: "requires", kind: "message", T: RequiredField, repeated: true },
    { no: 13, name: "custom_events", kind: "message", T: DataSourceCustom_Events },
    { no: 14, name: "custom_http", kind: "message", T: DataSourceCustom_HTTP },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceConfiguration {
    return new DataSourceConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceConfiguration {
    return new DataSourceConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceConfiguration {
    return new DataSourceConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceConfiguration | PlainMessage<DataSourceConfiguration> | undefined, b: DataSourceConfiguration | PlainMessage<DataSourceConfiguration> | undefined): boolean {
    return proto3.util.equals(DataSourceConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.FieldConfiguration
 */
export class FieldConfiguration extends Message<FieldConfiguration> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 2;
   */
  fieldName = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.ArgumentConfiguration arguments_configuration = 3;
   */
  argumentsConfiguration: ArgumentConfiguration[] = [];

  constructor(data?: PartialMessage<FieldConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.FieldConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "arguments_configuration", kind: "message", T: ArgumentConfiguration, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldConfiguration {
    return new FieldConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldConfiguration {
    return new FieldConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldConfiguration {
    return new FieldConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: FieldConfiguration | PlainMessage<FieldConfiguration> | undefined, b: FieldConfiguration | PlainMessage<FieldConfiguration> | undefined): boolean {
    return proto3.util.equals(FieldConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.ArgumentConfiguration
 */
export class ArgumentConfiguration extends Message<ArgumentConfiguration> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: wg.cosmo.node.v1.ArgumentSource source_type = 2;
   */
  sourceType = ArgumentSource.OBJECT_FIELD;

  constructor(data?: PartialMessage<ArgumentConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ArgumentConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source_type", kind: "enum", T: proto3.getEnumType(ArgumentSource) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgumentConfiguration {
    return new ArgumentConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgumentConfiguration {
    return new ArgumentConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgumentConfiguration {
    return new ArgumentConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: ArgumentConfiguration | PlainMessage<ArgumentConfiguration> | undefined, b: ArgumentConfiguration | PlainMessage<ArgumentConfiguration> | undefined): boolean {
    return proto3.util.equals(ArgumentConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.TypeConfiguration
 */
export class TypeConfiguration extends Message<TypeConfiguration> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string rename_to = 2;
   */
  renameTo = "";

  constructor(data?: PartialMessage<TypeConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.TypeConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rename_to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypeConfiguration {
    return new TypeConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypeConfiguration {
    return new TypeConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypeConfiguration {
    return new TypeConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: TypeConfiguration | PlainMessage<TypeConfiguration> | undefined, b: TypeConfiguration | PlainMessage<TypeConfiguration> | undefined): boolean {
    return proto3.util.equals(TypeConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.TypeField
 */
export class TypeField extends Message<TypeField> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: repeated string field_names = 2;
   */
  fieldNames: string[] = [];

  constructor(data?: PartialMessage<TypeField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.TypeField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypeField {
    return new TypeField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypeField {
    return new TypeField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypeField {
    return new TypeField().fromJsonString(jsonString, options);
  }

  static equals(a: TypeField | PlainMessage<TypeField> | undefined, b: TypeField | PlainMessage<TypeField> | undefined): boolean {
    return proto3.util.equals(TypeField, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.RequiredField
 */
export class RequiredField extends Message<RequiredField> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 2;
   */
  fieldName = "";

  /**
   * @generated from field: string selection_set = 3;
   */
  selectionSet = "";

  constructor(data?: PartialMessage<RequiredField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.RequiredField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "selection_set", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequiredField {
    return new RequiredField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequiredField {
    return new RequiredField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequiredField {
    return new RequiredField().fromJsonString(jsonString, options);
  }

  static equals(a: RequiredField | PlainMessage<RequiredField> | undefined, b: RequiredField | PlainMessage<RequiredField> | undefined): boolean {
    return proto3.util.equals(RequiredField, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.FetchConfiguration
 */
export class FetchConfiguration extends Message<FetchConfiguration> {
  /**
   * You should either configure url OR a combination of baseURL and path
   * If url resolves to a non empty string, it takes precedence over baseURL and path
   * If url resolves to an empty string, the url will be configured as "{{baseURL}}{{path}}"
   *
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable url = 1;
   */
  url?: ConfigurationVariable;

  /**
   * @generated from field: wg.cosmo.node.v1.HTTPMethod method = 2;
   */
  method = HTTPMethod.GET;

  /**
   * @generated from field: map<string, wg.cosmo.node.v1.HTTPHeader> header = 3;
   */
  header: { [key: string]: HTTPHeader } = {};

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable body = 4;
   */
  body?: ConfigurationVariable;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.URLQueryConfiguration query = 5;
   */
  query: URLQueryConfiguration[] = [];

  /**
   * urlEncodeBody defines whether the body should be URL encoded or not
   * by default, the body will be JSON encoded
   * setting urlEncodeBody to true will render the body empty,
   * the Header Content-Type will be set to application/x-www-form-urlencoded,
   * and the body will be URL encoded and set as the URL Query String
   *
   * @generated from field: bool url_encode_body = 7;
   */
  urlEncodeBody = false;

  /**
   * @generated from field: wg.cosmo.node.v1.MTLSConfiguration mtls = 8;
   */
  mtls?: MTLSConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable base_url = 9;
   */
  baseUrl?: ConfigurationVariable;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable path = 10;
   */
  path?: ConfigurationVariable;

  /**
   * @generated from field: optional wg.cosmo.node.v1.ConfigurationVariable http_proxy_url = 11;
   */
  httpProxyUrl?: ConfigurationVariable;

  constructor(data?: PartialMessage<FetchConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.FetchConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "message", T: ConfigurationVariable },
    { no: 2, name: "method", kind: "enum", T: proto3.getEnumType(HTTPMethod) },
    { no: 3, name: "header", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: HTTPHeader} },
    { no: 4, name: "body", kind: "message", T: ConfigurationVariable },
    { no: 5, name: "query", kind: "message", T: URLQueryConfiguration, repeated: true },
    { no: 7, name: "url_encode_body", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "mtls", kind: "message", T: MTLSConfiguration },
    { no: 9, name: "base_url", kind: "message", T: ConfigurationVariable },
    { no: 10, name: "path", kind: "message", T: ConfigurationVariable },
    { no: 11, name: "http_proxy_url", kind: "message", T: ConfigurationVariable, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchConfiguration {
    return new FetchConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchConfiguration {
    return new FetchConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchConfiguration {
    return new FetchConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: FetchConfiguration | PlainMessage<FetchConfiguration> | undefined, b: FetchConfiguration | PlainMessage<FetchConfiguration> | undefined): boolean {
    return proto3.util.equals(FetchConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.StatusCodeTypeMapping
 */
export class StatusCodeTypeMapping extends Message<StatusCodeTypeMapping> {
  /**
   * @generated from field: int64 status_code = 1;
   */
  statusCode = protoInt64.zero;

  /**
   * @generated from field: string type_name = 2;
   */
  typeName = "";

  /**
   * @generated from field: bool inject_status_code_into_body = 3;
   */
  injectStatusCodeIntoBody = false;

  constructor(data?: PartialMessage<StatusCodeTypeMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.StatusCodeTypeMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status_code", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "inject_status_code_into_body", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusCodeTypeMapping {
    return new StatusCodeTypeMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusCodeTypeMapping {
    return new StatusCodeTypeMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusCodeTypeMapping {
    return new StatusCodeTypeMapping().fromJsonString(jsonString, options);
  }

  static equals(a: StatusCodeTypeMapping | PlainMessage<StatusCodeTypeMapping> | undefined, b: StatusCodeTypeMapping | PlainMessage<StatusCodeTypeMapping> | undefined): boolean {
    return proto3.util.equals(StatusCodeTypeMapping, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceCustom_GraphQL
 */
export class DataSourceCustom_GraphQL extends Message<DataSourceCustom_GraphQL> {
  /**
   * @generated from field: wg.cosmo.node.v1.FetchConfiguration fetch = 1;
   */
  fetch?: FetchConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.GraphQLSubscriptionConfiguration subscription = 2;
   */
  subscription?: GraphQLSubscriptionConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.GraphQLFederationConfiguration federation = 3;
   */
  federation?: GraphQLFederationConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.InternedString upstream_schema = 4;
   */
  upstreamSchema?: InternedString;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.SingleTypeField custom_scalar_type_fields = 6;
   */
  customScalarTypeFields: SingleTypeField[] = [];

  constructor(data?: PartialMessage<DataSourceCustom_GraphQL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceCustom_GraphQL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fetch", kind: "message", T: FetchConfiguration },
    { no: 2, name: "subscription", kind: "message", T: GraphQLSubscriptionConfiguration },
    { no: 3, name: "federation", kind: "message", T: GraphQLFederationConfiguration },
    { no: 4, name: "upstream_schema", kind: "message", T: InternedString },
    { no: 6, name: "custom_scalar_type_fields", kind: "message", T: SingleTypeField, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceCustom_GraphQL {
    return new DataSourceCustom_GraphQL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceCustom_GraphQL {
    return new DataSourceCustom_GraphQL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceCustom_GraphQL {
    return new DataSourceCustom_GraphQL().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceCustom_GraphQL | PlainMessage<DataSourceCustom_GraphQL> | undefined, b: DataSourceCustom_GraphQL | PlainMessage<DataSourceCustom_GraphQL> | undefined): boolean {
    return proto3.util.equals(DataSourceCustom_GraphQL, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.EventConfiguration
 */
export class EventConfiguration extends Message<EventConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.EventType type = 1;
   */
  type = EventType.PUBLISH;

  /**
   * @generated from field: string type_name = 2;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 3;
   */
  fieldName = "";

  /**
   * @generated from field: string topic = 4;
   */
  topic = "";

  /**
   * @generated from field: string source_id = 5;
   */
  sourceId = "";

  constructor(data?: PartialMessage<EventConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.EventConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(EventType) },
    { no: 2, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "topic", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "source_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventConfiguration {
    return new EventConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventConfiguration {
    return new EventConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventConfiguration {
    return new EventConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: EventConfiguration | PlainMessage<EventConfiguration> | undefined, b: EventConfiguration | PlainMessage<EventConfiguration> | undefined): boolean {
    return proto3.util.equals(EventConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceCustom_Events
 */
export class DataSourceCustom_Events extends Message<DataSourceCustom_Events> {
  /**
   * @generated from field: repeated wg.cosmo.node.v1.EventConfiguration events = 1;
   */
  events: EventConfiguration[] = [];

  constructor(data?: PartialMessage<DataSourceCustom_Events>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceCustom_Events";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: EventConfiguration, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceCustom_Events {
    return new DataSourceCustom_Events().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceCustom_Events {
    return new DataSourceCustom_Events().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceCustom_Events {
    return new DataSourceCustom_Events().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceCustom_Events | PlainMessage<DataSourceCustom_Events> | undefined, b: DataSourceCustom_Events | PlainMessage<DataSourceCustom_Events> | undefined): boolean {
    return proto3.util.equals(DataSourceCustom_Events, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.HTTPFetchConfiguration
 */
export class HTTPFetchConfiguration extends Message<HTTPFetchConfiguration> {
  /**
   * @generated from field: string source_name = 1;
   */
  sourceName = "";

  /**
   * @generated from field: string endpoint = 2;
   */
  endpoint = "";

  /**
   * @generated from field: wg.cosmo.node.v1.HTTPObjMap operationHeaders = 3;
   */
  operationHeaders?: HTTPObjMap;

  /**
   * @generated from field: wg.cosmo.node.v1.HTTPObjMap queryStringOptions = 4;
   */
  queryStringOptions?: HTTPObjMap;

  /**
   * @generated from field: wg.cosmo.node.v1.HTTPObjMap queryParams = 5;
   */
  queryParams?: HTTPObjMap;

  constructor(data?: PartialMessage<HTTPFetchConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.HTTPFetchConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "operationHeaders", kind: "message", T: HTTPObjMap },
    { no: 4, name: "queryStringOptions", kind: "message", T: HTTPObjMap },
    { no: 5, name: "queryParams", kind: "message", T: HTTPObjMap },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPFetchConfiguration {
    return new HTTPFetchConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPFetchConfiguration {
    return new HTTPFetchConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPFetchConfiguration {
    return new HTTPFetchConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: HTTPFetchConfiguration | PlainMessage<HTTPFetchConfiguration> | undefined, b: HTTPFetchConfiguration | PlainMessage<HTTPFetchConfiguration> | undefined): boolean {
    return proto3.util.equals(HTTPFetchConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.HTTPObjMapValue
 */
export class HTTPObjMapValue extends Message<HTTPObjMapValue> {
  /**
   * @generated from field: string string_value = 1;
   */
  stringValue = "";

  /**
   * @generated from field: map<string, wg.cosmo.node.v1.HTTPObjMapValue> map_values = 2;
   */
  mapValues: { [key: string]: HTTPObjMapValue } = {};

  constructor(data?: PartialMessage<HTTPObjMapValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.HTTPObjMapValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "string_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "map_values", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: HTTPObjMapValue} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPObjMapValue {
    return new HTTPObjMapValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPObjMapValue {
    return new HTTPObjMapValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPObjMapValue {
    return new HTTPObjMapValue().fromJsonString(jsonString, options);
  }

  static equals(a: HTTPObjMapValue | PlainMessage<HTTPObjMapValue> | undefined, b: HTTPObjMapValue | PlainMessage<HTTPObjMapValue> | undefined): boolean {
    return proto3.util.equals(HTTPObjMapValue, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.HTTPObjMap
 */
export class HTTPObjMap extends Message<HTTPObjMap> {
  /**
   * @generated from field: map<string, wg.cosmo.node.v1.HTTPObjMapValue> values = 1;
   */
  values: { [key: string]: HTTPObjMapValue } = {};

  constructor(data?: PartialMessage<HTTPObjMap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.HTTPObjMap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: HTTPObjMapValue} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPObjMap {
    return new HTTPObjMap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPObjMap {
    return new HTTPObjMap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPObjMap {
    return new HTTPObjMap().fromJsonString(jsonString, options);
  }

  static equals(a: HTTPObjMap | PlainMessage<HTTPObjMap> | undefined, b: HTTPObjMap | PlainMessage<HTTPObjMap> | undefined): boolean {
    return proto3.util.equals(HTTPObjMap, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.HTTPOperationConfiguration
 */
export class HTTPOperationConfiguration extends Message<HTTPOperationConfiguration> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 2;
   */
  fieldName = "";

  /**
   * @generated from field: string path = 3;
   */
  path = "";

  /**
   * @generated from field: wg.cosmo.node.v1.HTTPObjMap operation_specific_headers = 4;
   */
  operationSpecificHeaders?: HTTPObjMap;

  /**
   * @generated from field: string http_method = 5;
   */
  httpMethod = "";

  /**
   * @generated from field: bool is_binary = 6;
   */
  isBinary = false;

  /**
   * @generated from field: wg.cosmo.node.v1.HTTPObjMap request_base_body = 7;
   */
  requestBaseBody?: HTTPObjMap;

  /**
   * @generated from field: wg.cosmo.node.v1.HTTPObjMap query_param_arg_map = 8;
   */
  queryParamArgMap?: HTTPObjMap;

  /**
   * @generated from field: wg.cosmo.node.v1.HTTPObjMap query_string_options_by_param = 9;
   */
  queryStringOptionsByParam?: HTTPObjMap;

  constructor(data?: PartialMessage<HTTPOperationConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.HTTPOperationConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "operation_specific_headers", kind: "message", T: HTTPObjMap },
    { no: 5, name: "http_method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "is_binary", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "request_base_body", kind: "message", T: HTTPObjMap },
    { no: 8, name: "query_param_arg_map", kind: "message", T: HTTPObjMap },
    { no: 9, name: "query_string_options_by_param", kind: "message", T: HTTPObjMap },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPOperationConfiguration {
    return new HTTPOperationConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPOperationConfiguration {
    return new HTTPOperationConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPOperationConfiguration {
    return new HTTPOperationConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: HTTPOperationConfiguration | PlainMessage<HTTPOperationConfiguration> | undefined, b: HTTPOperationConfiguration | PlainMessage<HTTPOperationConfiguration> | undefined): boolean {
    return proto3.util.equals(HTTPOperationConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceCustom_HTTP
 */
export class DataSourceCustom_HTTP extends Message<DataSourceCustom_HTTP> {
  /**
   * @generated from field: wg.cosmo.node.v1.HTTPFetchConfiguration fetch = 1;
   */
  fetch?: HTTPFetchConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.GraphQLFederationConfiguration federation = 2;
   */
  federation?: GraphQLFederationConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.InternedString upstream_schema = 3;
   */
  upstreamSchema?: InternedString;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.SingleTypeField custom_scalar_type_fields = 4;
   */
  customScalarTypeFields: SingleTypeField[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.HTTPOperationConfiguration operations = 5;
   */
  operations: HTTPOperationConfiguration[] = [];

  constructor(data?: PartialMessage<DataSourceCustom_HTTP>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceCustom_HTTP";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fetch", kind: "message", T: HTTPFetchConfiguration },
    { no: 2, name: "federation", kind: "message", T: GraphQLFederationConfiguration },
    { no: 3, name: "upstream_schema", kind: "message", T: InternedString },
    { no: 4, name: "custom_scalar_type_fields", kind: "message", T: SingleTypeField, repeated: true },
    { no: 5, name: "operations", kind: "message", T: HTTPOperationConfiguration, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceCustom_HTTP {
    return new DataSourceCustom_HTTP().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceCustom_HTTP {
    return new DataSourceCustom_HTTP().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceCustom_HTTP {
    return new DataSourceCustom_HTTP().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceCustom_HTTP | PlainMessage<DataSourceCustom_HTTP> | undefined, b: DataSourceCustom_HTTP | PlainMessage<DataSourceCustom_HTTP> | undefined): boolean {
    return proto3.util.equals(DataSourceCustom_HTTP, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceCustom_Static
 */
export class DataSourceCustom_Static extends Message<DataSourceCustom_Static> {
  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable data = 1;
   */
  data?: ConfigurationVariable;

  constructor(data?: PartialMessage<DataSourceCustom_Static>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceCustom_Static";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: ConfigurationVariable },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceCustom_Static {
    return new DataSourceCustom_Static().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceCustom_Static {
    return new DataSourceCustom_Static().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceCustom_Static {
    return new DataSourceCustom_Static().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceCustom_Static | PlainMessage<DataSourceCustom_Static> | undefined, b: DataSourceCustom_Static | PlainMessage<DataSourceCustom_Static> | undefined): boolean {
    return proto3.util.equals(DataSourceCustom_Static, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.ConfigurationVariable
 */
export class ConfigurationVariable extends Message<ConfigurationVariable> {
  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariableKind kind = 1;
   */
  kind = ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE;

  /**
   * @generated from field: string static_variable_content = 2;
   */
  staticVariableContent = "";

  /**
   * @generated from field: string environment_variable_name = 3;
   */
  environmentVariableName = "";

  /**
   * @generated from field: string environment_variable_default_value = 4;
   */
  environmentVariableDefaultValue = "";

  /**
   * @generated from field: string placeholder_variable_name = 5;
   */
  placeholderVariableName = "";

  constructor(data?: PartialMessage<ConfigurationVariable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ConfigurationVariable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(ConfigurationVariableKind) },
    { no: 2, name: "static_variable_content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "environment_variable_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "environment_variable_default_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "placeholder_variable_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigurationVariable {
    return new ConfigurationVariable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigurationVariable {
    return new ConfigurationVariable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigurationVariable {
    return new ConfigurationVariable().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigurationVariable | PlainMessage<ConfigurationVariable> | undefined, b: ConfigurationVariable | PlainMessage<ConfigurationVariable> | undefined): boolean {
    return proto3.util.equals(ConfigurationVariable, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DirectiveConfiguration
 */
export class DirectiveConfiguration extends Message<DirectiveConfiguration> {
  /**
   * @generated from field: string directive_name = 1;
   */
  directiveName = "";

  /**
   * @generated from field: string rename_to = 2;
   */
  renameTo = "";

  constructor(data?: PartialMessage<DirectiveConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DirectiveConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "directive_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rename_to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DirectiveConfiguration {
    return new DirectiveConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DirectiveConfiguration {
    return new DirectiveConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DirectiveConfiguration {
    return new DirectiveConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: DirectiveConfiguration | PlainMessage<DirectiveConfiguration> | undefined, b: DirectiveConfiguration | PlainMessage<DirectiveConfiguration> | undefined): boolean {
    return proto3.util.equals(DirectiveConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.URLQueryConfiguration
 */
export class URLQueryConfiguration extends Message<URLQueryConfiguration> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<URLQueryConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.URLQueryConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): URLQueryConfiguration {
    return new URLQueryConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): URLQueryConfiguration {
    return new URLQueryConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): URLQueryConfiguration {
    return new URLQueryConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: URLQueryConfiguration | PlainMessage<URLQueryConfiguration> | undefined, b: URLQueryConfiguration | PlainMessage<URLQueryConfiguration> | undefined): boolean {
    return proto3.util.equals(URLQueryConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.HTTPHeader
 */
export class HTTPHeader extends Message<HTTPHeader> {
  /**
   * @generated from field: repeated wg.cosmo.node.v1.ConfigurationVariable values = 1;
   */
  values: ConfigurationVariable[] = [];

  constructor(data?: PartialMessage<HTTPHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.HTTPHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "message", T: ConfigurationVariable, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPHeader {
    return new HTTPHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPHeader {
    return new HTTPHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPHeader {
    return new HTTPHeader().fromJsonString(jsonString, options);
  }

  static equals(a: HTTPHeader | PlainMessage<HTTPHeader> | undefined, b: HTTPHeader | PlainMessage<HTTPHeader> | undefined): boolean {
    return proto3.util.equals(HTTPHeader, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.MTLSConfiguration
 */
export class MTLSConfiguration extends Message<MTLSConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable key = 1;
   */
  key?: ConfigurationVariable;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable cert = 2;
   */
  cert?: ConfigurationVariable;

  /**
   * @generated from field: bool insecureSkipVerify = 3;
   */
  insecureSkipVerify = false;

  constructor(data?: PartialMessage<MTLSConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.MTLSConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: ConfigurationVariable },
    { no: 2, name: "cert", kind: "message", T: ConfigurationVariable },
    { no: 3, name: "insecureSkipVerify", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MTLSConfiguration {
    return new MTLSConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MTLSConfiguration {
    return new MTLSConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MTLSConfiguration {
    return new MTLSConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: MTLSConfiguration | PlainMessage<MTLSConfiguration> | undefined, b: MTLSConfiguration | PlainMessage<MTLSConfiguration> | undefined): boolean {
    return proto3.util.equals(MTLSConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GraphQLSubscriptionConfiguration
 */
export class GraphQLSubscriptionConfiguration extends Message<GraphQLSubscriptionConfiguration> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable url = 2;
   */
  url?: ConfigurationVariable;

  /**
   * @deprecated - Kept for backwards compatibility when decoding. Use protocol instead. 
   *
   * @generated from field: optional bool useSSE = 3;
   */
  useSSE?: boolean;

  /**
   * @generated from field: optional wg.cosmo.common.GraphQLSubscriptionProtocol protocol = 4;
   */
  protocol?: GraphQLSubscriptionProtocol;

  constructor(data?: PartialMessage<GraphQLSubscriptionConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GraphQLSubscriptionConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "url", kind: "message", T: ConfigurationVariable },
    { no: 3, name: "useSSE", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "protocol", kind: "enum", T: proto3.getEnumType(GraphQLSubscriptionProtocol), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GraphQLSubscriptionConfiguration {
    return new GraphQLSubscriptionConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GraphQLSubscriptionConfiguration {
    return new GraphQLSubscriptionConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GraphQLSubscriptionConfiguration {
    return new GraphQLSubscriptionConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: GraphQLSubscriptionConfiguration | PlainMessage<GraphQLSubscriptionConfiguration> | undefined, b: GraphQLSubscriptionConfiguration | PlainMessage<GraphQLSubscriptionConfiguration> | undefined): boolean {
    return proto3.util.equals(GraphQLSubscriptionConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GraphQLFederationConfiguration
 */
export class GraphQLFederationConfiguration extends Message<GraphQLFederationConfiguration> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * @generated from field: string serviceSdl = 2;
   */
  serviceSdl = "";

  constructor(data?: PartialMessage<GraphQLFederationConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GraphQLFederationConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "serviceSdl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GraphQLFederationConfiguration {
    return new GraphQLFederationConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GraphQLFederationConfiguration {
    return new GraphQLFederationConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GraphQLFederationConfiguration {
    return new GraphQLFederationConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: GraphQLFederationConfiguration | PlainMessage<GraphQLFederationConfiguration> | undefined, b: GraphQLFederationConfiguration | PlainMessage<GraphQLFederationConfiguration> | undefined): boolean {
    return proto3.util.equals(GraphQLFederationConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.InternedString
 */
export class InternedString extends Message<InternedString> {
  /**
   * key to index into EngineConfiguration.stringStorage
   *
   * @generated from field: string key = 1;
   */
  key = "";

  constructor(data?: PartialMessage<InternedString>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.InternedString";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InternedString {
    return new InternedString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InternedString {
    return new InternedString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InternedString {
    return new InternedString().fromJsonString(jsonString, options);
  }

  static equals(a: InternedString | PlainMessage<InternedString> | undefined, b: InternedString | PlainMessage<InternedString> | undefined): boolean {
    return proto3.util.equals(InternedString, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SingleTypeField
 */
export class SingleTypeField extends Message<SingleTypeField> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 2;
   */
  fieldName = "";

  constructor(data?: PartialMessage<SingleTypeField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SingleTypeField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SingleTypeField {
    return new SingleTypeField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SingleTypeField {
    return new SingleTypeField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SingleTypeField {
    return new SingleTypeField().fromJsonString(jsonString, options);
  }

  static equals(a: SingleTypeField | PlainMessage<SingleTypeField> | undefined, b: SingleTypeField | PlainMessage<SingleTypeField> | undefined): boolean {
    return proto3.util.equals(SingleTypeField, a, b);
  }
}

