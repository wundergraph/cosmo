// @generated by protoc-gen-es v1.4.1 with parameter "target=ts"
// @generated from file wg/cosmo/node/v1/node.proto (package wg.cosmo.node.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { EnumStatusCode, GraphQLSubscriptionProtocol, GraphQLWebsocketSubprotocol } from "../../common/common_pb.js";

/**
 * @generated from enum wg.cosmo.node.v1.ArgumentRenderConfiguration
 */
export enum ArgumentRenderConfiguration {
  /**
   * @generated from enum value: RENDER_ARGUMENT_DEFAULT = 0;
   */
  RENDER_ARGUMENT_DEFAULT = 0,

  /**
   * @generated from enum value: RENDER_ARGUMENT_AS_GRAPHQL_VALUE = 1;
   */
  RENDER_ARGUMENT_AS_GRAPHQL_VALUE = 1,

  /**
   * @generated from enum value: RENDER_ARGUMENT_AS_ARRAY_CSV = 2;
   */
  RENDER_ARGUMENT_AS_ARRAY_CSV = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ArgumentRenderConfiguration)
proto3.util.setEnumType(ArgumentRenderConfiguration, "wg.cosmo.node.v1.ArgumentRenderConfiguration", [
  { no: 0, name: "RENDER_ARGUMENT_DEFAULT" },
  { no: 1, name: "RENDER_ARGUMENT_AS_GRAPHQL_VALUE" },
  { no: 2, name: "RENDER_ARGUMENT_AS_ARRAY_CSV" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.ArgumentSource
 */
export enum ArgumentSource {
  /**
   * @generated from enum value: OBJECT_FIELD = 0;
   */
  OBJECT_FIELD = 0,

  /**
   * @generated from enum value: FIELD_ARGUMENT = 1;
   */
  FIELD_ARGUMENT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ArgumentSource)
proto3.util.setEnumType(ArgumentSource, "wg.cosmo.node.v1.ArgumentSource", [
  { no: 0, name: "OBJECT_FIELD" },
  { no: 1, name: "FIELD_ARGUMENT" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.DataSourceKind
 */
export enum DataSourceKind {
  /**
   * @generated from enum value: STATIC = 0;
   */
  STATIC = 0,

  /**
   * @generated from enum value: GRAPHQL = 1;
   */
  GRAPHQL = 1,

  /**
   * @generated from enum value: PUBSUB = 2;
   */
  PUBSUB = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(DataSourceKind)
proto3.util.setEnumType(DataSourceKind, "wg.cosmo.node.v1.DataSourceKind", [
  { no: 0, name: "STATIC" },
  { no: 1, name: "GRAPHQL" },
  { no: 2, name: "PUBSUB" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.EventType
 */
export enum EventType {
  /**
   * @generated from enum value: PUBLISH = 0;
   */
  PUBLISH = 0,

  /**
   * @generated from enum value: REQUEST = 1;
   */
  REQUEST = 1,

  /**
   * @generated from enum value: SUBSCRIBE = 2;
   */
  SUBSCRIBE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(EventType)
proto3.util.setEnumType(EventType, "wg.cosmo.node.v1.EventType", [
  { no: 0, name: "PUBLISH" },
  { no: 1, name: "REQUEST" },
  { no: 2, name: "SUBSCRIBE" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.ConfigurationVariableKind
 */
export enum ConfigurationVariableKind {
  /**
   * @generated from enum value: STATIC_CONFIGURATION_VARIABLE = 0;
   */
  STATIC_CONFIGURATION_VARIABLE = 0,

  /**
   * @generated from enum value: ENV_CONFIGURATION_VARIABLE = 1;
   */
  ENV_CONFIGURATION_VARIABLE = 1,

  /**
   * @generated from enum value: PLACEHOLDER_CONFIGURATION_VARIABLE = 2;
   */
  PLACEHOLDER_CONFIGURATION_VARIABLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConfigurationVariableKind)
proto3.util.setEnumType(ConfigurationVariableKind, "wg.cosmo.node.v1.ConfigurationVariableKind", [
  { no: 0, name: "STATIC_CONFIGURATION_VARIABLE" },
  { no: 1, name: "ENV_CONFIGURATION_VARIABLE" },
  { no: 2, name: "PLACEHOLDER_CONFIGURATION_VARIABLE" },
]);

/**
 * @generated from enum wg.cosmo.node.v1.HTTPMethod
 */
export enum HTTPMethod {
  /**
   * @generated from enum value: GET = 0;
   */
  GET = 0,

  /**
   * @generated from enum value: POST = 1;
   */
  POST = 1,

  /**
   * @generated from enum value: PUT = 2;
   */
  PUT = 2,

  /**
   * @generated from enum value: DELETE = 3;
   */
  DELETE = 3,

  /**
   * @generated from enum value: OPTIONS = 4;
   */
  OPTIONS = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(HTTPMethod)
proto3.util.setEnumType(HTTPMethod, "wg.cosmo.node.v1.HTTPMethod", [
  { no: 0, name: "GET" },
  { no: 1, name: "POST" },
  { no: 2, name: "PUT" },
  { no: 3, name: "DELETE" },
  { no: 4, name: "OPTIONS" },
]);

/**
 * @generated from message wg.cosmo.node.v1.Subgraph
 */
export class Subgraph extends Message<Subgraph> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: string routing_url = 3;
   */
  routingUrl = "";

  constructor(data?: PartialMessage<Subgraph>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.Subgraph";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "routing_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subgraph {
    return new Subgraph().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subgraph {
    return new Subgraph().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subgraph {
    return new Subgraph().fromJsonString(jsonString, options);
  }

  static equals(a: Subgraph | PlainMessage<Subgraph> | undefined, b: Subgraph | PlainMessage<Subgraph> | undefined): boolean {
    return proto3.util.equals(Subgraph, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.RouterConfig
 */
export class RouterConfig extends Message<RouterConfig> {
  /**
   * @generated from field: wg.cosmo.node.v1.EngineConfiguration engine_config = 1;
   */
  engineConfig?: EngineConfiguration;

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.Subgraph subgraphs = 3;
   */
  subgraphs: Subgraph[] = [];

  constructor(data?: PartialMessage<RouterConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.RouterConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "engine_config", kind: "message", T: EngineConfiguration },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subgraphs", kind: "message", T: Subgraph, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouterConfig {
    return new RouterConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouterConfig {
    return new RouterConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouterConfig {
    return new RouterConfig().fromJsonString(jsonString, options);
  }

  static equals(a: RouterConfig | PlainMessage<RouterConfig> | undefined, b: RouterConfig | PlainMessage<RouterConfig> | undefined): boolean {
    return proto3.util.equals(RouterConfig, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.Response
 */
export class Response extends Message<Response> {
  /**
   * @generated from field: wg.cosmo.common.EnumStatusCode code = 1;
   */
  code = EnumStatusCode.OK;

  /**
   * details is an optional field which can be used to provide more details about the error.
   *
   * @generated from field: optional string details = 2;
   */
  details?: string;

  constructor(data?: PartialMessage<Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(EnumStatusCode) },
    { no: 2, name: "details", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Response {
    return new Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJsonString(jsonString, options);
  }

  static equals(a: Response | PlainMessage<Response> | undefined, b: Response | PlainMessage<Response> | undefined): boolean {
    return proto3.util.equals(Response, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.ResponseStatus
 */
export class ResponseStatus extends Message<ResponseStatus> {
  /**
   * @generated from field: int32 code = 1;
   */
  code = 0;

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<ResponseStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ResponseStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResponseStatus {
    return new ResponseStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResponseStatus {
    return new ResponseStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResponseStatus {
    return new ResponseStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ResponseStatus | PlainMessage<ResponseStatus> | undefined, b: ResponseStatus | PlainMessage<ResponseStatus> | undefined): boolean {
    return proto3.util.equals(ResponseStatus, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GetConfigRequest
 */
export class GetConfigRequest extends Message<GetConfigRequest> {
  /**
   * With the introduction of namespaces, we no longer need the graph name. We keep it for backwards compatibility.
   * The FQDN of the graph to get the config for e.g. "wg.production"
   *
   * @generated from field: string graph_name = 1 [deprecated = true];
   * @deprecated
   */
  graphName = "";

  /**
   * The version to check for. If the version is not specified, the latest router config version will be returned.
   * Otherwise, the version will be used to check if a newer version of the router config is available.
   * That allow us to not send the router config if the version is the same.
   *
   * @generated from field: optional string version = 2;
   */
  version?: string;

  constructor(data?: PartialMessage<GetConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GetConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "graph_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigRequest {
    return new GetConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigRequest | PlainMessage<GetConfigRequest> | undefined, b: GetConfigRequest | PlainMessage<GetConfigRequest> | undefined): boolean {
    return proto3.util.equals(GetConfigRequest, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GetConfigResponse
 */
export class GetConfigResponse extends Message<GetConfigResponse> {
  /**
   * @generated from field: wg.cosmo.node.v1.Response response = 1;
   */
  response?: Response;

  /**
   * RouterConfig is the router config for the graph. It can be nil when a version is specified and the version is the same as the latest version.
   *
   * @generated from field: optional wg.cosmo.node.v1.RouterConfig config = 2;
   */
  config?: RouterConfig;

  constructor(data?: PartialMessage<GetConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GetConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "message", T: Response },
    { no: 2, name: "config", kind: "message", T: RouterConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigResponse {
    return new GetConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined, b: GetConfigResponse | PlainMessage<GetConfigResponse> | undefined): boolean {
    return proto3.util.equals(GetConfigResponse, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.RegistrationInfo
 */
export class RegistrationInfo extends Message<RegistrationInfo> {
  /**
   * @generated from field: wg.cosmo.node.v1.AccountLimits account_limits = 1;
   */
  accountLimits?: AccountLimits;

  /**
   * @generated from field: string graph_public_key = 2;
   */
  graphPublicKey = "";

  constructor(data?: PartialMessage<RegistrationInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.RegistrationInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_limits", kind: "message", T: AccountLimits },
    { no: 2, name: "graph_public_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegistrationInfo {
    return new RegistrationInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegistrationInfo {
    return new RegistrationInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegistrationInfo {
    return new RegistrationInfo().fromJsonString(jsonString, options);
  }

  static equals(a: RegistrationInfo | PlainMessage<RegistrationInfo> | undefined, b: RegistrationInfo | PlainMessage<RegistrationInfo> | undefined): boolean {
    return proto3.util.equals(RegistrationInfo, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.AccountLimits
 */
export class AccountLimits extends Message<AccountLimits> {
  /**
   * The maximum sampling rate for traces. Must be between 0 and 1.
   * 0 means no traces will be sampled and 1 means all traces will be sampled.
   *
   * @generated from field: float trace_sampling_rate = 1;
   */
  traceSamplingRate = 0;

  constructor(data?: PartialMessage<AccountLimits>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.AccountLimits";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trace_sampling_rate", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountLimits {
    return new AccountLimits().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountLimits {
    return new AccountLimits().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountLimits {
    return new AccountLimits().fromJsonString(jsonString, options);
  }

  static equals(a: AccountLimits | PlainMessage<AccountLimits> | undefined, b: AccountLimits | PlainMessage<AccountLimits> | undefined): boolean {
    return proto3.util.equals(AccountLimits, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SelfRegisterRequest
 */
export class SelfRegisterRequest extends Message<SelfRegisterRequest> {
  constructor(data?: PartialMessage<SelfRegisterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SelfRegisterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SelfRegisterRequest {
    return new SelfRegisterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SelfRegisterRequest {
    return new SelfRegisterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SelfRegisterRequest {
    return new SelfRegisterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SelfRegisterRequest | PlainMessage<SelfRegisterRequest> | undefined, b: SelfRegisterRequest | PlainMessage<SelfRegisterRequest> | undefined): boolean {
    return proto3.util.equals(SelfRegisterRequest, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SelfRegisterResponse
 */
export class SelfRegisterResponse extends Message<SelfRegisterResponse> {
  /**
   * @generated from field: wg.cosmo.node.v1.Response response = 1;
   */
  response?: Response;

  /**
   * @generated from field: optional wg.cosmo.node.v1.RegistrationInfo registrationInfo = 2;
   */
  registrationInfo?: RegistrationInfo;

  constructor(data?: PartialMessage<SelfRegisterResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SelfRegisterResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "message", T: Response },
    { no: 2, name: "registrationInfo", kind: "message", T: RegistrationInfo, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SelfRegisterResponse {
    return new SelfRegisterResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SelfRegisterResponse {
    return new SelfRegisterResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SelfRegisterResponse {
    return new SelfRegisterResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SelfRegisterResponse | PlainMessage<SelfRegisterResponse> | undefined, b: SelfRegisterResponse | PlainMessage<SelfRegisterResponse> | undefined): boolean {
    return proto3.util.equals(SelfRegisterResponse, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.EngineConfiguration
 */
export class EngineConfiguration extends Message<EngineConfiguration> {
  /**
   * @generated from field: int64 defaultFlushInterval = 1;
   */
  defaultFlushInterval = protoInt64.zero;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.DataSourceConfiguration datasource_configurations = 2;
   */
  datasourceConfigurations: DataSourceConfiguration[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.FieldConfiguration field_configurations = 3;
   */
  fieldConfigurations: FieldConfiguration[] = [];

  /**
   * @generated from field: string graphqlSchema = 4;
   */
  graphqlSchema = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.TypeConfiguration type_configurations = 5;
   */
  typeConfigurations: TypeConfiguration[] = [];

  /**
   * @generated from field: map<string, string> string_storage = 6;
   */
  stringStorage: { [key: string]: string } = {};

  /**
   * @generated from field: optional string graphql_client_schema = 7;
   */
  graphqlClientSchema?: string;

  constructor(data?: PartialMessage<EngineConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.EngineConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "defaultFlushInterval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "datasource_configurations", kind: "message", T: DataSourceConfiguration, repeated: true },
    { no: 3, name: "field_configurations", kind: "message", T: FieldConfiguration, repeated: true },
    { no: 4, name: "graphqlSchema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "type_configurations", kind: "message", T: TypeConfiguration, repeated: true },
    { no: 6, name: "string_storage", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 7, name: "graphql_client_schema", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EngineConfiguration {
    return new EngineConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EngineConfiguration {
    return new EngineConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EngineConfiguration {
    return new EngineConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: EngineConfiguration | PlainMessage<EngineConfiguration> | undefined, b: EngineConfiguration | PlainMessage<EngineConfiguration> | undefined): boolean {
    return proto3.util.equals(EngineConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceConfiguration
 */
export class DataSourceConfiguration extends Message<DataSourceConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceKind kind = 1;
   */
  kind = DataSourceKind.STATIC;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.TypeField root_nodes = 2;
   */
  rootNodes: TypeField[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.TypeField child_nodes = 3;
   */
  childNodes: TypeField[] = [];

  /**
   * @generated from field: bool override_field_path_from_alias = 4;
   */
  overrideFieldPathFromAlias = false;

  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceCustom_GraphQL custom_graphql = 5;
   */
  customGraphql?: DataSourceCustom_GraphQL;

  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceCustom_Static custom_static = 6;
   */
  customStatic?: DataSourceCustom_Static;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.DirectiveConfiguration directives = 7;
   */
  directives: DirectiveConfiguration[] = [];

  /**
   * @generated from field: int64 request_timeout_seconds = 8;
   */
  requestTimeoutSeconds = protoInt64.zero;

  /**
   * @generated from field: string id = 9;
   */
  id = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.RequiredField keys = 10;
   */
  keys: RequiredField[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.RequiredField provides = 11;
   */
  provides: RequiredField[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.RequiredField requires = 12;
   */
  requires: RequiredField[] = [];

  /**
   * @generated from field: wg.cosmo.node.v1.DataSourceCustomEvents custom_events = 13;
   */
  customEvents?: DataSourceCustomEvents;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.EntityInterfaceConfiguration entity_interfaces = 14;
   */
  entityInterfaces: EntityInterfaceConfiguration[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.EntityInterfaceConfiguration interface_objects = 15;
   */
  interfaceObjects: EntityInterfaceConfiguration[] = [];

  constructor(data?: PartialMessage<DataSourceConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(DataSourceKind) },
    { no: 2, name: "root_nodes", kind: "message", T: TypeField, repeated: true },
    { no: 3, name: "child_nodes", kind: "message", T: TypeField, repeated: true },
    { no: 4, name: "override_field_path_from_alias", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "custom_graphql", kind: "message", T: DataSourceCustom_GraphQL },
    { no: 6, name: "custom_static", kind: "message", T: DataSourceCustom_Static },
    { no: 7, name: "directives", kind: "message", T: DirectiveConfiguration, repeated: true },
    { no: 8, name: "request_timeout_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "keys", kind: "message", T: RequiredField, repeated: true },
    { no: 11, name: "provides", kind: "message", T: RequiredField, repeated: true },
    { no: 12, name: "requires", kind: "message", T: RequiredField, repeated: true },
    { no: 13, name: "custom_events", kind: "message", T: DataSourceCustomEvents },
    { no: 14, name: "entity_interfaces", kind: "message", T: EntityInterfaceConfiguration, repeated: true },
    { no: 15, name: "interface_objects", kind: "message", T: EntityInterfaceConfiguration, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceConfiguration {
    return new DataSourceConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceConfiguration {
    return new DataSourceConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceConfiguration {
    return new DataSourceConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceConfiguration | PlainMessage<DataSourceConfiguration> | undefined, b: DataSourceConfiguration | PlainMessage<DataSourceConfiguration> | undefined): boolean {
    return proto3.util.equals(DataSourceConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.ArgumentConfiguration
 */
export class ArgumentConfiguration extends Message<ArgumentConfiguration> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: wg.cosmo.node.v1.ArgumentSource source_type = 2;
   */
  sourceType = ArgumentSource.OBJECT_FIELD;

  constructor(data?: PartialMessage<ArgumentConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ArgumentConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source_type", kind: "enum", T: proto3.getEnumType(ArgumentSource) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArgumentConfiguration {
    return new ArgumentConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArgumentConfiguration {
    return new ArgumentConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArgumentConfiguration {
    return new ArgumentConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: ArgumentConfiguration | PlainMessage<ArgumentConfiguration> | undefined, b: ArgumentConfiguration | PlainMessage<ArgumentConfiguration> | undefined): boolean {
    return proto3.util.equals(ArgumentConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.Scopes
 */
export class Scopes extends Message<Scopes> {
  /**
   * @generated from field: repeated string required_and_scopes = 1;
   */
  requiredAndScopes: string[] = [];

  constructor(data?: PartialMessage<Scopes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.Scopes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "required_and_scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Scopes {
    return new Scopes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Scopes {
    return new Scopes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Scopes {
    return new Scopes().fromJsonString(jsonString, options);
  }

  static equals(a: Scopes | PlainMessage<Scopes> | undefined, b: Scopes | PlainMessage<Scopes> | undefined): boolean {
    return proto3.util.equals(Scopes, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.AuthorizationConfiguration
 */
export class AuthorizationConfiguration extends Message<AuthorizationConfiguration> {
  /**
   * @generated from field: bool requires_authentication = 1;
   */
  requiresAuthentication = false;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.Scopes required_or_scopes = 2;
   */
  requiredOrScopes: Scopes[] = [];

  constructor(data?: PartialMessage<AuthorizationConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.AuthorizationConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requires_authentication", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "required_or_scopes", kind: "message", T: Scopes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthorizationConfiguration {
    return new AuthorizationConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthorizationConfiguration {
    return new AuthorizationConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthorizationConfiguration {
    return new AuthorizationConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: AuthorizationConfiguration | PlainMessage<AuthorizationConfiguration> | undefined, b: AuthorizationConfiguration | PlainMessage<AuthorizationConfiguration> | undefined): boolean {
    return proto3.util.equals(AuthorizationConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.FieldConfiguration
 */
export class FieldConfiguration extends Message<FieldConfiguration> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 2;
   */
  fieldName = "";

  /**
   * @generated from field: repeated wg.cosmo.node.v1.ArgumentConfiguration arguments_configuration = 3;
   */
  argumentsConfiguration: ArgumentConfiguration[] = [];

  /**
   * @generated from field: wg.cosmo.node.v1.AuthorizationConfiguration authorization_configuration = 4;
   */
  authorizationConfiguration?: AuthorizationConfiguration;

  constructor(data?: PartialMessage<FieldConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.FieldConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "arguments_configuration", kind: "message", T: ArgumentConfiguration, repeated: true },
    { no: 4, name: "authorization_configuration", kind: "message", T: AuthorizationConfiguration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldConfiguration {
    return new FieldConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldConfiguration {
    return new FieldConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldConfiguration {
    return new FieldConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: FieldConfiguration | PlainMessage<FieldConfiguration> | undefined, b: FieldConfiguration | PlainMessage<FieldConfiguration> | undefined): boolean {
    return proto3.util.equals(FieldConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.TypeConfiguration
 */
export class TypeConfiguration extends Message<TypeConfiguration> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string rename_to = 2;
   */
  renameTo = "";

  constructor(data?: PartialMessage<TypeConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.TypeConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rename_to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypeConfiguration {
    return new TypeConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypeConfiguration {
    return new TypeConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypeConfiguration {
    return new TypeConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: TypeConfiguration | PlainMessage<TypeConfiguration> | undefined, b: TypeConfiguration | PlainMessage<TypeConfiguration> | undefined): boolean {
    return proto3.util.equals(TypeConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.TypeField
 */
export class TypeField extends Message<TypeField> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: repeated string field_names = 2;
   */
  fieldNames: string[] = [];

  constructor(data?: PartialMessage<TypeField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.TypeField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypeField {
    return new TypeField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypeField {
    return new TypeField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypeField {
    return new TypeField().fromJsonString(jsonString, options);
  }

  static equals(a: TypeField | PlainMessage<TypeField> | undefined, b: TypeField | PlainMessage<TypeField> | undefined): boolean {
    return proto3.util.equals(TypeField, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.RequiredField
 */
export class RequiredField extends Message<RequiredField> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 2;
   */
  fieldName = "";

  /**
   * @generated from field: string selection_set = 3;
   */
  selectionSet = "";

  /**
   * @generated from field: bool disable_entity_resolver = 4;
   */
  disableEntityResolver = false;

  constructor(data?: PartialMessage<RequiredField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.RequiredField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "selection_set", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "disable_entity_resolver", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequiredField {
    return new RequiredField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequiredField {
    return new RequiredField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequiredField {
    return new RequiredField().fromJsonString(jsonString, options);
  }

  static equals(a: RequiredField | PlainMessage<RequiredField> | undefined, b: RequiredField | PlainMessage<RequiredField> | undefined): boolean {
    return proto3.util.equals(RequiredField, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.EntityInterfaceConfiguration
 */
export class EntityInterfaceConfiguration extends Message<EntityInterfaceConfiguration> {
  /**
   * @generated from field: string interface_type_name = 1;
   */
  interfaceTypeName = "";

  /**
   * @generated from field: repeated string concrete_type_names = 2;
   */
  concreteTypeNames: string[] = [];

  constructor(data?: PartialMessage<EntityInterfaceConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.EntityInterfaceConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interface_type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "concrete_type_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntityInterfaceConfiguration {
    return new EntityInterfaceConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntityInterfaceConfiguration {
    return new EntityInterfaceConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntityInterfaceConfiguration {
    return new EntityInterfaceConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: EntityInterfaceConfiguration | PlainMessage<EntityInterfaceConfiguration> | undefined, b: EntityInterfaceConfiguration | PlainMessage<EntityInterfaceConfiguration> | undefined): boolean {
    return proto3.util.equals(EntityInterfaceConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.FetchConfiguration
 */
export class FetchConfiguration extends Message<FetchConfiguration> {
  /**
   * You should either configure url OR a combination of baseURL and path
   * If url resolves to a non empty string, it takes precedence over baseURL and path
   * If url resolves to an empty string, the url will be configured as "{{baseURL}}{{path}}"
   *
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable url = 1;
   */
  url?: ConfigurationVariable;

  /**
   * @generated from field: wg.cosmo.node.v1.HTTPMethod method = 2;
   */
  method = HTTPMethod.GET;

  /**
   * @generated from field: map<string, wg.cosmo.node.v1.HTTPHeader> header = 3;
   */
  header: { [key: string]: HTTPHeader } = {};

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable body = 4;
   */
  body?: ConfigurationVariable;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.URLQueryConfiguration query = 5;
   */
  query: URLQueryConfiguration[] = [];

  /**
   * urlEncodeBody defines whether the body should be URL encoded or not
   * by default, the body will be JSON encoded
   * setting urlEncodeBody to true will render the body empty,
   * the Header Content-Type will be set to application/x-www-form-urlencoded,
   * and the body will be URL encoded and set as the URL Query String
   *
   * @generated from field: bool url_encode_body = 7;
   */
  urlEncodeBody = false;

  /**
   * @generated from field: wg.cosmo.node.v1.MTLSConfiguration mtls = 8;
   */
  mtls?: MTLSConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable base_url = 9;
   */
  baseUrl?: ConfigurationVariable;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable path = 10;
   */
  path?: ConfigurationVariable;

  /**
   * @generated from field: optional wg.cosmo.node.v1.ConfigurationVariable http_proxy_url = 11;
   */
  httpProxyUrl?: ConfigurationVariable;

  constructor(data?: PartialMessage<FetchConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.FetchConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "message", T: ConfigurationVariable },
    { no: 2, name: "method", kind: "enum", T: proto3.getEnumType(HTTPMethod) },
    { no: 3, name: "header", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: HTTPHeader} },
    { no: 4, name: "body", kind: "message", T: ConfigurationVariable },
    { no: 5, name: "query", kind: "message", T: URLQueryConfiguration, repeated: true },
    { no: 7, name: "url_encode_body", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "mtls", kind: "message", T: MTLSConfiguration },
    { no: 9, name: "base_url", kind: "message", T: ConfigurationVariable },
    { no: 10, name: "path", kind: "message", T: ConfigurationVariable },
    { no: 11, name: "http_proxy_url", kind: "message", T: ConfigurationVariable, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchConfiguration {
    return new FetchConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchConfiguration {
    return new FetchConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchConfiguration {
    return new FetchConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: FetchConfiguration | PlainMessage<FetchConfiguration> | undefined, b: FetchConfiguration | PlainMessage<FetchConfiguration> | undefined): boolean {
    return proto3.util.equals(FetchConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.StatusCodeTypeMapping
 */
export class StatusCodeTypeMapping extends Message<StatusCodeTypeMapping> {
  /**
   * @generated from field: int64 status_code = 1;
   */
  statusCode = protoInt64.zero;

  /**
   * @generated from field: string type_name = 2;
   */
  typeName = "";

  /**
   * @generated from field: bool inject_status_code_into_body = 3;
   */
  injectStatusCodeIntoBody = false;

  constructor(data?: PartialMessage<StatusCodeTypeMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.StatusCodeTypeMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status_code", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "inject_status_code_into_body", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StatusCodeTypeMapping {
    return new StatusCodeTypeMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StatusCodeTypeMapping {
    return new StatusCodeTypeMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StatusCodeTypeMapping {
    return new StatusCodeTypeMapping().fromJsonString(jsonString, options);
  }

  static equals(a: StatusCodeTypeMapping | PlainMessage<StatusCodeTypeMapping> | undefined, b: StatusCodeTypeMapping | PlainMessage<StatusCodeTypeMapping> | undefined): boolean {
    return proto3.util.equals(StatusCodeTypeMapping, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceCustom_GraphQL
 */
export class DataSourceCustom_GraphQL extends Message<DataSourceCustom_GraphQL> {
  /**
   * @generated from field: wg.cosmo.node.v1.FetchConfiguration fetch = 1;
   */
  fetch?: FetchConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.GraphQLSubscriptionConfiguration subscription = 2;
   */
  subscription?: GraphQLSubscriptionConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.GraphQLFederationConfiguration federation = 3;
   */
  federation?: GraphQLFederationConfiguration;

  /**
   * @generated from field: wg.cosmo.node.v1.InternedString upstream_schema = 4;
   */
  upstreamSchema?: InternedString;

  /**
   * @generated from field: repeated wg.cosmo.node.v1.SingleTypeField custom_scalar_type_fields = 6;
   */
  customScalarTypeFields: SingleTypeField[] = [];

  constructor(data?: PartialMessage<DataSourceCustom_GraphQL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceCustom_GraphQL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fetch", kind: "message", T: FetchConfiguration },
    { no: 2, name: "subscription", kind: "message", T: GraphQLSubscriptionConfiguration },
    { no: 3, name: "federation", kind: "message", T: GraphQLFederationConfiguration },
    { no: 4, name: "upstream_schema", kind: "message", T: InternedString },
    { no: 6, name: "custom_scalar_type_fields", kind: "message", T: SingleTypeField, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceCustom_GraphQL {
    return new DataSourceCustom_GraphQL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceCustom_GraphQL {
    return new DataSourceCustom_GraphQL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceCustom_GraphQL {
    return new DataSourceCustom_GraphQL().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceCustom_GraphQL | PlainMessage<DataSourceCustom_GraphQL> | undefined, b: DataSourceCustom_GraphQL | PlainMessage<DataSourceCustom_GraphQL> | undefined): boolean {
    return proto3.util.equals(DataSourceCustom_GraphQL, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.NatsStreamConfiguration
 */
export class NatsStreamConfiguration extends Message<NatsStreamConfiguration> {
  /**
   * @generated from field: string consumer_name = 1;
   */
  consumerName = "";

  /**
   * @generated from field: string stream_name = 2;
   */
  streamName = "";

  constructor(data?: PartialMessage<NatsStreamConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.NatsStreamConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consumer_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "stream_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NatsStreamConfiguration {
    return new NatsStreamConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NatsStreamConfiguration {
    return new NatsStreamConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NatsStreamConfiguration {
    return new NatsStreamConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: NatsStreamConfiguration | PlainMessage<NatsStreamConfiguration> | undefined, b: NatsStreamConfiguration | PlainMessage<NatsStreamConfiguration> | undefined): boolean {
    return proto3.util.equals(NatsStreamConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.NatsEventConfiguration
 */
export class NatsEventConfiguration extends Message<NatsEventConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.EngineEventConfiguration engine_event_configuration = 1;
   */
  engineEventConfiguration?: EngineEventConfiguration;

  /**
   * @generated from field: repeated string subjects = 2;
   */
  subjects: string[] = [];

  /**
   * @generated from field: wg.cosmo.node.v1.NatsStreamConfiguration stream_configuration = 3;
   */
  streamConfiguration?: NatsStreamConfiguration;

  constructor(data?: PartialMessage<NatsEventConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.NatsEventConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "engine_event_configuration", kind: "message", T: EngineEventConfiguration },
    { no: 2, name: "subjects", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "stream_configuration", kind: "message", T: NatsStreamConfiguration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NatsEventConfiguration {
    return new NatsEventConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NatsEventConfiguration {
    return new NatsEventConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NatsEventConfiguration {
    return new NatsEventConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: NatsEventConfiguration | PlainMessage<NatsEventConfiguration> | undefined, b: NatsEventConfiguration | PlainMessage<NatsEventConfiguration> | undefined): boolean {
    return proto3.util.equals(NatsEventConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.KafkaEventConfiguration
 */
export class KafkaEventConfiguration extends Message<KafkaEventConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.EngineEventConfiguration engine_event_configuration = 1;
   */
  engineEventConfiguration?: EngineEventConfiguration;

  /**
   * @generated from field: repeated string topics = 2;
   */
  topics: string[] = [];

  constructor(data?: PartialMessage<KafkaEventConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.KafkaEventConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "engine_event_configuration", kind: "message", T: EngineEventConfiguration },
    { no: 2, name: "topics", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KafkaEventConfiguration {
    return new KafkaEventConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KafkaEventConfiguration {
    return new KafkaEventConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KafkaEventConfiguration {
    return new KafkaEventConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: KafkaEventConfiguration | PlainMessage<KafkaEventConfiguration> | undefined, b: KafkaEventConfiguration | PlainMessage<KafkaEventConfiguration> | undefined): boolean {
    return proto3.util.equals(KafkaEventConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.EngineEventConfiguration
 */
export class EngineEventConfiguration extends Message<EngineEventConfiguration> {
  /**
   * @generated from field: string provider_id = 1;
   */
  providerId = "";

  /**
   * @generated from field: wg.cosmo.node.v1.EventType type = 2;
   */
  type = EventType.PUBLISH;

  /**
   * @generated from field: string type_name = 3;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 4;
   */
  fieldName = "";

  constructor(data?: PartialMessage<EngineEventConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.EngineEventConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(EventType) },
    { no: 3, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EngineEventConfiguration {
    return new EngineEventConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EngineEventConfiguration {
    return new EngineEventConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EngineEventConfiguration {
    return new EngineEventConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: EngineEventConfiguration | PlainMessage<EngineEventConfiguration> | undefined, b: EngineEventConfiguration | PlainMessage<EngineEventConfiguration> | undefined): boolean {
    return proto3.util.equals(EngineEventConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceCustomEvents
 */
export class DataSourceCustomEvents extends Message<DataSourceCustomEvents> {
  /**
   * @generated from field: repeated wg.cosmo.node.v1.NatsEventConfiguration nats = 1;
   */
  nats: NatsEventConfiguration[] = [];

  /**
   * @generated from field: repeated wg.cosmo.node.v1.KafkaEventConfiguration kafka = 2;
   */
  kafka: KafkaEventConfiguration[] = [];

  constructor(data?: PartialMessage<DataSourceCustomEvents>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceCustomEvents";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nats", kind: "message", T: NatsEventConfiguration, repeated: true },
    { no: 2, name: "kafka", kind: "message", T: KafkaEventConfiguration, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceCustomEvents {
    return new DataSourceCustomEvents().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceCustomEvents {
    return new DataSourceCustomEvents().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceCustomEvents {
    return new DataSourceCustomEvents().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceCustomEvents | PlainMessage<DataSourceCustomEvents> | undefined, b: DataSourceCustomEvents | PlainMessage<DataSourceCustomEvents> | undefined): boolean {
    return proto3.util.equals(DataSourceCustomEvents, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DataSourceCustom_Static
 */
export class DataSourceCustom_Static extends Message<DataSourceCustom_Static> {
  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable data = 1;
   */
  data?: ConfigurationVariable;

  constructor(data?: PartialMessage<DataSourceCustom_Static>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DataSourceCustom_Static";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: ConfigurationVariable },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataSourceCustom_Static {
    return new DataSourceCustom_Static().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataSourceCustom_Static {
    return new DataSourceCustom_Static().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataSourceCustom_Static {
    return new DataSourceCustom_Static().fromJsonString(jsonString, options);
  }

  static equals(a: DataSourceCustom_Static | PlainMessage<DataSourceCustom_Static> | undefined, b: DataSourceCustom_Static | PlainMessage<DataSourceCustom_Static> | undefined): boolean {
    return proto3.util.equals(DataSourceCustom_Static, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.ConfigurationVariable
 */
export class ConfigurationVariable extends Message<ConfigurationVariable> {
  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariableKind kind = 1;
   */
  kind = ConfigurationVariableKind.STATIC_CONFIGURATION_VARIABLE;

  /**
   * @generated from field: string static_variable_content = 2;
   */
  staticVariableContent = "";

  /**
   * @generated from field: string environment_variable_name = 3;
   */
  environmentVariableName = "";

  /**
   * @generated from field: string environment_variable_default_value = 4;
   */
  environmentVariableDefaultValue = "";

  /**
   * @generated from field: string placeholder_variable_name = 5;
   */
  placeholderVariableName = "";

  constructor(data?: PartialMessage<ConfigurationVariable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.ConfigurationVariable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(ConfigurationVariableKind) },
    { no: 2, name: "static_variable_content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "environment_variable_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "environment_variable_default_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "placeholder_variable_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigurationVariable {
    return new ConfigurationVariable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigurationVariable {
    return new ConfigurationVariable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigurationVariable {
    return new ConfigurationVariable().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigurationVariable | PlainMessage<ConfigurationVariable> | undefined, b: ConfigurationVariable | PlainMessage<ConfigurationVariable> | undefined): boolean {
    return proto3.util.equals(ConfigurationVariable, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.DirectiveConfiguration
 */
export class DirectiveConfiguration extends Message<DirectiveConfiguration> {
  /**
   * @generated from field: string directive_name = 1;
   */
  directiveName = "";

  /**
   * @generated from field: string rename_to = 2;
   */
  renameTo = "";

  constructor(data?: PartialMessage<DirectiveConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.DirectiveConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "directive_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rename_to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DirectiveConfiguration {
    return new DirectiveConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DirectiveConfiguration {
    return new DirectiveConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DirectiveConfiguration {
    return new DirectiveConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: DirectiveConfiguration | PlainMessage<DirectiveConfiguration> | undefined, b: DirectiveConfiguration | PlainMessage<DirectiveConfiguration> | undefined): boolean {
    return proto3.util.equals(DirectiveConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.URLQueryConfiguration
 */
export class URLQueryConfiguration extends Message<URLQueryConfiguration> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<URLQueryConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.URLQueryConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): URLQueryConfiguration {
    return new URLQueryConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): URLQueryConfiguration {
    return new URLQueryConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): URLQueryConfiguration {
    return new URLQueryConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: URLQueryConfiguration | PlainMessage<URLQueryConfiguration> | undefined, b: URLQueryConfiguration | PlainMessage<URLQueryConfiguration> | undefined): boolean {
    return proto3.util.equals(URLQueryConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.HTTPHeader
 */
export class HTTPHeader extends Message<HTTPHeader> {
  /**
   * @generated from field: repeated wg.cosmo.node.v1.ConfigurationVariable values = 1;
   */
  values: ConfigurationVariable[] = [];

  constructor(data?: PartialMessage<HTTPHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.HTTPHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "message", T: ConfigurationVariable, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPHeader {
    return new HTTPHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPHeader {
    return new HTTPHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPHeader {
    return new HTTPHeader().fromJsonString(jsonString, options);
  }

  static equals(a: HTTPHeader | PlainMessage<HTTPHeader> | undefined, b: HTTPHeader | PlainMessage<HTTPHeader> | undefined): boolean {
    return proto3.util.equals(HTTPHeader, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.MTLSConfiguration
 */
export class MTLSConfiguration extends Message<MTLSConfiguration> {
  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable key = 1;
   */
  key?: ConfigurationVariable;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable cert = 2;
   */
  cert?: ConfigurationVariable;

  /**
   * @generated from field: bool insecureSkipVerify = 3;
   */
  insecureSkipVerify = false;

  constructor(data?: PartialMessage<MTLSConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.MTLSConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: ConfigurationVariable },
    { no: 2, name: "cert", kind: "message", T: ConfigurationVariable },
    { no: 3, name: "insecureSkipVerify", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MTLSConfiguration {
    return new MTLSConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MTLSConfiguration {
    return new MTLSConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MTLSConfiguration {
    return new MTLSConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: MTLSConfiguration | PlainMessage<MTLSConfiguration> | undefined, b: MTLSConfiguration | PlainMessage<MTLSConfiguration> | undefined): boolean {
    return proto3.util.equals(MTLSConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GraphQLSubscriptionConfiguration
 */
export class GraphQLSubscriptionConfiguration extends Message<GraphQLSubscriptionConfiguration> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * @generated from field: wg.cosmo.node.v1.ConfigurationVariable url = 2;
   */
  url?: ConfigurationVariable;

  /**
   * @deprecated - Kept for backwards compatibility when decoding. Use protocol instead. 
   *
   * @generated from field: optional bool useSSE = 3;
   */
  useSSE?: boolean;

  /**
   * @generated from field: optional wg.cosmo.common.GraphQLSubscriptionProtocol protocol = 4;
   */
  protocol?: GraphQLSubscriptionProtocol;

  /**
   * @generated from field: optional wg.cosmo.common.GraphQLWebsocketSubprotocol websocketSubprotocol = 5;
   */
  websocketSubprotocol?: GraphQLWebsocketSubprotocol;

  constructor(data?: PartialMessage<GraphQLSubscriptionConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GraphQLSubscriptionConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "url", kind: "message", T: ConfigurationVariable },
    { no: 3, name: "useSSE", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "protocol", kind: "enum", T: proto3.getEnumType(GraphQLSubscriptionProtocol), opt: true },
    { no: 5, name: "websocketSubprotocol", kind: "enum", T: proto3.getEnumType(GraphQLWebsocketSubprotocol), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GraphQLSubscriptionConfiguration {
    return new GraphQLSubscriptionConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GraphQLSubscriptionConfiguration {
    return new GraphQLSubscriptionConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GraphQLSubscriptionConfiguration {
    return new GraphQLSubscriptionConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: GraphQLSubscriptionConfiguration | PlainMessage<GraphQLSubscriptionConfiguration> | undefined, b: GraphQLSubscriptionConfiguration | PlainMessage<GraphQLSubscriptionConfiguration> | undefined): boolean {
    return proto3.util.equals(GraphQLSubscriptionConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.GraphQLFederationConfiguration
 */
export class GraphQLFederationConfiguration extends Message<GraphQLFederationConfiguration> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * @generated from field: string serviceSdl = 2;
   */
  serviceSdl = "";

  constructor(data?: PartialMessage<GraphQLFederationConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.GraphQLFederationConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "serviceSdl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GraphQLFederationConfiguration {
    return new GraphQLFederationConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GraphQLFederationConfiguration {
    return new GraphQLFederationConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GraphQLFederationConfiguration {
    return new GraphQLFederationConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: GraphQLFederationConfiguration | PlainMessage<GraphQLFederationConfiguration> | undefined, b: GraphQLFederationConfiguration | PlainMessage<GraphQLFederationConfiguration> | undefined): boolean {
    return proto3.util.equals(GraphQLFederationConfiguration, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.InternedString
 */
export class InternedString extends Message<InternedString> {
  /**
   * key to index into EngineConfiguration.stringStorage
   *
   * @generated from field: string key = 1;
   */
  key = "";

  constructor(data?: PartialMessage<InternedString>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.InternedString";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InternedString {
    return new InternedString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InternedString {
    return new InternedString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InternedString {
    return new InternedString().fromJsonString(jsonString, options);
  }

  static equals(a: InternedString | PlainMessage<InternedString> | undefined, b: InternedString | PlainMessage<InternedString> | undefined): boolean {
    return proto3.util.equals(InternedString, a, b);
  }
}

/**
 * @generated from message wg.cosmo.node.v1.SingleTypeField
 */
export class SingleTypeField extends Message<SingleTypeField> {
  /**
   * @generated from field: string type_name = 1;
   */
  typeName = "";

  /**
   * @generated from field: string field_name = 2;
   */
  fieldName = "";

  constructor(data?: PartialMessage<SingleTypeField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wg.cosmo.node.v1.SingleTypeField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SingleTypeField {
    return new SingleTypeField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SingleTypeField {
    return new SingleTypeField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SingleTypeField {
    return new SingleTypeField().fromJsonString(jsonString, options);
  }

  static equals(a: SingleTypeField | PlainMessage<SingleTypeField> | undefined, b: SingleTypeField | PlainMessage<SingleTypeField> | undefined): boolean {
    return proto3.util.equals(SingleTypeField, a, b);
  }
}

