"use strict";
var shim = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a2, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a2, prop, b[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // ../../node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.18.17/node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js
  var init_dirname = __esm({
    "../../node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.18.17/node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js"() {
      "use strict";
    }
  });

  // ../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/process.js
  var process_exports = {};
  __export(process_exports, {
    _debugEnd: () => _debugEnd,
    _debugProcess: () => _debugProcess,
    _events: () => _events,
    _eventsCount: () => _eventsCount,
    _exiting: () => _exiting,
    _fatalExceptions: () => _fatalExceptions,
    _getActiveHandles: () => _getActiveHandles,
    _getActiveRequests: () => _getActiveRequests,
    _kill: () => _kill,
    _linkedBinding: () => _linkedBinding,
    _maxListeners: () => _maxListeners,
    _preload_modules: () => _preload_modules,
    _rawDebug: () => _rawDebug,
    _startProfilerIdleNotifier: () => _startProfilerIdleNotifier,
    _stopProfilerIdleNotifier: () => _stopProfilerIdleNotifier,
    _tickCallback: () => _tickCallback,
    abort: () => abort,
    addListener: () => addListener,
    allowedNodeEnvironmentFlags: () => allowedNodeEnvironmentFlags,
    arch: () => arch,
    argv: () => argv,
    argv0: () => argv0,
    assert: () => assert,
    binding: () => binding,
    chdir: () => chdir,
    config: () => config,
    cpuUsage: () => cpuUsage,
    cwd: () => cwd,
    debugPort: () => debugPort,
    default: () => process,
    dlopen: () => dlopen,
    domain: () => domain,
    emit: () => emit,
    emitWarning: () => emitWarning,
    env: () => env,
    execArgv: () => execArgv,
    execPath: () => execPath,
    exit: () => exit,
    features: () => features,
    hasUncaughtExceptionCaptureCallback: () => hasUncaughtExceptionCaptureCallback,
    hrtime: () => hrtime,
    kill: () => kill,
    listeners: () => listeners,
    memoryUsage: () => memoryUsage,
    moduleLoadList: () => moduleLoadList,
    nextTick: () => nextTick,
    off: () => off,
    on: () => on,
    once: () => once,
    openStdin: () => openStdin,
    pid: () => pid,
    platform: () => platform,
    ppid: () => ppid,
    prependListener: () => prependListener,
    prependOnceListener: () => prependOnceListener,
    reallyExit: () => reallyExit,
    release: () => release,
    removeAllListeners: () => removeAllListeners,
    removeListener: () => removeListener,
    resourceUsage: () => resourceUsage,
    setSourceMapsEnabled: () => setSourceMapsEnabled,
    setUncaughtExceptionCaptureCallback: () => setUncaughtExceptionCaptureCallback,
    stderr: () => stderr,
    stdin: () => stdin,
    stdout: () => stdout,
    title: () => title,
    umask: () => umask,
    uptime: () => uptime,
    version: () => version,
    versions: () => versions
  });
  function unimplemented(name2) {
    throw new Error("Node.js process " + name2 + " is not supported by JSPM core outside of Node.js");
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue)
      return;
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length)
      drainQueue();
  }
  function drainQueue() {
    if (draining)
      return;
    var timeout = setTimeout(cleanUpNextTick, 0);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue)
          currentQueue[queueIndex].run();
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i2 = 1; i2 < arguments.length; i2++)
        args[i2 - 1] = arguments[i2];
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining)
      setTimeout(drainQueue, 0);
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  function _linkedBinding(name2) {
    unimplemented("_linkedBinding");
  }
  function dlopen(name2) {
    unimplemented("dlopen");
  }
  function _getActiveRequests() {
    return [];
  }
  function _getActiveHandles() {
    return [];
  }
  function assert(condition, message) {
    if (!condition)
      throw new Error(message || "assertion error");
  }
  function hasUncaughtExceptionCaptureCallback() {
    return false;
  }
  function uptime() {
    return _performance.now() / 1e3;
  }
  function hrtime(previousTimestamp) {
    var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
    var clocktime = _performance.now() * 1e-3;
    var seconds = Math.floor(clocktime) + baseNow;
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += nanoPerSec;
      }
    }
    return [seconds, nanoseconds];
  }
  function on() {
    return process;
  }
  function listeners(name2) {
    return [];
  }
  var queue, draining, currentQueue, queueIndex, title, arch, platform, env, argv, execArgv, version, versions, emitWarning, binding, umask, cwd, chdir, release, _rawDebug, moduleLoadList, domain, _exiting, config, reallyExit, _kill, cpuUsage, resourceUsage, memoryUsage, kill, exit, openStdin, allowedNodeEnvironmentFlags, features, _fatalExceptions, setUncaughtExceptionCaptureCallback, _tickCallback, _debugProcess, _debugEnd, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, stdout, stderr, stdin, abort, pid, ppid, execPath, debugPort, argv0, _preload_modules, setSourceMapsEnabled, _performance, nowOffset, nanoPerSec, _maxListeners, _events, _eventsCount, addListener, once, off, removeListener, removeAllListeners, emit, prependListener, prependOnceListener, process;
  var init_process = __esm({
    "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/process.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      queue = [];
      draining = false;
      queueIndex = -1;
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      arch = "x64";
      platform = "browser";
      env = {
        PATH: "/usr/bin",
        LANG: navigator.language + ".UTF-8",
        PWD: "/",
        HOME: "/home",
        TMP: "/tmp"
      };
      argv = ["/usr/bin/node"];
      execArgv = [];
      version = "v16.8.0";
      versions = {};
      emitWarning = function(message, type) {
        console.warn((type ? type + ": " : "") + message);
      };
      binding = function(name2) {
        unimplemented("binding");
      };
      umask = function(mask) {
        return 0;
      };
      cwd = function() {
        return "/";
      };
      chdir = function(dir) {
      };
      release = {
        name: "node",
        sourceUrl: "",
        headersUrl: "",
        libUrl: ""
      };
      _rawDebug = noop;
      moduleLoadList = [];
      domain = {};
      _exiting = false;
      config = {};
      reallyExit = noop;
      _kill = noop;
      cpuUsage = function() {
        return {};
      };
      resourceUsage = cpuUsage;
      memoryUsage = cpuUsage;
      kill = noop;
      exit = noop;
      openStdin = noop;
      allowedNodeEnvironmentFlags = {};
      features = {
        inspector: false,
        debug: false,
        uv: false,
        ipv6: false,
        tls_alpn: false,
        tls_sni: false,
        tls_ocsp: false,
        tls: false,
        cached_builtins: true
      };
      _fatalExceptions = noop;
      setUncaughtExceptionCaptureCallback = noop;
      _tickCallback = noop;
      _debugProcess = noop;
      _debugEnd = noop;
      _startProfilerIdleNotifier = noop;
      _stopProfilerIdleNotifier = noop;
      stdout = void 0;
      stderr = void 0;
      stdin = void 0;
      abort = noop;
      pid = 2;
      ppid = 1;
      execPath = "/bin/usr/node";
      debugPort = 9229;
      argv0 = "node";
      _preload_modules = [];
      setSourceMapsEnabled = noop;
      _performance = {
        now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
        timing: typeof performance !== "undefined" ? performance.timing : void 0
      };
      if (_performance.now === void 0) {
        nowOffset = Date.now();
        if (_performance.timing && _performance.timing.navigationStart) {
          nowOffset = _performance.timing.navigationStart;
        }
        _performance.now = () => Date.now() - nowOffset;
      }
      nanoPerSec = 1e9;
      hrtime.bigint = function(time) {
        var diff2 = hrtime(time);
        if (typeof BigInt === "undefined") {
          return diff2[0] * nanoPerSec + diff2[1];
        }
        return BigInt(diff2[0] * nanoPerSec) + BigInt(diff2[1]);
      };
      _maxListeners = 10;
      _events = {};
      _eventsCount = 0;
      addListener = on;
      once = on;
      off = on;
      removeListener = on;
      removeAllListeners = on;
      emit = noop;
      prependListener = on;
      prependOnceListener = on;
      process = {
        version,
        versions,
        arch,
        platform,
        release,
        _rawDebug,
        moduleLoadList,
        binding,
        _linkedBinding,
        _events,
        _eventsCount,
        _maxListeners,
        on,
        addListener,
        once,
        off,
        removeListener,
        removeAllListeners,
        emit,
        prependListener,
        prependOnceListener,
        listeners,
        domain,
        _exiting,
        config,
        dlopen,
        uptime,
        _getActiveRequests,
        _getActiveHandles,
        reallyExit,
        _kill,
        cpuUsage,
        resourceUsage,
        memoryUsage,
        kill,
        exit,
        openStdin,
        allowedNodeEnvironmentFlags,
        assert,
        features,
        _fatalExceptions,
        setUncaughtExceptionCaptureCallback,
        hasUncaughtExceptionCaptureCallback,
        emitWarning,
        nextTick,
        _tickCallback,
        _debugProcess,
        _debugEnd,
        _startProfilerIdleNotifier,
        _stopProfilerIdleNotifier,
        stdout,
        stdin,
        stderr,
        abort,
        umask,
        chdir,
        cwd,
        env,
        title,
        argv,
        execArgv,
        pid,
        ppid,
        execPath,
        debugPort,
        hrtime,
        argv0,
        _preload_modules,
        setSourceMapsEnabled
      };
    }
  });

  // ../../node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.18.17/node_modules/esbuild-plugin-polyfill-node/polyfills/process.js
  var init_process2 = __esm({
    "../../node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.18.17/node_modules/esbuild-plugin-polyfill-node/polyfills/process.js"() {
      "use strict";
      init_process();
    }
  });

  // ../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/buffer.js
  function dew$2() {
    if (_dewExec$2)
      return exports$3;
    _dewExec$2 = true;
    exports$3.byteLength = byteLength;
    exports$3.toByteArray = toByteArray;
    exports$3.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    return exports$3;
  }
  function dew$1() {
    if (_dewExec$1)
      return exports$2;
    _dewExec$1 = true;
    exports$2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s2 = buffer[offset + i2];
      i2 += d;
      e2 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
      }
      m = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s2 ? -1 : 1) * m * Math.pow(2, e2 - mLen);
    };
    exports$2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i2 - d] |= s2 * 128;
    };
    return exports$2;
  }
  function dew() {
    if (_dewExec)
      return exports$1;
    _dewExec = true;
    const base64 = dew$2();
    const ieee754 = dew$1();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports$1.Buffer = Buffer3;
    exports$1.SlowBuffer = SlowBuffer;
    exports$1.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports$1.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i2 = 0; i2 < length; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a2, b) {
      if (isInstance(a2, Uint8Array))
        a2 = Buffer3.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a2) || !Buffer3.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a2 === b)
        return 0;
      let x = a2.length;
      let y2 = b.length;
      for (let i2 = 0, len = Math.min(x, y2); i2 < len; ++i2) {
        if (a2[i2] !== b[i2]) {
          x = a2[i2];
          y2 = b[i2];
          break;
        }
      }
      if (x < y2)
        return -1;
      if (y2 < x)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length += list[i2].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n2, m) {
      const i2 = b[n2];
      b[n2] = b[m];
      b[m] = i2;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect2() {
      let str = "";
      const max = exports$1.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y2 = end - start;
      const len = Math.min(x, y2);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x < y2)
        return -1;
      if (y2 < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i2 + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i2;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        const parsed = parseInt(string.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24);
      const hi = this[++offset] + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + last * __pow(2, 24);
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
      const lo = this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i2 = byteLength2;
      let mul = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * __pow(2, 8) + this[offset + 6] * __pow(2, 16) + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24));
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    const errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E("ERR_INVALID_ARG_TYPE", function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > __pow(2, 32)) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > __pow(BigInt(2), BigInt(32)) || input < -__pow(BigInt(2), BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n2 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
          } else {
            range = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
          }
        } else {
          range = `>= ${min}${n2} and <= ${max}${n2}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i2 = 0; i2 < length; ++i2) {
        codePoint = string.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c2, hi, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0)
          break;
        c2 = str.charCodeAt(i2);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src.length)
          break;
        dst[i2 + offset] = src[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i2] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    return exports$1;
  }
  var exports$3, _dewExec$2, exports$2, _dewExec$1, exports$1, _dewExec, exports, Buffer2, INSPECT_MAX_BYTES, kMaxLength;
  var init_buffer = __esm({
    "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/buffer.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      exports$3 = {};
      _dewExec$2 = false;
      exports$2 = {};
      _dewExec$1 = false;
      exports$1 = {};
      _dewExec = false;
      exports = dew();
      exports["Buffer"];
      exports["SlowBuffer"];
      exports["INSPECT_MAX_BYTES"];
      exports["kMaxLength"];
      Buffer2 = exports.Buffer;
      INSPECT_MAX_BYTES = exports.INSPECT_MAX_BYTES;
      kMaxLength = exports.kMaxLength;
    }
  });

  // ../../node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.18.17/node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
  var init_buffer2 = __esm({
    "../../node_modules/.pnpm/esbuild-plugin-polyfill-node@0.3.0_esbuild@0.18.17/node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
      "use strict";
      init_buffer();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/version.mjs
  var version2, versionInfo;
  var init_version = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/version.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      version2 = "16.7.1";
      versionInfo = Object.freeze({
        major: 16,
        minor: 7,
        patch: 1,
        preReleaseTag: null
      });
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/devAssert.mjs
  function devAssert(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message);
    }
  }
  var init_devAssert = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/devAssert.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isPromise.mjs
  function isPromise(value) {
    return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
  }
  var init_isPromise = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isPromise.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isObjectLike.mjs
  function isObjectLike(value) {
    return typeof value == "object" && value !== null;
  }
  var init_isObjectLike = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isObjectLike.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/invariant.mjs
  function invariant(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(
        message != null ? message : "Unexpected invariant triggered."
      );
    }
  }
  var init_invariant = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/invariant.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/location.mjs
  function getLocation(source, position) {
    let lastLineStart = 0;
    let line = 1;
    for (const match of source.body.matchAll(LineRegExp)) {
      typeof match.index === "number" || invariant(false);
      if (match.index >= position) {
        break;
      }
      lastLineStart = match.index + match[0].length;
      line += 1;
    }
    return {
      line,
      column: position + 1 - lastLineStart
    };
  }
  var LineRegExp;
  var init_location = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/location.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_invariant();
      LineRegExp = /\r\n|[\n\r]/g;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printLocation.mjs
  function printLocation(location) {
    return printSourceLocation(
      location.source,
      getLocation(location.source, location.start)
    );
  }
  function printSourceLocation(source, sourceLocation) {
    const firstLineColumnOffset = source.locationOffset.column - 1;
    const body = "".padStart(firstLineColumnOffset) + source.body;
    const lineIndex = sourceLocation.line - 1;
    const lineOffset = source.locationOffset.line - 1;
    const lineNum = sourceLocation.line + lineOffset;
    const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
    const columnNum = sourceLocation.column + columnOffset;
    const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
    const lines = body.split(/\r\n|[\n\r]/g);
    const locationLine = lines[lineIndex];
    if (locationLine.length > 120) {
      const subLineIndex = Math.floor(columnNum / 80);
      const subLineColumnNum = columnNum % 80;
      const subLines = [];
      for (let i2 = 0; i2 < locationLine.length; i2 += 80) {
        subLines.push(locationLine.slice(i2, i2 + 80));
      }
      return locationStr + printPrefixedLines([
        [`${lineNum} |`, subLines[0]],
        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
        ["|", "^".padStart(subLineColumnNum)],
        ["|", subLines[subLineIndex + 1]]
      ]);
    }
    return locationStr + printPrefixedLines([
      // Lines specified like this: ["prefix", "string"],
      [`${lineNum - 1} |`, lines[lineIndex - 1]],
      [`${lineNum} |`, locationLine],
      ["|", "^".padStart(columnNum)],
      [`${lineNum + 1} |`, lines[lineIndex + 1]]
    ]);
  }
  function printPrefixedLines(lines) {
    const existingLines = lines.filter(([_, line]) => line !== void 0);
    const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
    return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
  }
  var init_printLocation = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printLocation.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_location();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/error/GraphQLError.mjs
  function toNormalizedOptions(args) {
    const firstArg = args[0];
    if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
      return {
        nodes: firstArg,
        source: args[1],
        positions: args[2],
        path: args[3],
        originalError: args[4],
        extensions: args[5]
      };
    }
    return firstArg;
  }
  function undefinedIfEmpty(array) {
    return array === void 0 || array.length === 0 ? void 0 : array;
  }
  function printError(error) {
    return error.toString();
  }
  function formatError(error) {
    return error.toJSON();
  }
  var GraphQLError;
  var init_GraphQLError = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/error/GraphQLError.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_isObjectLike();
      init_location();
      init_printLocation();
      GraphQLError = class _GraphQLError extends Error {
        /**
         * An array of `{ line, column }` locations within the source GraphQL document
         * which correspond to this error.
         *
         * Errors during validation often contain multiple locations, for example to
         * point out two things with the same name. Errors during execution include a
         * single location, the field which produced the error.
         *
         * Enumerable, and appears in the result of JSON.stringify().
         */
        /**
         * An array describing the JSON-path into the execution response which
         * corresponds to this error. Only included for errors during execution.
         *
         * Enumerable, and appears in the result of JSON.stringify().
         */
        /**
         * An array of GraphQL AST Nodes corresponding to this error.
         */
        /**
         * The source GraphQL document for the first location of this error.
         *
         * Note that if this Error represents more than one node, the source may not
         * represent nodes after the first node.
         */
        /**
         * An array of character offsets within the source GraphQL document
         * which correspond to this error.
         */
        /**
         * The original error thrown from a field resolver during execution.
         */
        /**
         * Extension fields to add to the formatted error.
         */
        /**
         * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
         */
        constructor(message, ...rawArgs) {
          var _this$nodes, _nodeLocations$, _ref;
          const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
          super(message);
          this.name = "GraphQLError";
          this.path = path !== null && path !== void 0 ? path : void 0;
          this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
          this.nodes = undefinedIfEmpty(
            Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
          );
          const nodeLocations = undefinedIfEmpty(
            (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
          );
          this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
          this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
          this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
          const originalExtensions = isObjectLike(
            originalError === null || originalError === void 0 ? void 0 : originalError.extensions
          ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
          this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
          Object.defineProperties(this, {
            message: {
              writable: true,
              enumerable: true
            },
            name: {
              enumerable: false
            },
            nodes: {
              enumerable: false
            },
            source: {
              enumerable: false
            },
            positions: {
              enumerable: false
            },
            originalError: {
              enumerable: false
            }
          });
          if (originalError !== null && originalError !== void 0 && originalError.stack) {
            Object.defineProperty(this, "stack", {
              value: originalError.stack,
              writable: true,
              configurable: true
            });
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, _GraphQLError);
          } else {
            Object.defineProperty(this, "stack", {
              value: Error().stack,
              writable: true,
              configurable: true
            });
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLError";
        }
        toString() {
          let output = this.message;
          if (this.nodes) {
            for (const node of this.nodes) {
              if (node.loc) {
                output += "\n\n" + printLocation(node.loc);
              }
            }
          } else if (this.source && this.locations) {
            for (const location of this.locations) {
              output += "\n\n" + printSourceLocation(this.source, location);
            }
          }
          return output;
        }
        toJSON() {
          const formattedError = {
            message: this.message
          };
          if (this.locations != null) {
            formattedError.locations = this.locations;
          }
          if (this.path != null) {
            formattedError.path = this.path;
          }
          if (this.extensions != null && Object.keys(this.extensions).length > 0) {
            formattedError.extensions = this.extensions;
          }
          return formattedError;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/error/syntaxError.mjs
  function syntaxError(source, position, description) {
    return new GraphQLError(`Syntax Error: ${description}`, {
      source,
      positions: [position]
    });
  }
  var init_syntaxError = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/error/syntaxError.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/ast.mjs
  function isNode(maybeNode) {
    const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
    return typeof maybeKind === "string" && kindValues.has(maybeKind);
  }
  var Location, Token, QueryDocumentKeys, kindValues, OperationTypeNode;
  var init_ast = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/ast.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Location = class {
        /**
         * The character offset at which this Node begins.
         */
        /**
         * The character offset at which this Node ends.
         */
        /**
         * The Token at which this Node begins.
         */
        /**
         * The Token at which this Node ends.
         */
        /**
         * The Source document the AST represents.
         */
        constructor(startToken, endToken, source) {
          this.start = startToken.start;
          this.end = endToken.end;
          this.startToken = startToken;
          this.endToken = endToken;
          this.source = source;
        }
        get [Symbol.toStringTag]() {
          return "Location";
        }
        toJSON() {
          return {
            start: this.start,
            end: this.end
          };
        }
      };
      Token = class {
        /**
         * The kind of Token.
         */
        /**
         * The character offset at which this Node begins.
         */
        /**
         * The character offset at which this Node ends.
         */
        /**
         * The 1-indexed line number on which this Token appears.
         */
        /**
         * The 1-indexed column number at which this Token begins.
         */
        /**
         * For non-punctuation tokens, represents the interpreted value of the token.
         *
         * Note: is undefined for punctuation tokens, but typed as string for
         * convenience in the parser.
         */
        /**
         * Tokens exist as nodes in a double-linked-list amongst all tokens
         * including ignored tokens. <SOF> is always the first node and <EOF>
         * the last.
         */
        constructor(kind, start, end, line, column, value) {
          this.kind = kind;
          this.start = start;
          this.end = end;
          this.line = line;
          this.column = column;
          this.value = value;
          this.prev = null;
          this.next = null;
        }
        get [Symbol.toStringTag]() {
          return "Token";
        }
        toJSON() {
          return {
            kind: this.kind,
            value: this.value,
            line: this.line,
            column: this.column
          };
        }
      };
      QueryDocumentKeys = {
        Name: [],
        Document: ["definitions"],
        OperationDefinition: [
          "name",
          "variableDefinitions",
          "directives",
          "selectionSet"
        ],
        VariableDefinition: ["variable", "type", "defaultValue", "directives"],
        Variable: ["name"],
        SelectionSet: ["selections"],
        Field: ["alias", "name", "arguments", "directives", "selectionSet"],
        Argument: ["name", "value"],
        FragmentSpread: ["name", "directives"],
        InlineFragment: ["typeCondition", "directives", "selectionSet"],
        FragmentDefinition: [
          "name",
          // Note: fragment variable definitions are deprecated and will removed in v17.0.0
          "variableDefinitions",
          "typeCondition",
          "directives",
          "selectionSet"
        ],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: ["values"],
        ObjectValue: ["fields"],
        ObjectField: ["name", "value"],
        Directive: ["name", "arguments"],
        NamedType: ["name"],
        ListType: ["type"],
        NonNullType: ["type"],
        SchemaDefinition: ["description", "directives", "operationTypes"],
        OperationTypeDefinition: ["type"],
        ScalarTypeDefinition: ["description", "name", "directives"],
        ObjectTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        FieldDefinition: ["description", "name", "arguments", "type", "directives"],
        InputValueDefinition: [
          "description",
          "name",
          "type",
          "defaultValue",
          "directives"
        ],
        InterfaceTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        UnionTypeDefinition: ["description", "name", "directives", "types"],
        EnumTypeDefinition: ["description", "name", "directives", "values"],
        EnumValueDefinition: ["description", "name", "directives"],
        InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
        DirectiveDefinition: ["description", "name", "arguments", "locations"],
        SchemaExtension: ["directives", "operationTypes"],
        ScalarTypeExtension: ["name", "directives"],
        ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
        InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
        UnionTypeExtension: ["name", "directives", "types"],
        EnumTypeExtension: ["name", "directives", "values"],
        InputObjectTypeExtension: ["name", "directives", "fields"]
      };
      kindValues = new Set(Object.keys(QueryDocumentKeys));
      (function(OperationTypeNode2) {
        OperationTypeNode2["QUERY"] = "query";
        OperationTypeNode2["MUTATION"] = "mutation";
        OperationTypeNode2["SUBSCRIPTION"] = "subscription";
      })(OperationTypeNode || (OperationTypeNode = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/directiveLocation.mjs
  var DirectiveLocation;
  var init_directiveLocation = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/directiveLocation.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      (function(DirectiveLocation2) {
        DirectiveLocation2["QUERY"] = "QUERY";
        DirectiveLocation2["MUTATION"] = "MUTATION";
        DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
        DirectiveLocation2["FIELD"] = "FIELD";
        DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
        DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
        DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
        DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
        DirectiveLocation2["SCHEMA"] = "SCHEMA";
        DirectiveLocation2["SCALAR"] = "SCALAR";
        DirectiveLocation2["OBJECT"] = "OBJECT";
        DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
        DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
        DirectiveLocation2["INTERFACE"] = "INTERFACE";
        DirectiveLocation2["UNION"] = "UNION";
        DirectiveLocation2["ENUM"] = "ENUM";
        DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
        DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
        DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
      })(DirectiveLocation || (DirectiveLocation = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/kinds.mjs
  var Kind;
  var init_kinds = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/kinds.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      (function(Kind2) {
        Kind2["NAME"] = "Name";
        Kind2["DOCUMENT"] = "Document";
        Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
        Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
        Kind2["SELECTION_SET"] = "SelectionSet";
        Kind2["FIELD"] = "Field";
        Kind2["ARGUMENT"] = "Argument";
        Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
        Kind2["INLINE_FRAGMENT"] = "InlineFragment";
        Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
        Kind2["VARIABLE"] = "Variable";
        Kind2["INT"] = "IntValue";
        Kind2["FLOAT"] = "FloatValue";
        Kind2["STRING"] = "StringValue";
        Kind2["BOOLEAN"] = "BooleanValue";
        Kind2["NULL"] = "NullValue";
        Kind2["ENUM"] = "EnumValue";
        Kind2["LIST"] = "ListValue";
        Kind2["OBJECT"] = "ObjectValue";
        Kind2["OBJECT_FIELD"] = "ObjectField";
        Kind2["DIRECTIVE"] = "Directive";
        Kind2["NAMED_TYPE"] = "NamedType";
        Kind2["LIST_TYPE"] = "ListType";
        Kind2["NON_NULL_TYPE"] = "NonNullType";
        Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
        Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
        Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
        Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
        Kind2["FIELD_DEFINITION"] = "FieldDefinition";
        Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
        Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
        Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
        Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
        Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
        Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
        Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
        Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
        Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
        Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
        Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
        Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
        Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
        Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
      })(Kind || (Kind = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/characterClasses.mjs
  function isWhiteSpace(code) {
    return code === 9 || code === 32;
  }
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }
  function isLetter(code) {
    return code >= 97 && code <= 122 || // A-Z
    code >= 65 && code <= 90;
  }
  function isNameStart(code) {
    return isLetter(code) || code === 95;
  }
  function isNameContinue(code) {
    return isLetter(code) || isDigit(code) || code === 95;
  }
  var init_characterClasses = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/characterClasses.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/blockString.mjs
  function dedentBlockStringLines(lines) {
    var _firstNonEmptyLine2;
    let commonIndent = Number.MAX_SAFE_INTEGER;
    let firstNonEmptyLine = null;
    let lastNonEmptyLine = -1;
    for (let i2 = 0; i2 < lines.length; ++i2) {
      var _firstNonEmptyLine;
      const line = lines[i2];
      const indent2 = leadingWhitespace(line);
      if (indent2 === line.length) {
        continue;
      }
      firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i2;
      lastNonEmptyLine = i2;
      if (i2 !== 0 && indent2 < commonIndent) {
        commonIndent = indent2;
      }
    }
    return lines.map((line, i2) => i2 === 0 ? line : line.slice(commonIndent)).slice(
      (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
      lastNonEmptyLine + 1
    );
  }
  function leadingWhitespace(str) {
    let i2 = 0;
    while (i2 < str.length && isWhiteSpace(str.charCodeAt(i2))) {
      ++i2;
    }
    return i2;
  }
  function isPrintableAsBlockString(value) {
    if (value === "") {
      return true;
    }
    let isEmptyLine = true;
    let hasIndent = false;
    let hasCommonIndent = true;
    let seenNonEmptyLine = false;
    for (let i2 = 0; i2 < value.length; ++i2) {
      switch (value.codePointAt(i2)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 11:
        case 12:
        case 14:
        case 15:
          return false;
        case 13:
          return false;
        case 10:
          if (isEmptyLine && !seenNonEmptyLine) {
            return false;
          }
          seenNonEmptyLine = true;
          isEmptyLine = true;
          hasIndent = false;
          break;
        case 9:
        case 32:
          hasIndent || (hasIndent = isEmptyLine);
          break;
        default:
          hasCommonIndent && (hasCommonIndent = hasIndent);
          isEmptyLine = false;
      }
    }
    if (isEmptyLine) {
      return false;
    }
    if (hasCommonIndent && seenNonEmptyLine) {
      return false;
    }
    return true;
  }
  function printBlockString(value, options) {
    const escapedValue = value.replace(/"""/g, '\\"""');
    const lines = escapedValue.split(/\r\n|[\n\r]/g);
    const isSingleLine = lines.length === 1;
    const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
    const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
    const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
    const hasTrailingSlash = value.endsWith("\\");
    const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
    const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
    (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
    let result = "";
    const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
    if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
      result += "\n";
    }
    result += escapedValue;
    if (printAsMultipleLines || forceTrailingNewline) {
      result += "\n";
    }
    return '"""' + result + '"""';
  }
  var init_blockString = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/blockString.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_characterClasses();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/tokenKind.mjs
  var TokenKind;
  var init_tokenKind = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/tokenKind.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      (function(TokenKind2) {
        TokenKind2["SOF"] = "<SOF>";
        TokenKind2["EOF"] = "<EOF>";
        TokenKind2["BANG"] = "!";
        TokenKind2["DOLLAR"] = "$";
        TokenKind2["AMP"] = "&";
        TokenKind2["PAREN_L"] = "(";
        TokenKind2["PAREN_R"] = ")";
        TokenKind2["SPREAD"] = "...";
        TokenKind2["COLON"] = ":";
        TokenKind2["EQUALS"] = "=";
        TokenKind2["AT"] = "@";
        TokenKind2["BRACKET_L"] = "[";
        TokenKind2["BRACKET_R"] = "]";
        TokenKind2["BRACE_L"] = "{";
        TokenKind2["PIPE"] = "|";
        TokenKind2["BRACE_R"] = "}";
        TokenKind2["NAME"] = "Name";
        TokenKind2["INT"] = "Int";
        TokenKind2["FLOAT"] = "Float";
        TokenKind2["STRING"] = "String";
        TokenKind2["BLOCK_STRING"] = "BlockString";
        TokenKind2["COMMENT"] = "Comment";
      })(TokenKind || (TokenKind = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/lexer.mjs
  function isPunctuatorTokenKind(kind) {
    return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
  }
  function isUnicodeScalarValue(code) {
    return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
  }
  function isSupplementaryCodePoint(body, location) {
    return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
  }
  function isLeadingSurrogate(code) {
    return code >= 55296 && code <= 56319;
  }
  function isTrailingSurrogate(code) {
    return code >= 56320 && code <= 57343;
  }
  function printCodePointAt(lexer, location) {
    const code = lexer.source.body.codePointAt(location);
    if (code === void 0) {
      return TokenKind.EOF;
    } else if (code >= 32 && code <= 126) {
      const char = String.fromCodePoint(code);
      return char === '"' ? `'"'` : `"${char}"`;
    }
    return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
  }
  function createToken(lexer, kind, start, end, value) {
    const line = lexer.line;
    const col = 1 + start - lexer.lineStart;
    return new Token(kind, start, end, line, col, value);
  }
  function readNextToken(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      switch (code) {
        case 65279:
        case 9:
        case 32:
        case 44:
          ++position;
          continue;
        case 10:
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 13:
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 35:
          return readComment(lexer, position);
        case 33:
          return createToken(lexer, TokenKind.BANG, position, position + 1);
        case 36:
          return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
        case 38:
          return createToken(lexer, TokenKind.AMP, position, position + 1);
        case 40:
          return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
        case 41:
          return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
        case 46:
          if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
            return createToken(lexer, TokenKind.SPREAD, position, position + 3);
          }
          break;
        case 58:
          return createToken(lexer, TokenKind.COLON, position, position + 1);
        case 61:
          return createToken(lexer, TokenKind.EQUALS, position, position + 1);
        case 64:
          return createToken(lexer, TokenKind.AT, position, position + 1);
        case 91:
          return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
        case 93:
          return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
        case 123:
          return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
        case 124:
          return createToken(lexer, TokenKind.PIPE, position, position + 1);
        case 125:
          return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
        case 34:
          if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            return readBlockString(lexer, position);
          }
          return readString(lexer, position);
      }
      if (isDigit(code) || code === 45) {
        return readNumber(lexer, position, code);
      }
      if (isNameStart(code)) {
        return readName(lexer, position);
      }
      throw syntaxError(
        lexer.source,
        position,
        code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
      );
    }
    return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
  }
  function readComment(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.COMMENT,
      start,
      position,
      body.slice(start + 1, position)
    );
  }
  function readNumber(lexer, start, firstCode) {
    const body = lexer.source.body;
    let position = start;
    let code = firstCode;
    let isFloat = false;
    if (code === 45) {
      code = body.charCodeAt(++position);
    }
    if (code === 48) {
      code = body.charCodeAt(++position);
      if (isDigit(code)) {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid number, unexpected digit after 0: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    } else {
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46) {
      isFloat = true;
      code = body.charCodeAt(++position);
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 69 || code === 101) {
      isFloat = true;
      code = body.charCodeAt(++position);
      if (code === 43 || code === 45) {
        code = body.charCodeAt(++position);
      }
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46 || isNameStart(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
    return createToken(
      lexer,
      isFloat ? TokenKind.FLOAT : TokenKind.INT,
      start,
      position,
      body.slice(start, position)
    );
  }
  function readDigits(lexer, start, firstCode) {
    if (!isDigit(firstCode)) {
      throw syntaxError(
        lexer.source,
        start,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          start
        )}.`
      );
    }
    const body = lexer.source.body;
    let position = start + 1;
    while (isDigit(body.charCodeAt(position))) {
      ++position;
    }
    return position;
  }
  function readString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    let chunkStart = position;
    let value = "";
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34) {
        value += body.slice(chunkStart, position);
        return createToken(lexer, TokenKind.STRING, start, position + 1, value);
      }
      if (code === 92) {
        value += body.slice(chunkStart, position);
        const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
        value += escape.value;
        position += escape.size;
        chunkStart = position;
        continue;
      }
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readEscapedUnicodeVariableWidth(lexer, position) {
    const body = lexer.source.body;
    let point = 0;
    let size = 3;
    while (size < 12) {
      const code = body.charCodeAt(position + size++);
      if (code === 125) {
        if (size < 5 || !isUnicodeScalarValue(point)) {
          break;
        }
        return {
          value: String.fromCodePoint(point),
          size
        };
      }
      point = point << 4 | readHexDigit(code);
      if (point < 0) {
        break;
      }
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid Unicode escape sequence: "${body.slice(
        position,
        position + size
      )}".`
    );
  }
  function readEscapedUnicodeFixedWidth(lexer, position) {
    const body = lexer.source.body;
    const code = read16BitHexCode(body, position + 2);
    if (isUnicodeScalarValue(code)) {
      return {
        value: String.fromCodePoint(code),
        size: 6
      };
    }
    if (isLeadingSurrogate(code)) {
      if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
        const trailingCode = read16BitHexCode(body, position + 8);
        if (isTrailingSurrogate(trailingCode)) {
          return {
            value: String.fromCodePoint(code, trailingCode),
            size: 12
          };
        }
      }
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
    );
  }
  function read16BitHexCode(body, position) {
    return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
  }
  function readHexDigit(code) {
    return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
  }
  function readEscapedCharacter(lexer, position) {
    const body = lexer.source.body;
    const code = body.charCodeAt(position + 1);
    switch (code) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: "\n",
          size: 2
        };
      case 114:
        return {
          value: "\r",
          size: 2
        };
      case 116:
        return {
          value: "	",
          size: 2
        };
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid character escape sequence: "${body.slice(
        position,
        position + 2
      )}".`
    );
  }
  function readBlockString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let lineStart = lexer.lineStart;
    let position = start + 3;
    let chunkStart = position;
    let currentLine = "";
    const blockLines = [];
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        const token = createToken(
          lexer,
          TokenKind.BLOCK_STRING,
          start,
          position + 3,
          // Return a string of the lines joined with U+000A.
          dedentBlockStringLines(blockLines).join("\n")
        );
        lexer.line += blockLines.length - 1;
        lexer.lineStart = lineStart;
        return token;
      }
      if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
        currentLine += body.slice(chunkStart, position);
        chunkStart = position + 1;
        position += 4;
        continue;
      }
      if (code === 10 || code === 13) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        if (code === 13 && body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        currentLine = "";
        chunkStart = position;
        lineStart = position;
        continue;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readName(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (isNameContinue(code)) {
        ++position;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.NAME,
      start,
      position,
      body.slice(start, position)
    );
  }
  var Lexer;
  var init_lexer = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/lexer.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_syntaxError();
      init_ast();
      init_blockString();
      init_characterClasses();
      init_tokenKind();
      Lexer = class {
        /**
         * The previously focused non-ignored token.
         */
        /**
         * The currently focused non-ignored token.
         */
        /**
         * The (1-indexed) line containing the current token.
         */
        /**
         * The character offset at which the current line begins.
         */
        constructor(source) {
          const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
          this.source = source;
          this.lastToken = startOfFileToken;
          this.token = startOfFileToken;
          this.line = 1;
          this.lineStart = 0;
        }
        get [Symbol.toStringTag]() {
          return "Lexer";
        }
        /**
         * Advances the token stream to the next non-ignored token.
         */
        advance() {
          this.lastToken = this.token;
          const token = this.token = this.lookahead();
          return token;
        }
        /**
         * Looks ahead and returns the next non-ignored token, but does not change
         * the state of Lexer.
         */
        lookahead() {
          let token = this.token;
          if (token.kind !== TokenKind.EOF) {
            do {
              if (token.next) {
                token = token.next;
              } else {
                const nextToken = readNextToken(this, token.end);
                token.next = nextToken;
                nextToken.prev = token;
                token = nextToken;
              }
            } while (token.kind === TokenKind.COMMENT);
          }
          return token;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/inspect.mjs
  function inspect(value) {
    return formatValue(value, []);
  }
  function formatValue(value, seenValues) {
    switch (typeof value) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? `[function ${value.name}]` : "[function]";
      case "object":
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  }
  function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
      return "null";
    }
    if (previouslySeenValues.includes(value)) {
      return "[Circular]";
    }
    const seenValues = [...previouslySeenValues, value];
    if (isJSONable(value)) {
      const jsonValue = value.toJSON();
      if (jsonValue !== value) {
        return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  }
  function isJSONable(value) {
    return typeof value.toJSON === "function";
  }
  function formatObject(object, seenValues) {
    const entries = Object.entries(object);
    if (entries.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object) + "]";
    }
    const properties = entries.map(
      ([key, value]) => key + ": " + formatValue(value, seenValues)
    );
    return "{ " + properties.join(", ") + " }";
  }
  function formatArray(array, seenValues) {
    if (array.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array.length);
    const remaining = array.length - len;
    const items = [];
    for (let i2 = 0; i2 < len; ++i2) {
      items.push(formatValue(array[i2], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
  }
  function getObjectTag(object) {
    const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object.constructor === "function") {
      const name2 = object.constructor.name;
      if (typeof name2 === "string" && name2 !== "") {
        return name2;
      }
    }
    return tag;
  }
  var MAX_ARRAY_LENGTH, MAX_RECURSIVE_DEPTH;
  var init_inspect = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/inspect.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      MAX_ARRAY_LENGTH = 10;
      MAX_RECURSIVE_DEPTH = 2;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/instanceOf.mjs
  var instanceOf;
  var init_instanceOf = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/instanceOf.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      instanceOf = /* c8 ignore next 6 */
      // FIXME: https://github.com/graphql/graphql-js/issues/2317
      globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf2(value, constructor) {
        return value instanceof constructor;
      } : function instanceOf3(value, constructor) {
        if (value instanceof constructor) {
          return true;
        }
        if (typeof value === "object" && value !== null) {
          var _value$constructor;
          const className = constructor.prototype[Symbol.toStringTag];
          const valueClassName = (
            // We still need to support constructor's name to detect conflicts with older versions of this library.
            Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
          );
          if (className === valueClassName) {
            const stringifiedValue = inspect(value);
            throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
          }
        }
        return false;
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/source.mjs
  function isSource(source) {
    return instanceOf(source, Source);
  }
  var Source;
  var init_source = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/source.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_inspect();
      init_instanceOf();
      Source = class {
        constructor(body, name2 = "GraphQL request", locationOffset = {
          line: 1,
          column: 1
        }) {
          typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
          this.body = body;
          this.name = name2;
          this.locationOffset = locationOffset;
          this.locationOffset.line > 0 || devAssert(
            false,
            "line in locationOffset is 1-indexed and must be positive."
          );
          this.locationOffset.column > 0 || devAssert(
            false,
            "column in locationOffset is 1-indexed and must be positive."
          );
        }
        get [Symbol.toStringTag]() {
          return "Source";
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/parser.mjs
  function parse(source, options) {
    const parser = new Parser(source, options);
    return parser.parseDocument();
  }
  function parseValue(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(TokenKind.SOF);
    const value = parser.parseValueLiteral(false);
    parser.expectToken(TokenKind.EOF);
    return value;
  }
  function parseConstValue(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(TokenKind.SOF);
    const value = parser.parseConstValueLiteral();
    parser.expectToken(TokenKind.EOF);
    return value;
  }
  function parseType(source, options) {
    const parser = new Parser(source, options);
    parser.expectToken(TokenKind.SOF);
    const type = parser.parseTypeReference();
    parser.expectToken(TokenKind.EOF);
    return type;
  }
  function getTokenDesc(token) {
    const value = token.value;
    return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
  }
  function getTokenKindDesc(kind) {
    return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
  }
  var Parser;
  var init_parser = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/parser.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_syntaxError();
      init_ast();
      init_directiveLocation();
      init_kinds();
      init_lexer();
      init_source();
      init_tokenKind();
      Parser = class {
        constructor(source, options = {}) {
          const sourceObj = isSource(source) ? source : new Source(source);
          this._lexer = new Lexer(sourceObj);
          this._options = options;
          this._tokenCounter = 0;
        }
        /**
         * Converts a name lex token into a name parse node.
         */
        parseName() {
          const token = this.expectToken(TokenKind.NAME);
          return this.node(token, {
            kind: Kind.NAME,
            value: token.value
          });
        }
        // Implements the parsing rules in the Document section.
        /**
         * Document : Definition+
         */
        parseDocument() {
          return this.node(this._lexer.token, {
            kind: Kind.DOCUMENT,
            definitions: this.many(
              TokenKind.SOF,
              this.parseDefinition,
              TokenKind.EOF
            )
          });
        }
        /**
         * Definition :
         *   - ExecutableDefinition
         *   - TypeSystemDefinition
         *   - TypeSystemExtension
         *
         * ExecutableDefinition :
         *   - OperationDefinition
         *   - FragmentDefinition
         *
         * TypeSystemDefinition :
         *   - SchemaDefinition
         *   - TypeDefinition
         *   - DirectiveDefinition
         *
         * TypeDefinition :
         *   - ScalarTypeDefinition
         *   - ObjectTypeDefinition
         *   - InterfaceTypeDefinition
         *   - UnionTypeDefinition
         *   - EnumTypeDefinition
         *   - InputObjectTypeDefinition
         */
        parseDefinition() {
          if (this.peek(TokenKind.BRACE_L)) {
            return this.parseOperationDefinition();
          }
          const hasDescription = this.peekDescription();
          const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
          if (keywordToken.kind === TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaDefinition();
              case "scalar":
                return this.parseScalarTypeDefinition();
              case "type":
                return this.parseObjectTypeDefinition();
              case "interface":
                return this.parseInterfaceTypeDefinition();
              case "union":
                return this.parseUnionTypeDefinition();
              case "enum":
                return this.parseEnumTypeDefinition();
              case "input":
                return this.parseInputObjectTypeDefinition();
              case "directive":
                return this.parseDirectiveDefinition();
            }
            if (hasDescription) {
              throw syntaxError(
                this._lexer.source,
                this._lexer.token.start,
                "Unexpected description, descriptions are supported only on type definitions."
              );
            }
            switch (keywordToken.value) {
              case "query":
              case "mutation":
              case "subscription":
                return this.parseOperationDefinition();
              case "fragment":
                return this.parseFragmentDefinition();
              case "extend":
                return this.parseTypeSystemExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        // Implements the parsing rules in the Operations section.
        /**
         * OperationDefinition :
         *  - SelectionSet
         *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
         */
        parseOperationDefinition() {
          const start = this._lexer.token;
          if (this.peek(TokenKind.BRACE_L)) {
            return this.node(start, {
              kind: Kind.OPERATION_DEFINITION,
              operation: OperationTypeNode.QUERY,
              name: void 0,
              variableDefinitions: [],
              directives: [],
              selectionSet: this.parseSelectionSet()
            });
          }
          const operation = this.parseOperationType();
          let name2;
          if (this.peek(TokenKind.NAME)) {
            name2 = this.parseName();
          }
          return this.node(start, {
            kind: Kind.OPERATION_DEFINITION,
            operation,
            name: name2,
            variableDefinitions: this.parseVariableDefinitions(),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * OperationType : one of query mutation subscription
         */
        parseOperationType() {
          const operationToken = this.expectToken(TokenKind.NAME);
          switch (operationToken.value) {
            case "query":
              return OperationTypeNode.QUERY;
            case "mutation":
              return OperationTypeNode.MUTATION;
            case "subscription":
              return OperationTypeNode.SUBSCRIPTION;
          }
          throw this.unexpected(operationToken);
        }
        /**
         * VariableDefinitions : ( VariableDefinition+ )
         */
        parseVariableDefinitions() {
          return this.optionalMany(
            TokenKind.PAREN_L,
            this.parseVariableDefinition,
            TokenKind.PAREN_R
          );
        }
        /**
         * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
         */
        parseVariableDefinition() {
          return this.node(this._lexer.token, {
            kind: Kind.VARIABLE_DEFINITION,
            variable: this.parseVariable(),
            type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
            defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
            directives: this.parseConstDirectives()
          });
        }
        /**
         * Variable : $ Name
         */
        parseVariable() {
          const start = this._lexer.token;
          this.expectToken(TokenKind.DOLLAR);
          return this.node(start, {
            kind: Kind.VARIABLE,
            name: this.parseName()
          });
        }
        /**
         * ```
         * SelectionSet : { Selection+ }
         * ```
         */
        parseSelectionSet() {
          return this.node(this._lexer.token, {
            kind: Kind.SELECTION_SET,
            selections: this.many(
              TokenKind.BRACE_L,
              this.parseSelection,
              TokenKind.BRACE_R
            )
          });
        }
        /**
         * Selection :
         *   - Field
         *   - FragmentSpread
         *   - InlineFragment
         */
        parseSelection() {
          return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
        }
        /**
         * Field : Alias? Name Arguments? Directives? SelectionSet?
         *
         * Alias : Name :
         */
        parseField() {
          const start = this._lexer.token;
          const nameOrAlias = this.parseName();
          let alias;
          let name2;
          if (this.expectOptionalToken(TokenKind.COLON)) {
            alias = nameOrAlias;
            name2 = this.parseName();
          } else {
            name2 = nameOrAlias;
          }
          return this.node(start, {
            kind: Kind.FIELD,
            alias,
            name: name2,
            arguments: this.parseArguments(false),
            directives: this.parseDirectives(false),
            selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
          });
        }
        /**
         * Arguments[Const] : ( Argument[?Const]+ )
         */
        parseArguments(isConst) {
          const item = isConst ? this.parseConstArgument : this.parseArgument;
          return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
        }
        /**
         * Argument[Const] : Name : Value[?Const]
         */
        parseArgument(isConst = false) {
          const start = this._lexer.token;
          const name2 = this.parseName();
          this.expectToken(TokenKind.COLON);
          return this.node(start, {
            kind: Kind.ARGUMENT,
            name: name2,
            value: this.parseValueLiteral(isConst)
          });
        }
        parseConstArgument() {
          return this.parseArgument(true);
        }
        // Implements the parsing rules in the Fragments section.
        /**
         * Corresponds to both FragmentSpread and InlineFragment in the spec.
         *
         * FragmentSpread : ... FragmentName Directives?
         *
         * InlineFragment : ... TypeCondition? Directives? SelectionSet
         */
        parseFragment() {
          const start = this._lexer.token;
          this.expectToken(TokenKind.SPREAD);
          const hasTypeCondition = this.expectOptionalKeyword("on");
          if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
            return this.node(start, {
              kind: Kind.FRAGMENT_SPREAD,
              name: this.parseFragmentName(),
              directives: this.parseDirectives(false)
            });
          }
          return this.node(start, {
            kind: Kind.INLINE_FRAGMENT,
            typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * FragmentDefinition :
         *   - fragment FragmentName on TypeCondition Directives? SelectionSet
         *
         * TypeCondition : NamedType
         */
        parseFragmentDefinition() {
          const start = this._lexer.token;
          this.expectKeyword("fragment");
          if (this._options.allowLegacyFragmentVariables === true) {
            return this.node(start, {
              kind: Kind.FRAGMENT_DEFINITION,
              name: this.parseFragmentName(),
              variableDefinitions: this.parseVariableDefinitions(),
              typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
              directives: this.parseDirectives(false),
              selectionSet: this.parseSelectionSet()
            });
          }
          return this.node(start, {
            kind: Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * FragmentName : Name but not `on`
         */
        parseFragmentName() {
          if (this._lexer.token.value === "on") {
            throw this.unexpected();
          }
          return this.parseName();
        }
        // Implements the parsing rules in the Values section.
        /**
         * Value[Const] :
         *   - [~Const] Variable
         *   - IntValue
         *   - FloatValue
         *   - StringValue
         *   - BooleanValue
         *   - NullValue
         *   - EnumValue
         *   - ListValue[?Const]
         *   - ObjectValue[?Const]
         *
         * BooleanValue : one of `true` `false`
         *
         * NullValue : `null`
         *
         * EnumValue : Name but not `true`, `false` or `null`
         */
        parseValueLiteral(isConst) {
          const token = this._lexer.token;
          switch (token.kind) {
            case TokenKind.BRACKET_L:
              return this.parseList(isConst);
            case TokenKind.BRACE_L:
              return this.parseObject(isConst);
            case TokenKind.INT:
              this.advanceLexer();
              return this.node(token, {
                kind: Kind.INT,
                value: token.value
              });
            case TokenKind.FLOAT:
              this.advanceLexer();
              return this.node(token, {
                kind: Kind.FLOAT,
                value: token.value
              });
            case TokenKind.STRING:
            case TokenKind.BLOCK_STRING:
              return this.parseStringLiteral();
            case TokenKind.NAME:
              this.advanceLexer();
              switch (token.value) {
                case "true":
                  return this.node(token, {
                    kind: Kind.BOOLEAN,
                    value: true
                  });
                case "false":
                  return this.node(token, {
                    kind: Kind.BOOLEAN,
                    value: false
                  });
                case "null":
                  return this.node(token, {
                    kind: Kind.NULL
                  });
                default:
                  return this.node(token, {
                    kind: Kind.ENUM,
                    value: token.value
                  });
              }
            case TokenKind.DOLLAR:
              if (isConst) {
                this.expectToken(TokenKind.DOLLAR);
                if (this._lexer.token.kind === TokenKind.NAME) {
                  const varName = this._lexer.token.value;
                  throw syntaxError(
                    this._lexer.source,
                    token.start,
                    `Unexpected variable "$${varName}" in constant value.`
                  );
                } else {
                  throw this.unexpected(token);
                }
              }
              return this.parseVariable();
            default:
              throw this.unexpected();
          }
        }
        parseConstValueLiteral() {
          return this.parseValueLiteral(true);
        }
        parseStringLiteral() {
          const token = this._lexer.token;
          this.advanceLexer();
          return this.node(token, {
            kind: Kind.STRING,
            value: token.value,
            block: token.kind === TokenKind.BLOCK_STRING
          });
        }
        /**
         * ListValue[Const] :
         *   - [ ]
         *   - [ Value[?Const]+ ]
         */
        parseList(isConst) {
          const item = () => this.parseValueLiteral(isConst);
          return this.node(this._lexer.token, {
            kind: Kind.LIST,
            values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
          });
        }
        /**
         * ```
         * ObjectValue[Const] :
         *   - { }
         *   - { ObjectField[?Const]+ }
         * ```
         */
        parseObject(isConst) {
          const item = () => this.parseObjectField(isConst);
          return this.node(this._lexer.token, {
            kind: Kind.OBJECT,
            fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
          });
        }
        /**
         * ObjectField[Const] : Name : Value[?Const]
         */
        parseObjectField(isConst) {
          const start = this._lexer.token;
          const name2 = this.parseName();
          this.expectToken(TokenKind.COLON);
          return this.node(start, {
            kind: Kind.OBJECT_FIELD,
            name: name2,
            value: this.parseValueLiteral(isConst)
          });
        }
        // Implements the parsing rules in the Directives section.
        /**
         * Directives[Const] : Directive[?Const]+
         */
        parseDirectives(isConst) {
          const directives = [];
          while (this.peek(TokenKind.AT)) {
            directives.push(this.parseDirective(isConst));
          }
          return directives;
        }
        parseConstDirectives() {
          return this.parseDirectives(true);
        }
        /**
         * ```
         * Directive[Const] : @ Name Arguments[?Const]?
         * ```
         */
        parseDirective(isConst) {
          const start = this._lexer.token;
          this.expectToken(TokenKind.AT);
          return this.node(start, {
            kind: Kind.DIRECTIVE,
            name: this.parseName(),
            arguments: this.parseArguments(isConst)
          });
        }
        // Implements the parsing rules in the Types section.
        /**
         * Type :
         *   - NamedType
         *   - ListType
         *   - NonNullType
         */
        parseTypeReference() {
          const start = this._lexer.token;
          let type;
          if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
            const innerType = this.parseTypeReference();
            this.expectToken(TokenKind.BRACKET_R);
            type = this.node(start, {
              kind: Kind.LIST_TYPE,
              type: innerType
            });
          } else {
            type = this.parseNamedType();
          }
          if (this.expectOptionalToken(TokenKind.BANG)) {
            return this.node(start, {
              kind: Kind.NON_NULL_TYPE,
              type
            });
          }
          return type;
        }
        /**
         * NamedType : Name
         */
        parseNamedType() {
          return this.node(this._lexer.token, {
            kind: Kind.NAMED_TYPE,
            name: this.parseName()
          });
        }
        // Implements the parsing rules in the Type Definition section.
        peekDescription() {
          return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
        }
        /**
         * Description : StringValue
         */
        parseDescription() {
          if (this.peekDescription()) {
            return this.parseStringLiteral();
          }
        }
        /**
         * ```
         * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
         * ```
         */
        parseSchemaDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.many(
            TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            TokenKind.BRACE_R
          );
          return this.node(start, {
            kind: Kind.SCHEMA_DEFINITION,
            description,
            directives,
            operationTypes
          });
        }
        /**
         * OperationTypeDefinition : OperationType : NamedType
         */
        parseOperationTypeDefinition() {
          const start = this._lexer.token;
          const operation = this.parseOperationType();
          this.expectToken(TokenKind.COLON);
          const type = this.parseNamedType();
          return this.node(start, {
            kind: Kind.OPERATION_TYPE_DEFINITION,
            operation,
            type
          });
        }
        /**
         * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
         */
        parseScalarTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("scalar");
          const name2 = this.parseName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: Kind.SCALAR_TYPE_DEFINITION,
            description,
            name: name2,
            directives
          });
        }
        /**
         * ObjectTypeDefinition :
         *   Description?
         *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
         */
        parseObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("type");
          const name2 = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: Kind.OBJECT_TYPE_DEFINITION,
            description,
            name: name2,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * ImplementsInterfaces :
         *   - implements `&`? NamedType
         *   - ImplementsInterfaces & NamedType
         */
        parseImplementsInterfaces() {
          return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
        }
        /**
         * ```
         * FieldsDefinition : { FieldDefinition+ }
         * ```
         */
        parseFieldsDefinition() {
          return this.optionalMany(
            TokenKind.BRACE_L,
            this.parseFieldDefinition,
            TokenKind.BRACE_R
          );
        }
        /**
         * FieldDefinition :
         *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
         */
        parseFieldDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name2 = this.parseName();
          const args = this.parseArgumentDefs();
          this.expectToken(TokenKind.COLON);
          const type = this.parseTypeReference();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: Kind.FIELD_DEFINITION,
            description,
            name: name2,
            arguments: args,
            type,
            directives
          });
        }
        /**
         * ArgumentsDefinition : ( InputValueDefinition+ )
         */
        parseArgumentDefs() {
          return this.optionalMany(
            TokenKind.PAREN_L,
            this.parseInputValueDef,
            TokenKind.PAREN_R
          );
        }
        /**
         * InputValueDefinition :
         *   - Description? Name : Type DefaultValue? Directives[Const]?
         */
        parseInputValueDef() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name2 = this.parseName();
          this.expectToken(TokenKind.COLON);
          const type = this.parseTypeReference();
          let defaultValue;
          if (this.expectOptionalToken(TokenKind.EQUALS)) {
            defaultValue = this.parseConstValueLiteral();
          }
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: Kind.INPUT_VALUE_DEFINITION,
            description,
            name: name2,
            type,
            defaultValue,
            directives
          });
        }
        /**
         * InterfaceTypeDefinition :
         *   - Description? interface Name Directives[Const]? FieldsDefinition?
         */
        parseInterfaceTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("interface");
          const name2 = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: Kind.INTERFACE_TYPE_DEFINITION,
            description,
            name: name2,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * UnionTypeDefinition :
         *   - Description? union Name Directives[Const]? UnionMemberTypes?
         */
        parseUnionTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("union");
          const name2 = this.parseName();
          const directives = this.parseConstDirectives();
          const types = this.parseUnionMemberTypes();
          return this.node(start, {
            kind: Kind.UNION_TYPE_DEFINITION,
            description,
            name: name2,
            directives,
            types
          });
        }
        /**
         * UnionMemberTypes :
         *   - = `|`? NamedType
         *   - UnionMemberTypes | NamedType
         */
        parseUnionMemberTypes() {
          return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
        }
        /**
         * EnumTypeDefinition :
         *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
         */
        parseEnumTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("enum");
          const name2 = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          return this.node(start, {
            kind: Kind.ENUM_TYPE_DEFINITION,
            description,
            name: name2,
            directives,
            values
          });
        }
        /**
         * ```
         * EnumValuesDefinition : { EnumValueDefinition+ }
         * ```
         */
        parseEnumValuesDefinition() {
          return this.optionalMany(
            TokenKind.BRACE_L,
            this.parseEnumValueDefinition,
            TokenKind.BRACE_R
          );
        }
        /**
         * EnumValueDefinition : Description? EnumValue Directives[Const]?
         */
        parseEnumValueDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name2 = this.parseEnumValueName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: Kind.ENUM_VALUE_DEFINITION,
            description,
            name: name2,
            directives
          });
        }
        /**
         * EnumValue : Name but not `true`, `false` or `null`
         */
        parseEnumValueName() {
          if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
            throw syntaxError(
              this._lexer.source,
              this._lexer.token.start,
              `${getTokenDesc(
                this._lexer.token
              )} is reserved and cannot be used for an enum value.`
            );
          }
          return this.parseName();
        }
        /**
         * InputObjectTypeDefinition :
         *   - Description? input Name Directives[Const]? InputFieldsDefinition?
         */
        parseInputObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("input");
          const name2 = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          return this.node(start, {
            kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
            description,
            name: name2,
            directives,
            fields
          });
        }
        /**
         * ```
         * InputFieldsDefinition : { InputValueDefinition+ }
         * ```
         */
        parseInputFieldsDefinition() {
          return this.optionalMany(
            TokenKind.BRACE_L,
            this.parseInputValueDef,
            TokenKind.BRACE_R
          );
        }
        /**
         * TypeSystemExtension :
         *   - SchemaExtension
         *   - TypeExtension
         *
         * TypeExtension :
         *   - ScalarTypeExtension
         *   - ObjectTypeExtension
         *   - InterfaceTypeExtension
         *   - UnionTypeExtension
         *   - EnumTypeExtension
         *   - InputObjectTypeDefinition
         */
        parseTypeSystemExtension() {
          const keywordToken = this._lexer.lookahead();
          if (keywordToken.kind === TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaExtension();
              case "scalar":
                return this.parseScalarTypeExtension();
              case "type":
                return this.parseObjectTypeExtension();
              case "interface":
                return this.parseInterfaceTypeExtension();
              case "union":
                return this.parseUnionTypeExtension();
              case "enum":
                return this.parseEnumTypeExtension();
              case "input":
                return this.parseInputObjectTypeExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        /**
         * ```
         * SchemaExtension :
         *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
         *  - extend schema Directives[Const]
         * ```
         */
        parseSchemaExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.optionalMany(
            TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            TokenKind.BRACE_R
          );
          if (directives.length === 0 && operationTypes.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: Kind.SCHEMA_EXTENSION,
            directives,
            operationTypes
          });
        }
        /**
         * ScalarTypeExtension :
         *   - extend scalar Name Directives[Const]
         */
        parseScalarTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("scalar");
          const name2 = this.parseName();
          const directives = this.parseConstDirectives();
          if (directives.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: Kind.SCALAR_TYPE_EXTENSION,
            name: name2,
            directives
          });
        }
        /**
         * ObjectTypeExtension :
         *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
         *  - extend type Name ImplementsInterfaces? Directives[Const]
         *  - extend type Name ImplementsInterfaces
         */
        parseObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("type");
          const name2 = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: Kind.OBJECT_TYPE_EXTENSION,
            name: name2,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * InterfaceTypeExtension :
         *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
         *  - extend interface Name ImplementsInterfaces? Directives[Const]
         *  - extend interface Name ImplementsInterfaces
         */
        parseInterfaceTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("interface");
          const name2 = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: Kind.INTERFACE_TYPE_EXTENSION,
            name: name2,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * UnionTypeExtension :
         *   - extend union Name Directives[Const]? UnionMemberTypes
         *   - extend union Name Directives[Const]
         */
        parseUnionTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("union");
          const name2 = this.parseName();
          const directives = this.parseConstDirectives();
          const types = this.parseUnionMemberTypes();
          if (directives.length === 0 && types.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: Kind.UNION_TYPE_EXTENSION,
            name: name2,
            directives,
            types
          });
        }
        /**
         * EnumTypeExtension :
         *   - extend enum Name Directives[Const]? EnumValuesDefinition
         *   - extend enum Name Directives[Const]
         */
        parseEnumTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("enum");
          const name2 = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          if (directives.length === 0 && values.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: Kind.ENUM_TYPE_EXTENSION,
            name: name2,
            directives,
            values
          });
        }
        /**
         * InputObjectTypeExtension :
         *   - extend input Name Directives[Const]? InputFieldsDefinition
         *   - extend input Name Directives[Const]
         */
        parseInputObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("input");
          const name2 = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          if (directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
            name: name2,
            directives,
            fields
          });
        }
        /**
         * ```
         * DirectiveDefinition :
         *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
         * ```
         */
        parseDirectiveDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("directive");
          this.expectToken(TokenKind.AT);
          const name2 = this.parseName();
          const args = this.parseArgumentDefs();
          const repeatable = this.expectOptionalKeyword("repeatable");
          this.expectKeyword("on");
          const locations = this.parseDirectiveLocations();
          return this.node(start, {
            kind: Kind.DIRECTIVE_DEFINITION,
            description,
            name: name2,
            arguments: args,
            repeatable,
            locations
          });
        }
        /**
         * DirectiveLocations :
         *   - `|`? DirectiveLocation
         *   - DirectiveLocations | DirectiveLocation
         */
        parseDirectiveLocations() {
          return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
        }
        /*
         * DirectiveLocation :
         *   - ExecutableDirectiveLocation
         *   - TypeSystemDirectiveLocation
         *
         * ExecutableDirectiveLocation : one of
         *   `QUERY`
         *   `MUTATION`
         *   `SUBSCRIPTION`
         *   `FIELD`
         *   `FRAGMENT_DEFINITION`
         *   `FRAGMENT_SPREAD`
         *   `INLINE_FRAGMENT`
         *
         * TypeSystemDirectiveLocation : one of
         *   `SCHEMA`
         *   `SCALAR`
         *   `OBJECT`
         *   `FIELD_DEFINITION`
         *   `ARGUMENT_DEFINITION`
         *   `INTERFACE`
         *   `UNION`
         *   `ENUM`
         *   `ENUM_VALUE`
         *   `INPUT_OBJECT`
         *   `INPUT_FIELD_DEFINITION`
         */
        parseDirectiveLocation() {
          const start = this._lexer.token;
          const name2 = this.parseName();
          if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name2.value)) {
            return name2;
          }
          throw this.unexpected(start);
        }
        // Core parsing utility functions
        /**
         * Returns a node that, if configured to do so, sets a "loc" field as a
         * location object, used to identify the place in the source that created a
         * given parsed object.
         */
        node(startToken, node) {
          if (this._options.noLocation !== true) {
            node.loc = new Location(
              startToken,
              this._lexer.lastToken,
              this._lexer.source
            );
          }
          return node;
        }
        /**
         * Determines if the next token is of a given kind
         */
        peek(kind) {
          return this._lexer.token.kind === kind;
        }
        /**
         * If the next token is of the given kind, return that token after advancing the lexer.
         * Otherwise, do not change the parser state and throw an error.
         */
        expectToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this.advanceLexer();
            return token;
          }
          throw syntaxError(
            this._lexer.source,
            token.start,
            `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
          );
        }
        /**
         * If the next token is of the given kind, return "true" after advancing the lexer.
         * Otherwise, do not change the parser state and return "false".
         */
        expectOptionalToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        /**
         * If the next token is a given keyword, advance the lexer.
         * Otherwise, do not change the parser state and throw an error.
         */
        expectKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === TokenKind.NAME && token.value === value) {
            this.advanceLexer();
          } else {
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Expected "${value}", found ${getTokenDesc(token)}.`
            );
          }
        }
        /**
         * If the next token is a given keyword, return "true" after advancing the lexer.
         * Otherwise, do not change the parser state and return "false".
         */
        expectOptionalKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === TokenKind.NAME && token.value === value) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        /**
         * Helper function for creating an error when an unexpected lexed token is encountered.
         */
        unexpected(atToken) {
          const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
          return syntaxError(
            this._lexer.source,
            token.start,
            `Unexpected ${getTokenDesc(token)}.`
          );
        }
        /**
         * Returns a possibly empty list of parse nodes, determined by the parseFn.
         * This list begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        any(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          while (!this.expectOptionalToken(closeKind)) {
            nodes.push(parseFn.call(this));
          }
          return nodes;
        }
        /**
         * Returns a list of parse nodes, determined by the parseFn.
         * It can be empty only if open token is missing otherwise it will always return non-empty list
         * that begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        optionalMany(openKind, parseFn, closeKind) {
          if (this.expectOptionalToken(openKind)) {
            const nodes = [];
            do {
              nodes.push(parseFn.call(this));
            } while (!this.expectOptionalToken(closeKind));
            return nodes;
          }
          return [];
        }
        /**
         * Returns a non-empty list of parse nodes, determined by the parseFn.
         * This list begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        many(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        /**
         * Returns a non-empty list of parse nodes, determined by the parseFn.
         * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
         * Advances the parser to the next lex token after last item in the list.
         */
        delimitedMany(delimiterKind, parseFn) {
          this.expectOptionalToken(delimiterKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (this.expectOptionalToken(delimiterKind));
          return nodes;
        }
        advanceLexer() {
          const { maxTokens } = this._options;
          const token = this._lexer.advance();
          if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
            ++this._tokenCounter;
            if (this._tokenCounter > maxTokens) {
              throw syntaxError(
                this._lexer.source,
                token.start,
                `Document contains more that ${maxTokens} tokens. Parsing aborted.`
              );
            }
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/didYouMean.mjs
  function didYouMean(firstArg, secondArg) {
    const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
    let message = " Did you mean ";
    if (subMessage) {
      message += subMessage + " ";
    }
    const suggestions = suggestionsArg.map((x) => `"${x}"`);
    switch (suggestions.length) {
      case 0:
        return "";
      case 1:
        return message + suggestions[0] + "?";
      case 2:
        return message + suggestions[0] + " or " + suggestions[1] + "?";
    }
    const selected = suggestions.slice(0, MAX_SUGGESTIONS);
    const lastItem = selected.pop();
    return message + selected.join(", ") + ", or " + lastItem + "?";
  }
  var MAX_SUGGESTIONS;
  var init_didYouMean = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/didYouMean.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      MAX_SUGGESTIONS = 5;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/identityFunc.mjs
  function identityFunc(x) {
    return x;
  }
  var init_identityFunc = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/identityFunc.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/keyMap.mjs
  function keyMap(list, keyFn) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const item of list) {
      result[keyFn(item)] = item;
    }
    return result;
  }
  var init_keyMap = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/keyMap.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/keyValMap.mjs
  function keyValMap(list, keyFn, valFn) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const item of list) {
      result[keyFn(item)] = valFn(item);
    }
    return result;
  }
  var init_keyValMap = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/keyValMap.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/mapValue.mjs
  function mapValue(map, fn) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const key of Object.keys(map)) {
      result[key] = fn(map[key], key);
    }
    return result;
  }
  var init_mapValue = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/mapValue.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/naturalCompare.mjs
  function naturalCompare(aStr, bStr) {
    let aIndex = 0;
    let bIndex = 0;
    while (aIndex < aStr.length && bIndex < bStr.length) {
      let aChar = aStr.charCodeAt(aIndex);
      let bChar = bStr.charCodeAt(bIndex);
      if (isDigit2(aChar) && isDigit2(bChar)) {
        let aNum = 0;
        do {
          ++aIndex;
          aNum = aNum * 10 + aChar - DIGIT_0;
          aChar = aStr.charCodeAt(aIndex);
        } while (isDigit2(aChar) && aNum > 0);
        let bNum = 0;
        do {
          ++bIndex;
          bNum = bNum * 10 + bChar - DIGIT_0;
          bChar = bStr.charCodeAt(bIndex);
        } while (isDigit2(bChar) && bNum > 0);
        if (aNum < bNum) {
          return -1;
        }
        if (aNum > bNum) {
          return 1;
        }
      } else {
        if (aChar < bChar) {
          return -1;
        }
        if (aChar > bChar) {
          return 1;
        }
        ++aIndex;
        ++bIndex;
      }
    }
    return aStr.length - bStr.length;
  }
  function isDigit2(code) {
    return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
  }
  var DIGIT_0, DIGIT_9;
  var init_naturalCompare = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/naturalCompare.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      DIGIT_0 = 48;
      DIGIT_9 = 57;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/suggestionList.mjs
  function suggestionList(input, options) {
    const optionsByDistance = /* @__PURE__ */ Object.create(null);
    const lexicalDistance = new LexicalDistance(input);
    const threshold = Math.floor(input.length * 0.4) + 1;
    for (const option of options) {
      const distance = lexicalDistance.measure(option, threshold);
      if (distance !== void 0) {
        optionsByDistance[option] = distance;
      }
    }
    return Object.keys(optionsByDistance).sort((a2, b) => {
      const distanceDiff = optionsByDistance[a2] - optionsByDistance[b];
      return distanceDiff !== 0 ? distanceDiff : naturalCompare(a2, b);
    });
  }
  function stringToArray(str) {
    const strLength = str.length;
    const array = new Array(strLength);
    for (let i2 = 0; i2 < strLength; ++i2) {
      array[i2] = str.charCodeAt(i2);
    }
    return array;
  }
  var LexicalDistance;
  var init_suggestionList = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/suggestionList.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_naturalCompare();
      LexicalDistance = class {
        constructor(input) {
          this._input = input;
          this._inputLowerCase = input.toLowerCase();
          this._inputArray = stringToArray(this._inputLowerCase);
          this._rows = [
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0)
          ];
        }
        measure(option, threshold) {
          if (this._input === option) {
            return 0;
          }
          const optionLowerCase = option.toLowerCase();
          if (this._inputLowerCase === optionLowerCase) {
            return 1;
          }
          let a2 = stringToArray(optionLowerCase);
          let b = this._inputArray;
          if (a2.length < b.length) {
            const tmp = a2;
            a2 = b;
            b = tmp;
          }
          const aLength = a2.length;
          const bLength = b.length;
          if (aLength - bLength > threshold) {
            return void 0;
          }
          const rows = this._rows;
          for (let j = 0; j <= bLength; j++) {
            rows[0][j] = j;
          }
          for (let i2 = 1; i2 <= aLength; i2++) {
            const upRow = rows[(i2 - 1) % 3];
            const currentRow = rows[i2 % 3];
            let smallestCell = currentRow[0] = i2;
            for (let j = 1; j <= bLength; j++) {
              const cost = a2[i2 - 1] === b[j - 1] ? 0 : 1;
              let currentCell = Math.min(
                upRow[j] + 1,
                // delete
                currentRow[j - 1] + 1,
                // insert
                upRow[j - 1] + cost
                // substitute
              );
              if (i2 > 1 && j > 1 && a2[i2 - 1] === b[j - 2] && a2[i2 - 2] === b[j - 1]) {
                const doubleDiagonalCell = rows[(i2 - 2) % 3][j - 2];
                currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
              }
              if (currentCell < smallestCell) {
                smallestCell = currentCell;
              }
              currentRow[j] = currentCell;
            }
            if (smallestCell > threshold) {
              return void 0;
            }
          }
          const distance = rows[aLength % 3][bLength];
          return distance <= threshold ? distance : void 0;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/toObjMap.mjs
  function toObjMap(obj) {
    if (obj == null) {
      return /* @__PURE__ */ Object.create(null);
    }
    if (Object.getPrototypeOf(obj) === null) {
      return obj;
    }
    const map = /* @__PURE__ */ Object.create(null);
    for (const [key, value] of Object.entries(obj)) {
      map[key] = value;
    }
    return map;
  }
  var init_toObjMap = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/toObjMap.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printString.mjs
  function printString(str) {
    return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
  }
  function escapedReplacer(str) {
    return escapeSequences[str.charCodeAt(0)];
  }
  var escapedRegExp, escapeSequences;
  var init_printString = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printString.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
      escapeSequences = [
        "\\u0000",
        "\\u0001",
        "\\u0002",
        "\\u0003",
        "\\u0004",
        "\\u0005",
        "\\u0006",
        "\\u0007",
        "\\b",
        "\\t",
        "\\n",
        "\\u000B",
        "\\f",
        "\\r",
        "\\u000E",
        "\\u000F",
        "\\u0010",
        "\\u0011",
        "\\u0012",
        "\\u0013",
        "\\u0014",
        "\\u0015",
        "\\u0016",
        "\\u0017",
        "\\u0018",
        "\\u0019",
        "\\u001A",
        "\\u001B",
        "\\u001C",
        "\\u001D",
        "\\u001E",
        "\\u001F",
        "",
        "",
        '\\"',
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 2F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 3F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 4F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\\\",
        "",
        "",
        "",
        // 5F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 6F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\u007F",
        "\\u0080",
        "\\u0081",
        "\\u0082",
        "\\u0083",
        "\\u0084",
        "\\u0085",
        "\\u0086",
        "\\u0087",
        "\\u0088",
        "\\u0089",
        "\\u008A",
        "\\u008B",
        "\\u008C",
        "\\u008D",
        "\\u008E",
        "\\u008F",
        "\\u0090",
        "\\u0091",
        "\\u0092",
        "\\u0093",
        "\\u0094",
        "\\u0095",
        "\\u0096",
        "\\u0097",
        "\\u0098",
        "\\u0099",
        "\\u009A",
        "\\u009B",
        "\\u009C",
        "\\u009D",
        "\\u009E",
        "\\u009F"
      ];
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/visitor.mjs
  function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
    const enterLeaveMap = /* @__PURE__ */ new Map();
    for (const kind of Object.values(Kind)) {
      enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
    }
    let stack = void 0;
    let inArray = Array.isArray(root);
    let keys = [root];
    let index = -1;
    let edits = [];
    let node = root;
    let key = void 0;
    let parent = void 0;
    const path = [];
    const ancestors = [];
    do {
      index++;
      const isLeaving = index === keys.length;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? void 0 : path[path.length - 1];
        node = parent;
        parent = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            node = node.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === null) {
                node.splice(arrayKey, 1);
                editOffset++;
              } else {
                node[arrayKey] = editValue;
              }
            }
          } else {
            node = Object.defineProperties(
              {},
              Object.getOwnPropertyDescriptors(node)
            );
            for (const [editKey, editValue] of edits) {
              node[editKey] = editValue;
            }
          }
        }
        index = stack.index;
        keys = stack.keys;
        edits = stack.edits;
        inArray = stack.inArray;
        stack = stack.prev;
      } else if (parent) {
        key = inArray ? index : keys[index];
        node = parent[key];
        if (node === null || node === void 0) {
          continue;
        }
        path.push(key);
      }
      let result;
      if (!Array.isArray(node)) {
        var _enterLeaveMap$get, _enterLeaveMap$get2;
        isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
        const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
        result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
      if (result === void 0 && isEdited) {
        edits.push([key, node]);
      }
      if (isLeaving) {
        path.pop();
      } else {
        var _node$kind;
        stack = {
          inArray,
          index,
          keys,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node);
        keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
        index = -1;
        edits = [];
        if (parent) {
          ancestors.push(parent);
        }
        parent = node;
      }
    } while (stack !== void 0);
    if (edits.length !== 0) {
      return edits[edits.length - 1][1];
    }
    return root;
  }
  function visitInParallel(visitors) {
    const skipping = new Array(visitors.length).fill(null);
    const mergedVisitor = /* @__PURE__ */ Object.create(null);
    for (const kind of Object.values(Kind)) {
      let hasVisitor = false;
      const enterList = new Array(visitors.length).fill(void 0);
      const leaveList = new Array(visitors.length).fill(void 0);
      for (let i2 = 0; i2 < visitors.length; ++i2) {
        const { enter, leave } = getEnterLeaveForKind(visitors[i2], kind);
        hasVisitor || (hasVisitor = enter != null || leave != null);
        enterList[i2] = enter;
        leaveList[i2] = leave;
      }
      if (!hasVisitor) {
        continue;
      }
      const mergedEnterLeave = {
        enter(...args) {
          const node = args[0];
          for (let i2 = 0; i2 < visitors.length; i2++) {
            if (skipping[i2] === null) {
              var _enterList$i;
              const result = (_enterList$i = enterList[i2]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i2], args);
              if (result === false) {
                skipping[i2] = node;
              } else if (result === BREAK) {
                skipping[i2] = BREAK;
              } else if (result !== void 0) {
                return result;
              }
            }
          }
        },
        leave(...args) {
          const node = args[0];
          for (let i2 = 0; i2 < visitors.length; i2++) {
            if (skipping[i2] === null) {
              var _leaveList$i;
              const result = (_leaveList$i = leaveList[i2]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i2], args);
              if (result === BREAK) {
                skipping[i2] = BREAK;
              } else if (result !== void 0 && result !== false) {
                return result;
              }
            } else if (skipping[i2] === node) {
              skipping[i2] = null;
            }
          }
        }
      };
      mergedVisitor[kind] = mergedEnterLeave;
    }
    return mergedVisitor;
  }
  function getEnterLeaveForKind(visitor, kind) {
    const kindVisitor = visitor[kind];
    if (typeof kindVisitor === "object") {
      return kindVisitor;
    } else if (typeof kindVisitor === "function") {
      return {
        enter: kindVisitor,
        leave: void 0
      };
    }
    return {
      enter: visitor.enter,
      leave: visitor.leave
    };
  }
  function getVisitFn(visitor, kind, isLeaving) {
    const { enter, leave } = getEnterLeaveForKind(visitor, kind);
    return isLeaving ? leave : enter;
  }
  var BREAK;
  var init_visitor = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/visitor.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_inspect();
      init_ast();
      init_kinds();
      BREAK = Object.freeze({});
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printer.mjs
  function print(ast) {
    return visit(ast, printDocASTReducer);
  }
  function join(maybeArray, separator = "") {
    var _maybeArray$filter$jo;
    return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
  }
  function block(array) {
    return wrap("{\n", indent(join(array, "\n")), "\n}");
  }
  function wrap(start, maybeString, end = "") {
    return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
  }
  function indent(str) {
    return wrap("  ", str.replace(/\n/g, "\n  "));
  }
  function hasMultilineItems(maybeArray) {
    var _maybeArray$some;
    return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
  }
  var MAX_LINE_LENGTH, printDocASTReducer;
  var init_printer = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printer.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_blockString();
      init_printString();
      init_visitor();
      MAX_LINE_LENGTH = 80;
      printDocASTReducer = {
        Name: {
          leave: (node) => node.value
        },
        Variable: {
          leave: (node) => "$" + node.name
        },
        // Document
        Document: {
          leave: (node) => join(node.definitions, "\n\n")
        },
        OperationDefinition: {
          leave(node) {
            const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
            const prefix = join(
              [
                node.operation,
                join([node.name, varDefs]),
                join(node.directives, " ")
              ],
              " "
            );
            return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
          }
        },
        VariableDefinition: {
          leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
        },
        SelectionSet: {
          leave: ({ selections }) => block(selections)
        },
        Field: {
          leave({ alias, name: name2, arguments: args, directives, selectionSet }) {
            const prefix = wrap("", alias, ": ") + name2;
            let argsLine = prefix + wrap("(", join(args, ", "), ")");
            if (argsLine.length > MAX_LINE_LENGTH) {
              argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
            }
            return join([argsLine, join(directives, " "), selectionSet], " ");
          }
        },
        Argument: {
          leave: ({ name: name2, value }) => name2 + ": " + value
        },
        // Fragments
        FragmentSpread: {
          leave: ({ name: name2, directives }) => "..." + name2 + wrap(" ", join(directives, " "))
        },
        InlineFragment: {
          leave: ({ typeCondition, directives, selectionSet }) => join(
            [
              "...",
              wrap("on ", typeCondition),
              join(directives, " "),
              selectionSet
            ],
            " "
          )
        },
        FragmentDefinition: {
          leave: ({ name: name2, typeCondition, variableDefinitions, directives, selectionSet }) => (
            // or removed in the future.
            `fragment ${name2}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
          )
        },
        // Value
        IntValue: {
          leave: ({ value }) => value
        },
        FloatValue: {
          leave: ({ value }) => value
        },
        StringValue: {
          leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
        },
        BooleanValue: {
          leave: ({ value }) => value ? "true" : "false"
        },
        NullValue: {
          leave: () => "null"
        },
        EnumValue: {
          leave: ({ value }) => value
        },
        ListValue: {
          leave: ({ values }) => "[" + join(values, ", ") + "]"
        },
        ObjectValue: {
          leave: ({ fields }) => "{" + join(fields, ", ") + "}"
        },
        ObjectField: {
          leave: ({ name: name2, value }) => name2 + ": " + value
        },
        // Directive
        Directive: {
          leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap("(", join(args, ", "), ")")
        },
        // Type
        NamedType: {
          leave: ({ name: name2 }) => name2
        },
        ListType: {
          leave: ({ type }) => "[" + type + "]"
        },
        NonNullType: {
          leave: ({ type }) => type + "!"
        },
        // Type System Definitions
        SchemaDefinition: {
          leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
        },
        OperationTypeDefinition: {
          leave: ({ operation, type }) => operation + ": " + type
        },
        ScalarTypeDefinition: {
          leave: ({ description, name: name2, directives }) => wrap("", description, "\n") + join(["scalar", name2, join(directives, " ")], " ")
        },
        ObjectTypeDefinition: {
          leave: ({ description, name: name2, interfaces, directives, fields }) => wrap("", description, "\n") + join(
            [
              "type",
              name2,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        FieldDefinition: {
          leave: ({ description, name: name2, arguments: args, type, directives }) => wrap("", description, "\n") + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
        },
        InputValueDefinition: {
          leave: ({ description, name: name2, type, defaultValue, directives }) => wrap("", description, "\n") + join(
            [name2 + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
            " "
          )
        },
        InterfaceTypeDefinition: {
          leave: ({ description, name: name2, interfaces, directives, fields }) => wrap("", description, "\n") + join(
            [
              "interface",
              name2,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        UnionTypeDefinition: {
          leave: ({ description, name: name2, directives, types }) => wrap("", description, "\n") + join(
            ["union", name2, join(directives, " "), wrap("= ", join(types, " | "))],
            " "
          )
        },
        EnumTypeDefinition: {
          leave: ({ description, name: name2, directives, values }) => wrap("", description, "\n") + join(["enum", name2, join(directives, " "), block(values)], " ")
        },
        EnumValueDefinition: {
          leave: ({ description, name: name2, directives }) => wrap("", description, "\n") + join([name2, join(directives, " ")], " ")
        },
        InputObjectTypeDefinition: {
          leave: ({ description, name: name2, directives, fields }) => wrap("", description, "\n") + join(["input", name2, join(directives, " "), block(fields)], " ")
        },
        DirectiveDefinition: {
          leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
        },
        SchemaExtension: {
          leave: ({ directives, operationTypes }) => join(
            ["extend schema", join(directives, " "), block(operationTypes)],
            " "
          )
        },
        ScalarTypeExtension: {
          leave: ({ name: name2, directives }) => join(["extend scalar", name2, join(directives, " ")], " ")
        },
        ObjectTypeExtension: {
          leave: ({ name: name2, interfaces, directives, fields }) => join(
            [
              "extend type",
              name2,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        InterfaceTypeExtension: {
          leave: ({ name: name2, interfaces, directives, fields }) => join(
            [
              "extend interface",
              name2,
              wrap("implements ", join(interfaces, " & ")),
              join(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        UnionTypeExtension: {
          leave: ({ name: name2, directives, types }) => join(
            [
              "extend union",
              name2,
              join(directives, " "),
              wrap("= ", join(types, " | "))
            ],
            " "
          )
        },
        EnumTypeExtension: {
          leave: ({ name: name2, directives, values }) => join(["extend enum", name2, join(directives, " "), block(values)], " ")
        },
        InputObjectTypeExtension: {
          leave: ({ name: name2, directives, fields }) => join(["extend input", name2, join(directives, " "), block(fields)], " ")
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/valueFromASTUntyped.mjs
  function valueFromASTUntyped(valueNode, variables) {
    switch (valueNode.kind) {
      case Kind.NULL:
        return null;
      case Kind.INT:
        return parseInt(valueNode.value, 10);
      case Kind.FLOAT:
        return parseFloat(valueNode.value);
      case Kind.STRING:
      case Kind.ENUM:
      case Kind.BOOLEAN:
        return valueNode.value;
      case Kind.LIST:
        return valueNode.values.map(
          (node) => valueFromASTUntyped(node, variables)
        );
      case Kind.OBJECT:
        return keyValMap(
          valueNode.fields,
          (field) => field.name.value,
          (field) => valueFromASTUntyped(field.value, variables)
        );
      case Kind.VARIABLE:
        return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
    }
  }
  var init_valueFromASTUntyped = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/valueFromASTUntyped.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_keyValMap();
      init_kinds();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/assertName.mjs
  function assertName(name2) {
    name2 != null || devAssert(false, "Must provide name.");
    typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
    if (name2.length === 0) {
      throw new GraphQLError("Expected name to be a non-empty string.");
    }
    for (let i2 = 1; i2 < name2.length; ++i2) {
      if (!isNameContinue(name2.charCodeAt(i2))) {
        throw new GraphQLError(
          `Names must only contain [_a-zA-Z0-9] but "${name2}" does not.`
        );
      }
    }
    if (!isNameStart(name2.charCodeAt(0))) {
      throw new GraphQLError(
        `Names must start with [_a-zA-Z] but "${name2}" does not.`
      );
    }
    return name2;
  }
  function assertEnumValueName(name2) {
    if (name2 === "true" || name2 === "false" || name2 === "null") {
      throw new GraphQLError(`Enum values cannot be named: ${name2}`);
    }
    return assertName(name2);
  }
  var init_assertName = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/assertName.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_GraphQLError();
      init_characterClasses();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/definition.mjs
  function isType(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
  }
  function assertType(type) {
    if (!isType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL type.`);
    }
    return type;
  }
  function isScalarType(type) {
    return instanceOf(type, GraphQLScalarType);
  }
  function assertScalarType(type) {
    if (!isScalarType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL Scalar type.`);
    }
    return type;
  }
  function isObjectType(type) {
    return instanceOf(type, GraphQLObjectType);
  }
  function assertObjectType(type) {
    if (!isObjectType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL Object type.`);
    }
    return type;
  }
  function isInterfaceType(type) {
    return instanceOf(type, GraphQLInterfaceType);
  }
  function assertInterfaceType(type) {
    if (!isInterfaceType(type)) {
      throw new Error(
        `Expected ${inspect(type)} to be a GraphQL Interface type.`
      );
    }
    return type;
  }
  function isUnionType(type) {
    return instanceOf(type, GraphQLUnionType);
  }
  function assertUnionType(type) {
    if (!isUnionType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL Union type.`);
    }
    return type;
  }
  function isEnumType(type) {
    return instanceOf(type, GraphQLEnumType);
  }
  function assertEnumType(type) {
    if (!isEnumType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL Enum type.`);
    }
    return type;
  }
  function isInputObjectType(type) {
    return instanceOf(type, GraphQLInputObjectType);
  }
  function assertInputObjectType(type) {
    if (!isInputObjectType(type)) {
      throw new Error(
        `Expected ${inspect(type)} to be a GraphQL Input Object type.`
      );
    }
    return type;
  }
  function isListType(type) {
    return instanceOf(type, GraphQLList);
  }
  function assertListType(type) {
    if (!isListType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL List type.`);
    }
    return type;
  }
  function isNonNullType(type) {
    return instanceOf(type, GraphQLNonNull);
  }
  function assertNonNullType(type) {
    if (!isNonNullType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL Non-Null type.`);
    }
    return type;
  }
  function isInputType(type) {
    return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
  }
  function assertInputType(type) {
    if (!isInputType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL input type.`);
    }
    return type;
  }
  function isOutputType(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
  }
  function assertOutputType(type) {
    if (!isOutputType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL output type.`);
    }
    return type;
  }
  function isLeafType(type) {
    return isScalarType(type) || isEnumType(type);
  }
  function assertLeafType(type) {
    if (!isLeafType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL leaf type.`);
    }
    return type;
  }
  function isCompositeType(type) {
    return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
  }
  function assertCompositeType(type) {
    if (!isCompositeType(type)) {
      throw new Error(
        `Expected ${inspect(type)} to be a GraphQL composite type.`
      );
    }
    return type;
  }
  function isAbstractType(type) {
    return isInterfaceType(type) || isUnionType(type);
  }
  function assertAbstractType(type) {
    if (!isAbstractType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL abstract type.`);
    }
    return type;
  }
  function isWrappingType(type) {
    return isListType(type) || isNonNullType(type);
  }
  function assertWrappingType(type) {
    if (!isWrappingType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL wrapping type.`);
    }
    return type;
  }
  function isNullableType(type) {
    return isType(type) && !isNonNullType(type);
  }
  function assertNullableType(type) {
    if (!isNullableType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL nullable type.`);
    }
    return type;
  }
  function getNullableType(type) {
    if (type) {
      return isNonNullType(type) ? type.ofType : type;
    }
  }
  function isNamedType(type) {
    return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
  }
  function assertNamedType(type) {
    if (!isNamedType(type)) {
      throw new Error(`Expected ${inspect(type)} to be a GraphQL named type.`);
    }
    return type;
  }
  function getNamedType(type) {
    if (type) {
      let unwrappedType = type;
      while (isWrappingType(unwrappedType)) {
        unwrappedType = unwrappedType.ofType;
      }
      return unwrappedType;
    }
  }
  function resolveReadonlyArrayThunk(thunk) {
    return typeof thunk === "function" ? thunk() : thunk;
  }
  function resolveObjMapThunk(thunk) {
    return typeof thunk === "function" ? thunk() : thunk;
  }
  function defineInterfaces(config2) {
    var _config$interfaces;
    const interfaces = resolveReadonlyArrayThunk(
      (_config$interfaces = config2.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
    );
    Array.isArray(interfaces) || devAssert(
      false,
      `${config2.name} interfaces must be an Array or a function which returns an Array.`
    );
    return interfaces;
  }
  function defineFieldMap(config2) {
    const fieldMap = resolveObjMapThunk(config2.fields);
    isPlainObj(fieldMap) || devAssert(
      false,
      `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
    );
    return mapValue(fieldMap, (fieldConfig, fieldName) => {
      var _fieldConfig$args;
      isPlainObj(fieldConfig) || devAssert(
        false,
        `${config2.name}.${fieldName} field config must be an object.`
      );
      fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
        false,
        `${config2.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
      );
      const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
      isPlainObj(argsConfig) || devAssert(
        false,
        `${config2.name}.${fieldName} args must be an object with argument names as keys.`
      );
      return {
        name: assertName(fieldName),
        description: fieldConfig.description,
        type: fieldConfig.type,
        args: defineArguments(argsConfig),
        resolve: fieldConfig.resolve,
        subscribe: fieldConfig.subscribe,
        deprecationReason: fieldConfig.deprecationReason,
        extensions: toObjMap(fieldConfig.extensions),
        astNode: fieldConfig.astNode
      };
    });
  }
  function defineArguments(config2) {
    return Object.entries(config2).map(([argName, argConfig]) => ({
      name: assertName(argName),
      description: argConfig.description,
      type: argConfig.type,
      defaultValue: argConfig.defaultValue,
      deprecationReason: argConfig.deprecationReason,
      extensions: toObjMap(argConfig.extensions),
      astNode: argConfig.astNode
    }));
  }
  function isPlainObj(obj) {
    return isObjectLike(obj) && !Array.isArray(obj);
  }
  function fieldsToFieldsConfig(fields) {
    return mapValue(fields, (field) => ({
      description: field.description,
      type: field.type,
      args: argsToArgsConfig(field.args),
      resolve: field.resolve,
      subscribe: field.subscribe,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
  }
  function argsToArgsConfig(args) {
    return keyValMap(
      args,
      (arg) => arg.name,
      (arg) => ({
        description: arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        deprecationReason: arg.deprecationReason,
        extensions: arg.extensions,
        astNode: arg.astNode
      })
    );
  }
  function isRequiredArgument(arg) {
    return isNonNullType(arg.type) && arg.defaultValue === void 0;
  }
  function defineTypes(config2) {
    const types = resolveReadonlyArrayThunk(config2.types);
    Array.isArray(types) || devAssert(
      false,
      `Must provide Array of types or a function which returns such an array for Union ${config2.name}.`
    );
    return types;
  }
  function didYouMeanEnumValue(enumType, unknownValueStr) {
    const allNames = enumType.getValues().map((value) => value.name);
    const suggestedValues = suggestionList(unknownValueStr, allNames);
    return didYouMean("the enum value", suggestedValues);
  }
  function defineEnumValues(typeName, valueMap) {
    isPlainObj(valueMap) || devAssert(
      false,
      `${typeName} values must be an object with value names as keys.`
    );
    return Object.entries(valueMap).map(([valueName, valueConfig]) => {
      isPlainObj(valueConfig) || devAssert(
        false,
        `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
      );
      return {
        name: assertEnumValueName(valueName),
        description: valueConfig.description,
        value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
        deprecationReason: valueConfig.deprecationReason,
        extensions: toObjMap(valueConfig.extensions),
        astNode: valueConfig.astNode
      };
    });
  }
  function defineInputFieldMap(config2) {
    const fieldMap = resolveObjMapThunk(config2.fields);
    isPlainObj(fieldMap) || devAssert(
      false,
      `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
    );
    return mapValue(fieldMap, (fieldConfig, fieldName) => {
      !("resolve" in fieldConfig) || devAssert(
        false,
        `${config2.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
      );
      return {
        name: assertName(fieldName),
        description: fieldConfig.description,
        type: fieldConfig.type,
        defaultValue: fieldConfig.defaultValue,
        deprecationReason: fieldConfig.deprecationReason,
        extensions: toObjMap(fieldConfig.extensions),
        astNode: fieldConfig.astNode
      };
    });
  }
  function isRequiredInputField(field) {
    return isNonNullType(field.type) && field.defaultValue === void 0;
  }
  var GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType;
  var init_definition = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/definition.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_didYouMean();
      init_identityFunc();
      init_inspect();
      init_instanceOf();
      init_isObjectLike();
      init_keyMap();
      init_keyValMap();
      init_mapValue();
      init_suggestionList();
      init_toObjMap();
      init_GraphQLError();
      init_kinds();
      init_printer();
      init_valueFromASTUntyped();
      init_assertName();
      GraphQLList = class {
        constructor(ofType) {
          isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLList";
        }
        toString() {
          return "[" + String(this.ofType) + "]";
        }
        toJSON() {
          return this.toString();
        }
      };
      GraphQLNonNull = class {
        constructor(ofType) {
          isNullableType(ofType) || devAssert(
            false,
            `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
          );
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLNonNull";
        }
        toString() {
          return String(this.ofType) + "!";
        }
        toJSON() {
          return this.toString();
        }
      };
      GraphQLScalarType = class {
        constructor(config2) {
          var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
          const parseValue2 = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
          this.name = assertName(config2.name);
          this.description = config2.description;
          this.specifiedByURL = config2.specifiedByURL;
          this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
          this.parseValue = parseValue2;
          this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
          this.extensions = toObjMap(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          config2.specifiedByURL == null || typeof config2.specifiedByURL === "string" || devAssert(
            false,
            `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config2.specifiedByURL)}.`
          );
          config2.serialize == null || typeof config2.serialize === "function" || devAssert(
            false,
            `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
          );
          if (config2.parseLiteral) {
            typeof config2.parseValue === "function" && typeof config2.parseLiteral === "function" || devAssert(
              false,
              `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
            );
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLScalarType";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            specifiedByURL: this.specifiedByURL,
            serialize: this.serialize,
            parseValue: this.parseValue,
            parseLiteral: this.parseLiteral,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      GraphQLObjectType = class {
        constructor(config2) {
          var _config$extensionASTN2;
          this.name = assertName(config2.name);
          this.description = config2.description;
          this.isTypeOf = config2.isTypeOf;
          this.extensions = toObjMap(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN2 = config2.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
          this._fields = () => defineFieldMap(config2);
          this._interfaces = () => defineInterfaces(config2);
          config2.isTypeOf == null || typeof config2.isTypeOf === "function" || devAssert(
            false,
            `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config2.isTypeOf)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            isTypeOf: this.isTypeOf,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      GraphQLInterfaceType = class {
        constructor(config2) {
          var _config$extensionASTN3;
          this.name = assertName(config2.name);
          this.description = config2.description;
          this.resolveType = config2.resolveType;
          this.extensions = toObjMap(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN3 = config2.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
          this._fields = defineFieldMap.bind(void 0, config2);
          this._interfaces = defineInterfaces.bind(void 0, config2);
          config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(
            false,
            `${this.name} must provide "resolveType" as a function, but got: ${inspect(config2.resolveType)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInterfaceType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig(this.getFields()),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      GraphQLUnionType = class {
        constructor(config2) {
          var _config$extensionASTN4;
          this.name = assertName(config2.name);
          this.description = config2.description;
          this.resolveType = config2.resolveType;
          this.extensions = toObjMap(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN4 = config2.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
          this._types = defineTypes.bind(void 0, config2);
          config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(
            false,
            `${this.name} must provide "resolveType" as a function, but got: ${inspect(config2.resolveType)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLUnionType";
        }
        getTypes() {
          if (typeof this._types === "function") {
            this._types = this._types();
          }
          return this._types;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            types: this.getTypes(),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      GraphQLEnumType = class {
        /* <T> */
        constructor(config2) {
          var _config$extensionASTN5;
          this.name = assertName(config2.name);
          this.description = config2.description;
          this.extensions = toObjMap(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN5 = config2.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
          this._values = defineEnumValues(this.name, config2.values);
          this._valueLookup = new Map(
            this._values.map((enumValue) => [enumValue.value, enumValue])
          );
          this._nameLookup = keyMap(this._values, (value) => value.name);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLEnumType";
        }
        getValues() {
          return this._values;
        }
        getValue(name2) {
          return this._nameLookup[name2];
        }
        serialize(outputValue) {
          const enumValue = this._valueLookup.get(outputValue);
          if (enumValue === void 0) {
            throw new GraphQLError(
              `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
            );
          }
          return enumValue.name;
        }
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            const valueStr = inspect(inputValue);
            throw new GraphQLError(
              `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
            );
          }
          const enumValue = this.getValue(inputValue);
          if (enumValue == null) {
            throw new GraphQLError(
              `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
            );
          }
          return enumValue.value;
        }
        parseLiteral(valueNode, _variables) {
          if (valueNode.kind !== Kind.ENUM) {
            const valueStr = print(valueNode);
            throw new GraphQLError(
              `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
              {
                nodes: valueNode
              }
            );
          }
          const enumValue = this.getValue(valueNode.value);
          if (enumValue == null) {
            const valueStr = print(valueNode);
            throw new GraphQLError(
              `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
              {
                nodes: valueNode
              }
            );
          }
          return enumValue.value;
        }
        toConfig() {
          const values = keyValMap(
            this.getValues(),
            (value) => value.name,
            (value) => ({
              description: value.description,
              value: value.value,
              deprecationReason: value.deprecationReason,
              extensions: value.extensions,
              astNode: value.astNode
            })
          );
          return {
            name: this.name,
            description: this.description,
            values,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      GraphQLInputObjectType = class {
        constructor(config2) {
          var _config$extensionASTN6;
          this.name = assertName(config2.name);
          this.description = config2.description;
          this.extensions = toObjMap(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN6 = config2.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
          this._fields = defineInputFieldMap.bind(void 0, config2);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInputObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        toConfig() {
          const fields = mapValue(this.getFields(), (field) => ({
            description: field.description,
            type: field.type,
            defaultValue: field.defaultValue,
            deprecationReason: field.deprecationReason,
            extensions: field.extensions,
            astNode: field.astNode
          }));
          return {
            name: this.name,
            description: this.description,
            fields,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/typeComparators.mjs
  function isEqualType(typeA, typeB) {
    if (typeA === typeB) {
      return true;
    }
    if (isNonNullType(typeA) && isNonNullType(typeB)) {
      return isEqualType(typeA.ofType, typeB.ofType);
    }
    if (isListType(typeA) && isListType(typeB)) {
      return isEqualType(typeA.ofType, typeB.ofType);
    }
    return false;
  }
  function isTypeSubTypeOf(schema, maybeSubType, superType) {
    if (maybeSubType === superType) {
      return true;
    }
    if (isNonNullType(superType)) {
      if (isNonNullType(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
      }
      return false;
    }
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
    }
    if (isListType(superType)) {
      if (isListType(maybeSubType)) {
        return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
      }
      return false;
    }
    if (isListType(maybeSubType)) {
      return false;
    }
    return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
  }
  function doTypesOverlap(schema, typeA, typeB) {
    if (typeA === typeB) {
      return true;
    }
    if (isAbstractType(typeA)) {
      if (isAbstractType(typeB)) {
        return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
      }
      return schema.isSubType(typeA, typeB);
    }
    if (isAbstractType(typeB)) {
      return schema.isSubType(typeB, typeA);
    }
    return false;
  }
  var init_typeComparators = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/typeComparators.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_definition();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/scalars.mjs
  function isSpecifiedScalarType(type) {
    return specifiedScalarTypes.some(({ name: name2 }) => type.name === name2);
  }
  function serializeObject(outputValue) {
    if (isObjectLike(outputValue)) {
      if (typeof outputValue.valueOf === "function") {
        const valueOfResult = outputValue.valueOf();
        if (!isObjectLike(valueOfResult)) {
          return valueOfResult;
        }
      }
      if (typeof outputValue.toJSON === "function") {
        return outputValue.toJSON();
      }
    }
    return outputValue;
  }
  var GRAPHQL_MAX_INT, GRAPHQL_MIN_INT, GraphQLInt, GraphQLFloat, GraphQLString, GraphQLBoolean, GraphQLID, specifiedScalarTypes;
  var init_scalars = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/scalars.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_isObjectLike();
      init_GraphQLError();
      init_kinds();
      init_printer();
      init_definition();
      GRAPHQL_MAX_INT = 2147483647;
      GRAPHQL_MIN_INT = -2147483648;
      GraphQLInt = new GraphQLScalarType({
        name: "Int",
        description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isInteger(num)) {
            throw new GraphQLError(
              `Int cannot represent non-integer value: ${inspect(coercedValue)}`
            );
          }
          if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new GraphQLError(
              "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
            );
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
            throw new GraphQLError(
              `Int cannot represent non-integer value: ${inspect(inputValue)}`
            );
          }
          if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
            throw new GraphQLError(
              `Int cannot represent non 32-bit signed integer value: ${inputValue}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== Kind.INT) {
            throw new GraphQLError(
              `Int cannot represent non-integer value: ${print(valueNode)}`,
              {
                nodes: valueNode
              }
            );
          }
          const num = parseInt(valueNode.value, 10);
          if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
            throw new GraphQLError(
              `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
              {
                nodes: valueNode
              }
            );
          }
          return num;
        }
      });
      GraphQLFloat = new GraphQLScalarType({
        name: "Float",
        description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isFinite(num)) {
            throw new GraphQLError(
              `Float cannot represent non numeric value: ${inspect(coercedValue)}`
            );
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
            throw new GraphQLError(
              `Float cannot represent non numeric value: ${inspect(inputValue)}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
            throw new GraphQLError(
              `Float cannot represent non numeric value: ${print(valueNode)}`,
              valueNode
            );
          }
          return parseFloat(valueNode.value);
        }
      });
      GraphQLString = new GraphQLScalarType({
        name: "String",
        description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (typeof coercedValue === "boolean") {
            return coercedValue ? "true" : "false";
          }
          if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
            return coercedValue.toString();
          }
          throw new GraphQLError(
            `String cannot represent value: ${inspect(outputValue)}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            throw new GraphQLError(
              `String cannot represent a non string value: ${inspect(inputValue)}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== Kind.STRING) {
            throw new GraphQLError(
              `String cannot represent a non string value: ${print(valueNode)}`,
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      GraphQLBoolean = new GraphQLScalarType({
        name: "Boolean",
        description: "The `Boolean` scalar type represents `true` or `false`.",
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue;
          }
          if (Number.isFinite(coercedValue)) {
            return coercedValue !== 0;
          }
          throw new GraphQLError(
            `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "boolean") {
            throw new GraphQLError(
              `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== Kind.BOOLEAN) {
            throw new GraphQLError(
              `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      GraphQLID = new GraphQLScalarType({
        name: "ID",
        description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
        serialize(outputValue) {
          const coercedValue = serializeObject(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (Number.isInteger(coercedValue)) {
            return String(coercedValue);
          }
          throw new GraphQLError(
            `ID cannot represent value: ${inspect(outputValue)}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue === "string") {
            return inputValue;
          }
          if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
            return inputValue.toString();
          }
          throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
            throw new GraphQLError(
              "ID cannot represent a non-string and non-integer value: " + print(valueNode),
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      specifiedScalarTypes = Object.freeze([
        GraphQLString,
        GraphQLInt,
        GraphQLFloat,
        GraphQLBoolean,
        GraphQLID
      ]);
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/directives.mjs
  function isDirective(directive) {
    return instanceOf(directive, GraphQLDirective);
  }
  function assertDirective(directive) {
    if (!isDirective(directive)) {
      throw new Error(
        `Expected ${inspect(directive)} to be a GraphQL directive.`
      );
    }
    return directive;
  }
  function isSpecifiedDirective(directive) {
    return specifiedDirectives.some(({ name: name2 }) => name2 === directive.name);
  }
  var GraphQLDirective, GraphQLIncludeDirective, GraphQLSkipDirective, DEFAULT_DEPRECATION_REASON, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective, specifiedDirectives;
  var init_directives = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/directives.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_inspect();
      init_instanceOf();
      init_isObjectLike();
      init_toObjMap();
      init_directiveLocation();
      init_assertName();
      init_definition();
      init_scalars();
      GraphQLDirective = class {
        constructor(config2) {
          var _config$isRepeatable, _config$args;
          this.name = assertName(config2.name);
          this.description = config2.description;
          this.locations = config2.locations;
          this.isRepeatable = (_config$isRepeatable = config2.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
          this.extensions = toObjMap(config2.extensions);
          this.astNode = config2.astNode;
          Array.isArray(config2.locations) || devAssert(false, `@${config2.name} locations must be an Array.`);
          const args = (_config$args = config2.args) !== null && _config$args !== void 0 ? _config$args : {};
          isObjectLike(args) && !Array.isArray(args) || devAssert(
            false,
            `@${config2.name} args must be an object with argument names as keys.`
          );
          this.args = defineArguments(args);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLDirective";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            locations: this.locations,
            args: argsToArgsConfig(this.args),
            isRepeatable: this.isRepeatable,
            extensions: this.extensions,
            astNode: this.astNode
          };
        }
        toString() {
          return "@" + this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      GraphQLIncludeDirective = new GraphQLDirective({
        name: "include",
        description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
        locations: [
          DirectiveLocation.FIELD,
          DirectiveLocation.FRAGMENT_SPREAD,
          DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new GraphQLNonNull(GraphQLBoolean),
            description: "Included when true."
          }
        }
      });
      GraphQLSkipDirective = new GraphQLDirective({
        name: "skip",
        description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
        locations: [
          DirectiveLocation.FIELD,
          DirectiveLocation.FRAGMENT_SPREAD,
          DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new GraphQLNonNull(GraphQLBoolean),
            description: "Skipped when true."
          }
        }
      });
      DEFAULT_DEPRECATION_REASON = "No longer supported";
      GraphQLDeprecatedDirective = new GraphQLDirective({
        name: "deprecated",
        description: "Marks an element of a GraphQL schema as no longer supported.",
        locations: [
          DirectiveLocation.FIELD_DEFINITION,
          DirectiveLocation.ARGUMENT_DEFINITION,
          DirectiveLocation.INPUT_FIELD_DEFINITION,
          DirectiveLocation.ENUM_VALUE
        ],
        args: {
          reason: {
            type: GraphQLString,
            description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
            defaultValue: DEFAULT_DEPRECATION_REASON
          }
        }
      });
      GraphQLSpecifiedByDirective = new GraphQLDirective({
        name: "specifiedBy",
        description: "Exposes a URL that specifies the behavior of this scalar.",
        locations: [DirectiveLocation.SCALAR],
        args: {
          url: {
            type: new GraphQLNonNull(GraphQLString),
            description: "The URL that specifies the behavior of this scalar."
          }
        }
      });
      specifiedDirectives = Object.freeze([
        GraphQLIncludeDirective,
        GraphQLSkipDirective,
        GraphQLDeprecatedDirective,
        GraphQLSpecifiedByDirective
      ]);
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isIterableObject.mjs
  function isIterableObject(maybeIterable) {
    return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
  }
  var init_isIterableObject = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isIterableObject.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/astFromValue.mjs
  function astFromValue(value, type) {
    if (isNonNullType(type)) {
      const astValue = astFromValue(value, type.ofType);
      if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
        return null;
      }
      return astValue;
    }
    if (value === null) {
      return {
        kind: Kind.NULL
      };
    }
    if (value === void 0) {
      return null;
    }
    if (isListType(type)) {
      const itemType = type.ofType;
      if (isIterableObject(value)) {
        const valuesNodes = [];
        for (const item of value) {
          const itemNode = astFromValue(item, itemType);
          if (itemNode != null) {
            valuesNodes.push(itemNode);
          }
        }
        return {
          kind: Kind.LIST,
          values: valuesNodes
        };
      }
      return astFromValue(value, itemType);
    }
    if (isInputObjectType(type)) {
      if (!isObjectLike(value)) {
        return null;
      }
      const fieldNodes = [];
      for (const field of Object.values(type.getFields())) {
        const fieldValue = astFromValue(value[field.name], field.type);
        if (fieldValue) {
          fieldNodes.push({
            kind: Kind.OBJECT_FIELD,
            name: {
              kind: Kind.NAME,
              value: field.name
            },
            value: fieldValue
          });
        }
      }
      return {
        kind: Kind.OBJECT,
        fields: fieldNodes
      };
    }
    if (isLeafType(type)) {
      const serialized = type.serialize(value);
      if (serialized == null) {
        return null;
      }
      if (typeof serialized === "boolean") {
        return {
          kind: Kind.BOOLEAN,
          value: serialized
        };
      }
      if (typeof serialized === "number" && Number.isFinite(serialized)) {
        const stringNum = String(serialized);
        return integerStringRegExp.test(stringNum) ? {
          kind: Kind.INT,
          value: stringNum
        } : {
          kind: Kind.FLOAT,
          value: stringNum
        };
      }
      if (typeof serialized === "string") {
        if (isEnumType(type)) {
          return {
            kind: Kind.ENUM,
            value: serialized
          };
        }
        if (type === GraphQLID && integerStringRegExp.test(serialized)) {
          return {
            kind: Kind.INT,
            value: serialized
          };
        }
        return {
          kind: Kind.STRING,
          value: serialized
        };
      }
      throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
    }
    invariant(false, "Unexpected input type: " + inspect(type));
  }
  var integerStringRegExp;
  var init_astFromValue = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/astFromValue.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_invariant();
      init_isIterableObject();
      init_isObjectLike();
      init_kinds();
      init_definition();
      init_scalars();
      integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/introspection.mjs
  function isIntrospectionType(type) {
    return introspectionTypes.some(({ name: name2 }) => type.name === name2);
  }
  var __Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, TypeKind, __TypeKind, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, introspectionTypes;
  var init_introspection = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/introspection.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_invariant();
      init_directiveLocation();
      init_printer();
      init_astFromValue();
      init_definition();
      init_scalars();
      __Schema = new GraphQLObjectType({
        name: "__Schema",
        description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
        fields: () => ({
          description: {
            type: GraphQLString,
            resolve: (schema) => schema.description
          },
          types: {
            description: "A list of all types supported by this server.",
            type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
            resolve(schema) {
              return Object.values(schema.getTypeMap());
            }
          },
          queryType: {
            description: "The type that query operations will be rooted at.",
            type: new GraphQLNonNull(__Type),
            resolve: (schema) => schema.getQueryType()
          },
          mutationType: {
            description: "If this server supports mutation, the type that mutation operations will be rooted at.",
            type: __Type,
            resolve: (schema) => schema.getMutationType()
          },
          subscriptionType: {
            description: "If this server support subscription, the type that subscription operations will be rooted at.",
            type: __Type,
            resolve: (schema) => schema.getSubscriptionType()
          },
          directives: {
            description: "A list of all directives supported by this server.",
            type: new GraphQLNonNull(
              new GraphQLList(new GraphQLNonNull(__Directive))
            ),
            resolve: (schema) => schema.getDirectives()
          }
        })
      });
      __Directive = new GraphQLObjectType({
        name: "__Directive",
        description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
        fields: () => ({
          name: {
            type: new GraphQLNonNull(GraphQLString),
            resolve: (directive) => directive.name
          },
          description: {
            type: GraphQLString,
            resolve: (directive) => directive.description
          },
          isRepeatable: {
            type: new GraphQLNonNull(GraphQLBoolean),
            resolve: (directive) => directive.isRepeatable
          },
          locations: {
            type: new GraphQLNonNull(
              new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
            ),
            resolve: (directive) => directive.locations
          },
          args: {
            type: new GraphQLNonNull(
              new GraphQLList(new GraphQLNonNull(__InputValue))
            ),
            args: {
              includeDeprecated: {
                type: GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          }
        })
      });
      __DirectiveLocation = new GraphQLEnumType({
        name: "__DirectiveLocation",
        description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
        values: {
          QUERY: {
            value: DirectiveLocation.QUERY,
            description: "Location adjacent to a query operation."
          },
          MUTATION: {
            value: DirectiveLocation.MUTATION,
            description: "Location adjacent to a mutation operation."
          },
          SUBSCRIPTION: {
            value: DirectiveLocation.SUBSCRIPTION,
            description: "Location adjacent to a subscription operation."
          },
          FIELD: {
            value: DirectiveLocation.FIELD,
            description: "Location adjacent to a field."
          },
          FRAGMENT_DEFINITION: {
            value: DirectiveLocation.FRAGMENT_DEFINITION,
            description: "Location adjacent to a fragment definition."
          },
          FRAGMENT_SPREAD: {
            value: DirectiveLocation.FRAGMENT_SPREAD,
            description: "Location adjacent to a fragment spread."
          },
          INLINE_FRAGMENT: {
            value: DirectiveLocation.INLINE_FRAGMENT,
            description: "Location adjacent to an inline fragment."
          },
          VARIABLE_DEFINITION: {
            value: DirectiveLocation.VARIABLE_DEFINITION,
            description: "Location adjacent to a variable definition."
          },
          SCHEMA: {
            value: DirectiveLocation.SCHEMA,
            description: "Location adjacent to a schema definition."
          },
          SCALAR: {
            value: DirectiveLocation.SCALAR,
            description: "Location adjacent to a scalar definition."
          },
          OBJECT: {
            value: DirectiveLocation.OBJECT,
            description: "Location adjacent to an object type definition."
          },
          FIELD_DEFINITION: {
            value: DirectiveLocation.FIELD_DEFINITION,
            description: "Location adjacent to a field definition."
          },
          ARGUMENT_DEFINITION: {
            value: DirectiveLocation.ARGUMENT_DEFINITION,
            description: "Location adjacent to an argument definition."
          },
          INTERFACE: {
            value: DirectiveLocation.INTERFACE,
            description: "Location adjacent to an interface definition."
          },
          UNION: {
            value: DirectiveLocation.UNION,
            description: "Location adjacent to a union definition."
          },
          ENUM: {
            value: DirectiveLocation.ENUM,
            description: "Location adjacent to an enum definition."
          },
          ENUM_VALUE: {
            value: DirectiveLocation.ENUM_VALUE,
            description: "Location adjacent to an enum value definition."
          },
          INPUT_OBJECT: {
            value: DirectiveLocation.INPUT_OBJECT,
            description: "Location adjacent to an input object type definition."
          },
          INPUT_FIELD_DEFINITION: {
            value: DirectiveLocation.INPUT_FIELD_DEFINITION,
            description: "Location adjacent to an input object field definition."
          }
        }
      });
      __Type = new GraphQLObjectType({
        name: "__Type",
        description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
        fields: () => ({
          kind: {
            type: new GraphQLNonNull(__TypeKind),
            resolve(type) {
              if (isScalarType(type)) {
                return TypeKind.SCALAR;
              }
              if (isObjectType(type)) {
                return TypeKind.OBJECT;
              }
              if (isInterfaceType(type)) {
                return TypeKind.INTERFACE;
              }
              if (isUnionType(type)) {
                return TypeKind.UNION;
              }
              if (isEnumType(type)) {
                return TypeKind.ENUM;
              }
              if (isInputObjectType(type)) {
                return TypeKind.INPUT_OBJECT;
              }
              if (isListType(type)) {
                return TypeKind.LIST;
              }
              if (isNonNullType(type)) {
                return TypeKind.NON_NULL;
              }
              invariant(false, `Unexpected type: "${inspect(type)}".`);
            }
          },
          name: {
            type: GraphQLString,
            resolve: (type) => "name" in type ? type.name : void 0
          },
          description: {
            type: GraphQLString,
            resolve: (type) => (
              /* c8 ignore next */
              "description" in type ? type.description : void 0
            )
          },
          specifiedByURL: {
            type: GraphQLString,
            resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
          },
          fields: {
            type: new GraphQLList(new GraphQLNonNull(__Field)),
            args: {
              includeDeprecated: {
                type: GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if (isObjectType(type) || isInterfaceType(type)) {
                const fields = Object.values(type.getFields());
                return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
              }
            }
          },
          interfaces: {
            type: new GraphQLList(new GraphQLNonNull(__Type)),
            resolve(type) {
              if (isObjectType(type) || isInterfaceType(type)) {
                return type.getInterfaces();
              }
            }
          },
          possibleTypes: {
            type: new GraphQLList(new GraphQLNonNull(__Type)),
            resolve(type, _args, _context, { schema }) {
              if (isAbstractType(type)) {
                return schema.getPossibleTypes(type);
              }
            }
          },
          enumValues: {
            type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
            args: {
              includeDeprecated: {
                type: GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if (isEnumType(type)) {
                const values = type.getValues();
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          inputFields: {
            type: new GraphQLList(new GraphQLNonNull(__InputValue)),
            args: {
              includeDeprecated: {
                type: GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if (isInputObjectType(type)) {
                const values = Object.values(type.getFields());
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          ofType: {
            type: __Type,
            resolve: (type) => "ofType" in type ? type.ofType : void 0
          }
        })
      });
      __Field = new GraphQLObjectType({
        name: "__Field",
        description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
        fields: () => ({
          name: {
            type: new GraphQLNonNull(GraphQLString),
            resolve: (field) => field.name
          },
          description: {
            type: GraphQLString,
            resolve: (field) => field.description
          },
          args: {
            type: new GraphQLNonNull(
              new GraphQLList(new GraphQLNonNull(__InputValue))
            ),
            args: {
              includeDeprecated: {
                type: GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          },
          type: {
            type: new GraphQLNonNull(__Type),
            resolve: (field) => field.type
          },
          isDeprecated: {
            type: new GraphQLNonNull(GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: GraphQLString,
            resolve: (field) => field.deprecationReason
          }
        })
      });
      __InputValue = new GraphQLObjectType({
        name: "__InputValue",
        description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
        fields: () => ({
          name: {
            type: new GraphQLNonNull(GraphQLString),
            resolve: (inputValue) => inputValue.name
          },
          description: {
            type: GraphQLString,
            resolve: (inputValue) => inputValue.description
          },
          type: {
            type: new GraphQLNonNull(__Type),
            resolve: (inputValue) => inputValue.type
          },
          defaultValue: {
            type: GraphQLString,
            description: "A GraphQL-formatted string representing the default value for this input value.",
            resolve(inputValue) {
              const { type, defaultValue } = inputValue;
              const valueAST = astFromValue(defaultValue, type);
              return valueAST ? print(valueAST) : null;
            }
          },
          isDeprecated: {
            type: new GraphQLNonNull(GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: GraphQLString,
            resolve: (obj) => obj.deprecationReason
          }
        })
      });
      __EnumValue = new GraphQLObjectType({
        name: "__EnumValue",
        description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
        fields: () => ({
          name: {
            type: new GraphQLNonNull(GraphQLString),
            resolve: (enumValue) => enumValue.name
          },
          description: {
            type: GraphQLString,
            resolve: (enumValue) => enumValue.description
          },
          isDeprecated: {
            type: new GraphQLNonNull(GraphQLBoolean),
            resolve: (enumValue) => enumValue.deprecationReason != null
          },
          deprecationReason: {
            type: GraphQLString,
            resolve: (enumValue) => enumValue.deprecationReason
          }
        })
      });
      (function(TypeKind2) {
        TypeKind2["SCALAR"] = "SCALAR";
        TypeKind2["OBJECT"] = "OBJECT";
        TypeKind2["INTERFACE"] = "INTERFACE";
        TypeKind2["UNION"] = "UNION";
        TypeKind2["ENUM"] = "ENUM";
        TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
        TypeKind2["LIST"] = "LIST";
        TypeKind2["NON_NULL"] = "NON_NULL";
      })(TypeKind || (TypeKind = {}));
      __TypeKind = new GraphQLEnumType({
        name: "__TypeKind",
        description: "An enum describing what kind of type a given `__Type` is.",
        values: {
          SCALAR: {
            value: TypeKind.SCALAR,
            description: "Indicates this type is a scalar."
          },
          OBJECT: {
            value: TypeKind.OBJECT,
            description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
          },
          INTERFACE: {
            value: TypeKind.INTERFACE,
            description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
          },
          UNION: {
            value: TypeKind.UNION,
            description: "Indicates this type is a union. `possibleTypes` is a valid field."
          },
          ENUM: {
            value: TypeKind.ENUM,
            description: "Indicates this type is an enum. `enumValues` is a valid field."
          },
          INPUT_OBJECT: {
            value: TypeKind.INPUT_OBJECT,
            description: "Indicates this type is an input object. `inputFields` is a valid field."
          },
          LIST: {
            value: TypeKind.LIST,
            description: "Indicates this type is a list. `ofType` is a valid field."
          },
          NON_NULL: {
            value: TypeKind.NON_NULL,
            description: "Indicates this type is a non-null. `ofType` is a valid field."
          }
        }
      });
      SchemaMetaFieldDef = {
        name: "__schema",
        type: new GraphQLNonNull(__Schema),
        description: "Access the current type schema of this server.",
        args: [],
        resolve: (_source, _args, _context, { schema }) => schema,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      TypeMetaFieldDef = {
        name: "__type",
        type: __Type,
        description: "Request the type information of a single type.",
        args: [
          {
            name: "name",
            description: void 0,
            type: new GraphQLNonNull(GraphQLString),
            defaultValue: void 0,
            deprecationReason: void 0,
            extensions: /* @__PURE__ */ Object.create(null),
            astNode: void 0
          }
        ],
        resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      TypeNameMetaFieldDef = {
        name: "__typename",
        type: new GraphQLNonNull(GraphQLString),
        description: "The name of the current Object type at runtime.",
        args: [],
        resolve: (_source, _args, _context, { parentType }) => parentType.name,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      introspectionTypes = Object.freeze([
        __Schema,
        __Directive,
        __DirectiveLocation,
        __Type,
        __Field,
        __InputValue,
        __EnumValue,
        __TypeKind
      ]);
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/schema.mjs
  function isSchema(schema) {
    return instanceOf(schema, GraphQLSchema);
  }
  function assertSchema(schema) {
    if (!isSchema(schema)) {
      throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
    }
    return schema;
  }
  function collectReferencedTypes(type, typeSet) {
    const namedType = getNamedType(type);
    if (!typeSet.has(namedType)) {
      typeSet.add(namedType);
      if (isUnionType(namedType)) {
        for (const memberType of namedType.getTypes()) {
          collectReferencedTypes(memberType, typeSet);
        }
      } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
        for (const interfaceType of namedType.getInterfaces()) {
          collectReferencedTypes(interfaceType, typeSet);
        }
        for (const field of Object.values(namedType.getFields())) {
          collectReferencedTypes(field.type, typeSet);
          for (const arg of field.args) {
            collectReferencedTypes(arg.type, typeSet);
          }
        }
      } else if (isInputObjectType(namedType)) {
        for (const field of Object.values(namedType.getFields())) {
          collectReferencedTypes(field.type, typeSet);
        }
      }
    }
    return typeSet;
  }
  var GraphQLSchema;
  var init_schema = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/schema.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_inspect();
      init_instanceOf();
      init_isObjectLike();
      init_toObjMap();
      init_ast();
      init_definition();
      init_directives();
      init_introspection();
      GraphQLSchema = class {
        // Used as a cache for validateSchema().
        constructor(config2) {
          var _config$extensionASTN, _config$directives;
          this.__validationErrors = config2.assumeValid === true ? [] : void 0;
          isObjectLike(config2) || devAssert(false, "Must provide configuration object.");
          !config2.types || Array.isArray(config2.types) || devAssert(
            false,
            `"types" must be Array if provided but got: ${inspect(config2.types)}.`
          );
          !config2.directives || Array.isArray(config2.directives) || devAssert(
            false,
            `"directives" must be Array if provided but got: ${inspect(config2.directives)}.`
          );
          this.description = config2.description;
          this.extensions = toObjMap(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          this._queryType = config2.query;
          this._mutationType = config2.mutation;
          this._subscriptionType = config2.subscription;
          this._directives = (_config$directives = config2.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
          const allReferencedTypes = new Set(config2.types);
          if (config2.types != null) {
            for (const type of config2.types) {
              allReferencedTypes.delete(type);
              collectReferencedTypes(type, allReferencedTypes);
            }
          }
          if (this._queryType != null) {
            collectReferencedTypes(this._queryType, allReferencedTypes);
          }
          if (this._mutationType != null) {
            collectReferencedTypes(this._mutationType, allReferencedTypes);
          }
          if (this._subscriptionType != null) {
            collectReferencedTypes(this._subscriptionType, allReferencedTypes);
          }
          for (const directive of this._directives) {
            if (isDirective(directive)) {
              for (const arg of directive.args) {
                collectReferencedTypes(arg.type, allReferencedTypes);
              }
            }
          }
          collectReferencedTypes(__Schema, allReferencedTypes);
          this._typeMap = /* @__PURE__ */ Object.create(null);
          this._subTypeMap = /* @__PURE__ */ Object.create(null);
          this._implementationsMap = /* @__PURE__ */ Object.create(null);
          for (const namedType of allReferencedTypes) {
            if (namedType == null) {
              continue;
            }
            const typeName = namedType.name;
            typeName || devAssert(
              false,
              "One of the provided types for building the Schema is missing a name."
            );
            if (this._typeMap[typeName] !== void 0) {
              throw new Error(
                `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
              );
            }
            this._typeMap[typeName] = namedType;
            if (isInterfaceType(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if (isInterfaceType(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.interfaces.push(namedType);
                }
              }
            } else if (isObjectType(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if (isInterfaceType(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.objects.push(namedType);
                }
              }
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLSchema";
        }
        getQueryType() {
          return this._queryType;
        }
        getMutationType() {
          return this._mutationType;
        }
        getSubscriptionType() {
          return this._subscriptionType;
        }
        getRootType(operation) {
          switch (operation) {
            case OperationTypeNode.QUERY:
              return this.getQueryType();
            case OperationTypeNode.MUTATION:
              return this.getMutationType();
            case OperationTypeNode.SUBSCRIPTION:
              return this.getSubscriptionType();
          }
        }
        getTypeMap() {
          return this._typeMap;
        }
        getType(name2) {
          return this.getTypeMap()[name2];
        }
        getPossibleTypes(abstractType) {
          return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
        }
        getImplementations(interfaceType) {
          const implementations = this._implementationsMap[interfaceType.name];
          return implementations !== null && implementations !== void 0 ? implementations : {
            objects: [],
            interfaces: []
          };
        }
        isSubType(abstractType, maybeSubType) {
          let map = this._subTypeMap[abstractType.name];
          if (map === void 0) {
            map = /* @__PURE__ */ Object.create(null);
            if (isUnionType(abstractType)) {
              for (const type of abstractType.getTypes()) {
                map[type.name] = true;
              }
            } else {
              const implementations = this.getImplementations(abstractType);
              for (const type of implementations.objects) {
                map[type.name] = true;
              }
              for (const type of implementations.interfaces) {
                map[type.name] = true;
              }
            }
            this._subTypeMap[abstractType.name] = map;
          }
          return map[maybeSubType.name] !== void 0;
        }
        getDirectives() {
          return this._directives;
        }
        getDirective(name2) {
          return this.getDirectives().find((directive) => directive.name === name2);
        }
        toConfig() {
          return {
            description: this.description,
            query: this.getQueryType(),
            mutation: this.getMutationType(),
            subscription: this.getSubscriptionType(),
            types: Object.values(this.getTypeMap()),
            directives: this.getDirectives(),
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes,
            assumeValid: this.__validationErrors !== void 0
          };
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/validate.mjs
  function validateSchema(schema) {
    assertSchema(schema);
    if (schema.__validationErrors) {
      return schema.__validationErrors;
    }
    const context = new SchemaValidationContext(schema);
    validateRootTypes(context);
    validateDirectives(context);
    validateTypes(context);
    const errors = context.getErrors();
    schema.__validationErrors = errors;
    return errors;
  }
  function assertValidSchema(schema) {
    const errors = validateSchema(schema);
    if (errors.length !== 0) {
      throw new Error(errors.map((error) => error.message).join("\n\n"));
    }
  }
  function validateRootTypes(context) {
    const schema = context.schema;
    const queryType = schema.getQueryType();
    if (!queryType) {
      context.reportError("Query root type must be provided.", schema.astNode);
    } else if (!isObjectType(queryType)) {
      var _getOperationTypeNode;
      context.reportError(
        `Query root type must be Object type, it cannot be ${inspect(
          queryType
        )}.`,
        (_getOperationTypeNode = getOperationTypeNode(
          schema,
          OperationTypeNode.QUERY
        )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
      );
    }
    const mutationType = schema.getMutationType();
    if (mutationType && !isObjectType(mutationType)) {
      var _getOperationTypeNode2;
      context.reportError(
        `Mutation root type must be Object type if provided, it cannot be ${inspect(mutationType)}.`,
        (_getOperationTypeNode2 = getOperationTypeNode(
          schema,
          OperationTypeNode.MUTATION
        )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
      );
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && !isObjectType(subscriptionType)) {
      var _getOperationTypeNode3;
      context.reportError(
        `Subscription root type must be Object type if provided, it cannot be ${inspect(subscriptionType)}.`,
        (_getOperationTypeNode3 = getOperationTypeNode(
          schema,
          OperationTypeNode.SUBSCRIPTION
        )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
      );
    }
  }
  function getOperationTypeNode(schema, operation) {
    var _flatMap$find;
    return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (schemaNode) => {
        var _schemaNode$operation;
        return (
          /* c8 ignore next */
          (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
        );
      }
    ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
  }
  function validateDirectives(context) {
    for (const directive of context.schema.getDirectives()) {
      if (!isDirective(directive)) {
        context.reportError(
          `Expected directive but got: ${inspect(directive)}.`,
          directive === null || directive === void 0 ? void 0 : directive.astNode
        );
        continue;
      }
      validateName(context, directive);
      for (const arg of directive.args) {
        validateName(context, arg);
        if (!isInputType(arg.type)) {
          context.reportError(
            `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${inspect(arg.type)}.`,
            arg.astNode
          );
        }
        if (isRequiredArgument(arg) && arg.deprecationReason != null) {
          var _arg$astNode;
          context.reportError(
            `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
            [
              getDeprecatedDirectiveNode(arg.astNode),
              (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
            ]
          );
        }
      }
    }
  }
  function validateName(context, node) {
    if (node.name.startsWith("__")) {
      context.reportError(
        `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
        node.astNode
      );
    }
  }
  function validateTypes(context) {
    const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
    const typeMap = context.schema.getTypeMap();
    for (const type of Object.values(typeMap)) {
      if (!isNamedType(type)) {
        context.reportError(
          `Expected GraphQL named type but got: ${inspect(type)}.`,
          type.astNode
        );
        continue;
      }
      if (!isIntrospectionType(type)) {
        validateName(context, type);
      }
      if (isObjectType(type)) {
        validateFields(context, type);
        validateInterfaces(context, type);
      } else if (isInterfaceType(type)) {
        validateFields(context, type);
        validateInterfaces(context, type);
      } else if (isUnionType(type)) {
        validateUnionMembers(context, type);
      } else if (isEnumType(type)) {
        validateEnumValues(context, type);
      } else if (isInputObjectType(type)) {
        validateInputFields(context, type);
        validateInputObjectCircularRefs(type);
      }
    }
  }
  function validateFields(context, type) {
    const fields = Object.values(type.getFields());
    if (fields.length === 0) {
      context.reportError(`Type ${type.name} must define one or more fields.`, [
        type.astNode,
        ...type.extensionASTNodes
      ]);
    }
    for (const field of fields) {
      validateName(context, field);
      if (!isOutputType(field.type)) {
        var _field$astNode;
        context.reportError(
          `The type of ${type.name}.${field.name} must be Output Type but got: ${inspect(field.type)}.`,
          (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
        );
      }
      for (const arg of field.args) {
        const argName = arg.name;
        validateName(context, arg);
        if (!isInputType(arg.type)) {
          var _arg$astNode2;
          context.reportError(
            `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${inspect(arg.type)}.`,
            (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
          );
        }
        if (isRequiredArgument(arg) && arg.deprecationReason != null) {
          var _arg$astNode3;
          context.reportError(
            `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
            [
              getDeprecatedDirectiveNode(arg.astNode),
              (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
            ]
          );
        }
      }
    }
  }
  function validateInterfaces(context, type) {
    const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
    for (const iface of type.getInterfaces()) {
      if (!isInterfaceType(iface)) {
        context.reportError(
          `Type ${inspect(type)} must only implement Interface types, it cannot implement ${inspect(iface)}.`,
          getAllImplementsInterfaceNodes(type, iface)
        );
        continue;
      }
      if (type === iface) {
        context.reportError(
          `Type ${type.name} cannot implement itself because it would create a circular reference.`,
          getAllImplementsInterfaceNodes(type, iface)
        );
        continue;
      }
      if (ifaceTypeNames[iface.name]) {
        context.reportError(
          `Type ${type.name} can only implement ${iface.name} once.`,
          getAllImplementsInterfaceNodes(type, iface)
        );
        continue;
      }
      ifaceTypeNames[iface.name] = true;
      validateTypeImplementsAncestors(context, type, iface);
      validateTypeImplementsInterface(context, type, iface);
    }
  }
  function validateTypeImplementsInterface(context, type, iface) {
    const typeFieldMap = type.getFields();
    for (const ifaceField of Object.values(iface.getFields())) {
      const fieldName = ifaceField.name;
      const typeField = typeFieldMap[fieldName];
      if (!typeField) {
        context.reportError(
          `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
          [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
        );
        continue;
      }
      if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
        var _ifaceField$astNode, _typeField$astNode;
        context.reportError(
          `Interface field ${iface.name}.${fieldName} expects type ${inspect(ifaceField.type)} but ${type.name}.${fieldName} is type ${inspect(typeField.type)}.`,
          [
            (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
            (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
          ]
        );
      }
      for (const ifaceArg of ifaceField.args) {
        const argName = ifaceArg.name;
        const typeArg = typeField.args.find((arg) => arg.name === argName);
        if (!typeArg) {
          context.reportError(
            `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
            [ifaceArg.astNode, typeField.astNode]
          );
          continue;
        }
        if (!isEqualType(ifaceArg.type, typeArg.type)) {
          var _ifaceArg$astNode, _typeArg$astNode;
          context.reportError(
            `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${inspect(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${inspect(typeArg.type)}.`,
            [
              (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
              (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
            ]
          );
        }
      }
      for (const typeArg of typeField.args) {
        const argName = typeArg.name;
        const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
        if (!ifaceArg && isRequiredArgument(typeArg)) {
          context.reportError(
            `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
            [typeArg.astNode, ifaceField.astNode]
          );
        }
      }
    }
  }
  function validateTypeImplementsAncestors(context, type, iface) {
    const ifaceInterfaces = type.getInterfaces();
    for (const transitive of iface.getInterfaces()) {
      if (!ifaceInterfaces.includes(transitive)) {
        context.reportError(
          transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
          [
            ...getAllImplementsInterfaceNodes(iface, transitive),
            ...getAllImplementsInterfaceNodes(type, iface)
          ]
        );
      }
    }
  }
  function validateUnionMembers(context, union) {
    const memberTypes = union.getTypes();
    if (memberTypes.length === 0) {
      context.reportError(
        `Union type ${union.name} must define one or more member types.`,
        [union.astNode, ...union.extensionASTNodes]
      );
    }
    const includedTypeNames = /* @__PURE__ */ Object.create(null);
    for (const memberType of memberTypes) {
      if (includedTypeNames[memberType.name]) {
        context.reportError(
          `Union type ${union.name} can only include type ${memberType.name} once.`,
          getUnionMemberTypeNodes(union, memberType.name)
        );
        continue;
      }
      includedTypeNames[memberType.name] = true;
      if (!isObjectType(memberType)) {
        context.reportError(
          `Union type ${union.name} can only include Object types, it cannot include ${inspect(memberType)}.`,
          getUnionMemberTypeNodes(union, String(memberType))
        );
      }
    }
  }
  function validateEnumValues(context, enumType) {
    const enumValues = enumType.getValues();
    if (enumValues.length === 0) {
      context.reportError(
        `Enum type ${enumType.name} must define one or more values.`,
        [enumType.astNode, ...enumType.extensionASTNodes]
      );
    }
    for (const enumValue of enumValues) {
      validateName(context, enumValue);
    }
  }
  function validateInputFields(context, inputObj) {
    const fields = Object.values(inputObj.getFields());
    if (fields.length === 0) {
      context.reportError(
        `Input Object type ${inputObj.name} must define one or more fields.`,
        [inputObj.astNode, ...inputObj.extensionASTNodes]
      );
    }
    for (const field of fields) {
      validateName(context, field);
      if (!isInputType(field.type)) {
        var _field$astNode2;
        context.reportError(
          `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${inspect(field.type)}.`,
          (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
        );
      }
      if (isRequiredInputField(field) && field.deprecationReason != null) {
        var _field$astNode3;
        context.reportError(
          `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(field.astNode),
            (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
          ]
        );
      }
    }
  }
  function createInputObjectCircularRefsValidator(context) {
    const visitedTypes = /* @__PURE__ */ Object.create(null);
    const fieldPath = [];
    const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
    return detectCycleRecursive;
    function detectCycleRecursive(inputObj) {
      if (visitedTypes[inputObj.name]) {
        return;
      }
      visitedTypes[inputObj.name] = true;
      fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
      const fields = Object.values(inputObj.getFields());
      for (const field of fields) {
        if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
          const fieldType = field.type.ofType;
          const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
          fieldPath.push(field);
          if (cycleIndex === void 0) {
            detectCycleRecursive(fieldType);
          } else {
            const cyclePath = fieldPath.slice(cycleIndex);
            const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
            context.reportError(
              `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
              cyclePath.map((fieldObj) => fieldObj.astNode)
            );
          }
          fieldPath.pop();
        }
      }
      fieldPathIndexByTypeName[inputObj.name] = void 0;
    }
  }
  function getAllImplementsInterfaceNodes(type, iface) {
    const { astNode, extensionASTNodes } = type;
    const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
    return nodes.flatMap((typeNode) => {
      var _typeNode$interfaces;
      return (
        /* c8 ignore next */
        (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
      );
    }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
  }
  function getUnionMemberTypeNodes(union, typeName) {
    const { astNode, extensionASTNodes } = union;
    const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
    return nodes.flatMap((unionNode) => {
      var _unionNode$types;
      return (
        /* c8 ignore next */
        (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
      );
    }).filter((typeNode) => typeNode.name.value === typeName);
  }
  function getDeprecatedDirectiveNode(definitionNode) {
    var _definitionNode$direc;
    return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
      (node) => node.name.value === GraphQLDeprecatedDirective.name
    );
  }
  var SchemaValidationContext;
  var init_validate = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/validate.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_GraphQLError();
      init_ast();
      init_typeComparators();
      init_definition();
      init_directives();
      init_introspection();
      init_schema();
      SchemaValidationContext = class {
        constructor(schema) {
          this._errors = [];
          this.schema = schema;
        }
        reportError(message, nodes) {
          const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
          this._errors.push(
            new GraphQLError(message, {
              nodes: _nodes
            })
          );
        }
        getErrors() {
          return this._errors;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/typeFromAST.mjs
  function typeFromAST(schema, typeNode) {
    switch (typeNode.kind) {
      case Kind.LIST_TYPE: {
        const innerType = typeFromAST(schema, typeNode.type);
        return innerType && new GraphQLList(innerType);
      }
      case Kind.NON_NULL_TYPE: {
        const innerType = typeFromAST(schema, typeNode.type);
        return innerType && new GraphQLNonNull(innerType);
      }
      case Kind.NAMED_TYPE:
        return schema.getType(typeNode.name.value);
    }
  }
  var init_typeFromAST = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/typeFromAST.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_kinds();
      init_definition();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/TypeInfo.mjs
  function getFieldDef(schema, parentType, fieldNode) {
    const name2 = fieldNode.name.value;
    if (name2 === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
      return SchemaMetaFieldDef;
    }
    if (name2 === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
      return TypeMetaFieldDef;
    }
    if (name2 === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
      return TypeNameMetaFieldDef;
    }
    if (isObjectType(parentType) || isInterfaceType(parentType)) {
      return parentType.getFields()[name2];
    }
  }
  function visitWithTypeInfo(typeInfo, visitor) {
    return {
      enter(...args) {
        const node = args[0];
        typeInfo.enter(node);
        const fn = getEnterLeaveForKind(visitor, node.kind).enter;
        if (fn) {
          const result = fn.apply(visitor, args);
          if (result !== void 0) {
            typeInfo.leave(node);
            if (isNode(result)) {
              typeInfo.enter(result);
            }
          }
          return result;
        }
      },
      leave(...args) {
        const node = args[0];
        const fn = getEnterLeaveForKind(visitor, node.kind).leave;
        let result;
        if (fn) {
          result = fn.apply(visitor, args);
        }
        typeInfo.leave(node);
        return result;
      }
    };
  }
  var TypeInfo;
  var init_TypeInfo = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/TypeInfo.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_ast();
      init_kinds();
      init_visitor();
      init_definition();
      init_introspection();
      init_typeFromAST();
      TypeInfo = class {
        constructor(schema, initialType, getFieldDefFn) {
          this._schema = schema;
          this._typeStack = [];
          this._parentTypeStack = [];
          this._inputTypeStack = [];
          this._fieldDefStack = [];
          this._defaultValueStack = [];
          this._directive = null;
          this._argument = null;
          this._enumValue = null;
          this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
          if (initialType) {
            if (isInputType(initialType)) {
              this._inputTypeStack.push(initialType);
            }
            if (isCompositeType(initialType)) {
              this._parentTypeStack.push(initialType);
            }
            if (isOutputType(initialType)) {
              this._typeStack.push(initialType);
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "TypeInfo";
        }
        getType() {
          if (this._typeStack.length > 0) {
            return this._typeStack[this._typeStack.length - 1];
          }
        }
        getParentType() {
          if (this._parentTypeStack.length > 0) {
            return this._parentTypeStack[this._parentTypeStack.length - 1];
          }
        }
        getInputType() {
          if (this._inputTypeStack.length > 0) {
            return this._inputTypeStack[this._inputTypeStack.length - 1];
          }
        }
        getParentInputType() {
          if (this._inputTypeStack.length > 1) {
            return this._inputTypeStack[this._inputTypeStack.length - 2];
          }
        }
        getFieldDef() {
          if (this._fieldDefStack.length > 0) {
            return this._fieldDefStack[this._fieldDefStack.length - 1];
          }
        }
        getDefaultValue() {
          if (this._defaultValueStack.length > 0) {
            return this._defaultValueStack[this._defaultValueStack.length - 1];
          }
        }
        getDirective() {
          return this._directive;
        }
        getArgument() {
          return this._argument;
        }
        getEnumValue() {
          return this._enumValue;
        }
        enter(node) {
          const schema = this._schema;
          switch (node.kind) {
            case Kind.SELECTION_SET: {
              const namedType = getNamedType(this.getType());
              this._parentTypeStack.push(
                isCompositeType(namedType) ? namedType : void 0
              );
              break;
            }
            case Kind.FIELD: {
              const parentType = this.getParentType();
              let fieldDef;
              let fieldType;
              if (parentType) {
                fieldDef = this._getFieldDef(schema, parentType, node);
                if (fieldDef) {
                  fieldType = fieldDef.type;
                }
              }
              this._fieldDefStack.push(fieldDef);
              this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
              break;
            }
            case Kind.DIRECTIVE:
              this._directive = schema.getDirective(node.name.value);
              break;
            case Kind.OPERATION_DEFINITION: {
              const rootType = schema.getRootType(node.operation);
              this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
              break;
            }
            case Kind.INLINE_FRAGMENT:
            case Kind.FRAGMENT_DEFINITION: {
              const typeConditionAST = node.typeCondition;
              const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
              this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
              break;
            }
            case Kind.VARIABLE_DEFINITION: {
              const inputType = typeFromAST(schema, node.type);
              this._inputTypeStack.push(
                isInputType(inputType) ? inputType : void 0
              );
              break;
            }
            case Kind.ARGUMENT: {
              var _this$getDirective;
              let argDef;
              let argType;
              const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
              if (fieldOrDirective) {
                argDef = fieldOrDirective.args.find(
                  (arg) => arg.name === node.name.value
                );
                if (argDef) {
                  argType = argDef.type;
                }
              }
              this._argument = argDef;
              this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
              this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
              break;
            }
            case Kind.LIST: {
              const listType = getNullableType(this.getInputType());
              const itemType = isListType(listType) ? listType.ofType : listType;
              this._defaultValueStack.push(void 0);
              this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
              break;
            }
            case Kind.OBJECT_FIELD: {
              const objectType = getNamedType(this.getInputType());
              let inputFieldType;
              let inputField;
              if (isInputObjectType(objectType)) {
                inputField = objectType.getFields()[node.name.value];
                if (inputField) {
                  inputFieldType = inputField.type;
                }
              }
              this._defaultValueStack.push(
                inputField ? inputField.defaultValue : void 0
              );
              this._inputTypeStack.push(
                isInputType(inputFieldType) ? inputFieldType : void 0
              );
              break;
            }
            case Kind.ENUM: {
              const enumType = getNamedType(this.getInputType());
              let enumValue;
              if (isEnumType(enumType)) {
                enumValue = enumType.getValue(node.value);
              }
              this._enumValue = enumValue;
              break;
            }
            default:
          }
        }
        leave(node) {
          switch (node.kind) {
            case Kind.SELECTION_SET:
              this._parentTypeStack.pop();
              break;
            case Kind.FIELD:
              this._fieldDefStack.pop();
              this._typeStack.pop();
              break;
            case Kind.DIRECTIVE:
              this._directive = null;
              break;
            case Kind.OPERATION_DEFINITION:
            case Kind.INLINE_FRAGMENT:
            case Kind.FRAGMENT_DEFINITION:
              this._typeStack.pop();
              break;
            case Kind.VARIABLE_DEFINITION:
              this._inputTypeStack.pop();
              break;
            case Kind.ARGUMENT:
              this._argument = null;
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case Kind.LIST:
            case Kind.OBJECT_FIELD:
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case Kind.ENUM:
              this._enumValue = null;
              break;
            default:
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/predicates.mjs
  function isDefinitionNode(node) {
    return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
  }
  function isExecutableDefinitionNode(node) {
    return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
  }
  function isSelectionNode(node) {
    return node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT;
  }
  function isValueNode(node) {
    return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;
  }
  function isConstValueNode(node) {
    return isValueNode(node) && (node.kind === Kind.LIST ? node.values.some(isConstValueNode) : node.kind === Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== Kind.VARIABLE);
  }
  function isTypeNode(node) {
    return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;
  }
  function isTypeSystemDefinitionNode(node) {
    return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
  }
  function isTypeDefinitionNode(node) {
    return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
  }
  function isTypeSystemExtensionNode(node) {
    return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
  }
  function isTypeExtensionNode(node) {
    return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  var init_predicates = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/predicates.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_kinds();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
  function ExecutableDefinitionsRule(context) {
    return {
      Document(node) {
        for (const definition of node.definitions) {
          if (!isExecutableDefinitionNode(definition)) {
            const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
            context.reportError(
              new GraphQLError(`The ${defName} definition is not executable.`, {
                nodes: definition
              })
            );
          }
        }
        return false;
      }
    };
  }
  var init_ExecutableDefinitionsRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
      init_kinds();
      init_predicates();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
  function FieldsOnCorrectTypeRule(context) {
    return {
      Field(node) {
        const type = context.getParentType();
        if (type) {
          const fieldDef = context.getFieldDef();
          if (!fieldDef) {
            const schema = context.getSchema();
            const fieldName = node.name.value;
            let suggestion = didYouMean(
              "to use an inline fragment on",
              getSuggestedTypeNames(schema, type, fieldName)
            );
            if (suggestion === "") {
              suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
            }
            context.reportError(
              new GraphQLError(
                `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
                {
                  nodes: node
                }
              )
            );
          }
        }
      }
    };
  }
  function getSuggestedTypeNames(schema, type, fieldName) {
    if (!isAbstractType(type)) {
      return [];
    }
    const suggestedTypes = /* @__PURE__ */ new Set();
    const usageCount = /* @__PURE__ */ Object.create(null);
    for (const possibleType of schema.getPossibleTypes(type)) {
      if (!possibleType.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleType);
      usageCount[possibleType.name] = 1;
      for (const possibleInterface of possibleType.getInterfaces()) {
        var _usageCount$possibleI;
        if (!possibleInterface.getFields()[fieldName]) {
          continue;
        }
        suggestedTypes.add(possibleInterface);
        usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
      }
    }
    return [...suggestedTypes].sort((typeA, typeB) => {
      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
      if (usageCountDiff !== 0) {
        return usageCountDiff;
      }
      if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
        return -1;
      }
      if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
        return 1;
      }
      return naturalCompare(typeA.name, typeB.name);
    }).map((x) => x.name);
  }
  function getSuggestedFieldNames(type, fieldName) {
    if (isObjectType(type) || isInterfaceType(type)) {
      const possibleFieldNames = Object.keys(type.getFields());
      return suggestionList(fieldName, possibleFieldNames);
    }
    return [];
  }
  var init_FieldsOnCorrectTypeRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_didYouMean();
      init_naturalCompare();
      init_suggestionList();
      init_GraphQLError();
      init_definition();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
  function FragmentsOnCompositeTypesRule(context) {
    return {
      InlineFragment(node) {
        const typeCondition = node.typeCondition;
        if (typeCondition) {
          const type = typeFromAST(context.getSchema(), typeCondition);
          if (type && !isCompositeType(type)) {
            const typeStr = print(typeCondition);
            context.reportError(
              new GraphQLError(
                `Fragment cannot condition on non composite type "${typeStr}".`,
                {
                  nodes: typeCondition
                }
              )
            );
          }
        }
      },
      FragmentDefinition(node) {
        const type = typeFromAST(context.getSchema(), node.typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(node.typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
              {
                nodes: node.typeCondition
              }
            )
          );
        }
      }
    };
  }
  var init_FragmentsOnCompositeTypesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
      init_printer();
      init_definition();
      init_typeFromAST();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
  function KnownArgumentNamesRule(context) {
    return __spreadProps(__spreadValues({}, KnownArgumentNamesOnDirectivesRule(context)), {
      Argument(argNode) {
        const argDef = context.getArgument();
        const fieldDef = context.getFieldDef();
        const parentType = context.getParentType();
        if (!argDef && fieldDef && parentType) {
          const argName = argNode.name.value;
          const knownArgsNames = fieldDef.args.map((arg) => arg.name);
          const suggestions = suggestionList(argName, knownArgsNames);
          context.reportError(
            new GraphQLError(
              `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
              {
                nodes: argNode
              }
            )
          );
        }
      }
    });
  }
  function KnownArgumentNamesOnDirectivesRule(context) {
    const directiveArgs = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
    for (const directive of definedDirectives) {
      directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === Kind.DIRECTIVE_DEFINITION) {
        var _def$arguments;
        const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
        directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
      }
    }
    return {
      Directive(directiveNode) {
        const directiveName = directiveNode.name.value;
        const knownArgs = directiveArgs[directiveName];
        if (directiveNode.arguments && knownArgs) {
          for (const argNode of directiveNode.arguments) {
            const argName = argNode.name.value;
            if (!knownArgs.includes(argName)) {
              const suggestions = suggestionList(argName, knownArgs);
              context.reportError(
                new GraphQLError(
                  `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                  {
                    nodes: argNode
                  }
                )
              );
            }
          }
        }
        return false;
      }
    };
  }
  var init_KnownArgumentNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_didYouMean();
      init_suggestionList();
      init_GraphQLError();
      init_kinds();
      init_directives();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
  function KnownDirectivesRule(context) {
    const locationsMap = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
    for (const directive of definedDirectives) {
      locationsMap[directive.name] = directive.locations;
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === Kind.DIRECTIVE_DEFINITION) {
        locationsMap[def.name.value] = def.locations.map((name2) => name2.value);
      }
    }
    return {
      Directive(node, _key, _parent, _path, ancestors) {
        const name2 = node.name.value;
        const locations = locationsMap[name2];
        if (!locations) {
          context.reportError(
            new GraphQLError(`Unknown directive "@${name2}".`, {
              nodes: node
            })
          );
          return;
        }
        const candidateLocation = getDirectiveLocationForASTPath(ancestors);
        if (candidateLocation && !locations.includes(candidateLocation)) {
          context.reportError(
            new GraphQLError(
              `Directive "@${name2}" may not be used on ${candidateLocation}.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    };
  }
  function getDirectiveLocationForASTPath(ancestors) {
    const appliedTo = ancestors[ancestors.length - 1];
    "kind" in appliedTo || invariant(false);
    switch (appliedTo.kind) {
      case Kind.OPERATION_DEFINITION:
        return getDirectiveLocationForOperation(appliedTo.operation);
      case Kind.FIELD:
        return DirectiveLocation.FIELD;
      case Kind.FRAGMENT_SPREAD:
        return DirectiveLocation.FRAGMENT_SPREAD;
      case Kind.INLINE_FRAGMENT:
        return DirectiveLocation.INLINE_FRAGMENT;
      case Kind.FRAGMENT_DEFINITION:
        return DirectiveLocation.FRAGMENT_DEFINITION;
      case Kind.VARIABLE_DEFINITION:
        return DirectiveLocation.VARIABLE_DEFINITION;
      case Kind.SCHEMA_DEFINITION:
      case Kind.SCHEMA_EXTENSION:
        return DirectiveLocation.SCHEMA;
      case Kind.SCALAR_TYPE_DEFINITION:
      case Kind.SCALAR_TYPE_EXTENSION:
        return DirectiveLocation.SCALAR;
      case Kind.OBJECT_TYPE_DEFINITION:
      case Kind.OBJECT_TYPE_EXTENSION:
        return DirectiveLocation.OBJECT;
      case Kind.FIELD_DEFINITION:
        return DirectiveLocation.FIELD_DEFINITION;
      case Kind.INTERFACE_TYPE_DEFINITION:
      case Kind.INTERFACE_TYPE_EXTENSION:
        return DirectiveLocation.INTERFACE;
      case Kind.UNION_TYPE_DEFINITION:
      case Kind.UNION_TYPE_EXTENSION:
        return DirectiveLocation.UNION;
      case Kind.ENUM_TYPE_DEFINITION:
      case Kind.ENUM_TYPE_EXTENSION:
        return DirectiveLocation.ENUM;
      case Kind.ENUM_VALUE_DEFINITION:
        return DirectiveLocation.ENUM_VALUE;
      case Kind.INPUT_OBJECT_TYPE_DEFINITION:
      case Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return DirectiveLocation.INPUT_OBJECT;
      case Kind.INPUT_VALUE_DEFINITION: {
        const parentNode = ancestors[ancestors.length - 3];
        "kind" in parentNode || invariant(false);
        return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
      }
      default:
        invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
    }
  }
  function getDirectiveLocationForOperation(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return DirectiveLocation.QUERY;
      case OperationTypeNode.MUTATION:
        return DirectiveLocation.MUTATION;
      case OperationTypeNode.SUBSCRIPTION:
        return DirectiveLocation.SUBSCRIPTION;
    }
  }
  var init_KnownDirectivesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_invariant();
      init_GraphQLError();
      init_ast();
      init_directiveLocation();
      init_kinds();
      init_directives();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
  function KnownFragmentNamesRule(context) {
    return {
      FragmentSpread(node) {
        const fragmentName = node.name.value;
        const fragment = context.getFragment(fragmentName);
        if (!fragment) {
          context.reportError(
            new GraphQLError(`Unknown fragment "${fragmentName}".`, {
              nodes: node.name
            })
          );
        }
      }
    };
  }
  var init_KnownFragmentNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
  function KnownTypeNamesRule(context) {
    const schema = context.getSchema();
    const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
    const definedTypes = /* @__PURE__ */ Object.create(null);
    for (const def of context.getDocument().definitions) {
      if (isTypeDefinitionNode(def)) {
        definedTypes[def.name.value] = true;
      }
    }
    const typeNames = [
      ...Object.keys(existingTypesMap),
      ...Object.keys(definedTypes)
    ];
    return {
      NamedType(node, _1, parent, _2, ancestors) {
        const typeName = node.name.value;
        if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
          var _ancestors$;
          const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
          const isSDL = definitionNode != null && isSDLNode(definitionNode);
          if (isSDL && standardTypeNames.includes(typeName)) {
            return;
          }
          const suggestedTypes = suggestionList(
            typeName,
            isSDL ? standardTypeNames.concat(typeNames) : typeNames
          );
          context.reportError(
            new GraphQLError(
              `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
              {
                nodes: node
              }
            )
          );
        }
      }
    };
  }
  function isSDLNode(value) {
    return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
  }
  var standardTypeNames;
  var init_KnownTypeNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_didYouMean();
      init_suggestionList();
      init_GraphQLError();
      init_predicates();
      init_introspection();
      init_scalars();
      standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
        (type) => type.name
      );
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
  function LoneAnonymousOperationRule(context) {
    let operationCount = 0;
    return {
      Document(node) {
        operationCount = node.definitions.filter(
          (definition) => definition.kind === Kind.OPERATION_DEFINITION
        ).length;
      },
      OperationDefinition(node) {
        if (!node.name && operationCount > 1) {
          context.reportError(
            new GraphQLError(
              "This anonymous operation must be the only defined operation.",
              {
                nodes: node
              }
            )
          );
        }
      }
    };
  }
  var init_LoneAnonymousOperationRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
      init_kinds();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
  function LoneSchemaDefinitionRule(context) {
    var _ref, _ref2, _oldSchema$astNode;
    const oldSchema = context.getSchema();
    const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
    let schemaDefinitionsCount = 0;
    return {
      SchemaDefinition(node) {
        if (alreadyDefined) {
          context.reportError(
            new GraphQLError(
              "Cannot define a new schema within a schema extension.",
              {
                nodes: node
              }
            )
          );
          return;
        }
        if (schemaDefinitionsCount > 0) {
          context.reportError(
            new GraphQLError("Must provide only one schema definition.", {
              nodes: node
            })
          );
        }
        ++schemaDefinitionsCount;
      }
    };
  }
  var init_LoneSchemaDefinitionRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
  function NoFragmentCyclesRule(context) {
    const visitedFrags = /* @__PURE__ */ Object.create(null);
    const spreadPath = [];
    const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: () => false,
      FragmentDefinition(node) {
        detectCycleRecursive(node);
        return false;
      }
    };
    function detectCycleRecursive(fragment) {
      if (visitedFrags[fragment.name.value]) {
        return;
      }
      const fragmentName = fragment.name.value;
      visitedFrags[fragmentName] = true;
      const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
      if (spreadNodes.length === 0) {
        return;
      }
      spreadPathIndexByName[fragmentName] = spreadPath.length;
      for (const spreadNode of spreadNodes) {
        const spreadName = spreadNode.name.value;
        const cycleIndex = spreadPathIndexByName[spreadName];
        spreadPath.push(spreadNode);
        if (cycleIndex === void 0) {
          const spreadFragment = context.getFragment(spreadName);
          if (spreadFragment) {
            detectCycleRecursive(spreadFragment);
          }
        } else {
          const cyclePath = spreadPath.slice(cycleIndex);
          const viaPath = cyclePath.slice(0, -1).map((s2) => '"' + s2.name.value + '"').join(", ");
          context.reportError(
            new GraphQLError(
              `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
              {
                nodes: cyclePath
              }
            )
          );
        }
        spreadPath.pop();
      }
      spreadPathIndexByName[fragmentName] = void 0;
    }
  }
  var init_NoFragmentCyclesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
  function NoUndefinedVariablesRule(context) {
    let variableNameDefined = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          variableNameDefined = /* @__PURE__ */ Object.create(null);
        },
        leave(operation) {
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node } of usages) {
            const varName = node.name.value;
            if (variableNameDefined[varName] !== true) {
              context.reportError(
                new GraphQLError(
                  operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                  {
                    nodes: [node, operation]
                  }
                )
              );
            }
          }
        }
      },
      VariableDefinition(node) {
        variableNameDefined[node.variable.name.value] = true;
      }
    };
  }
  var init_NoUndefinedVariablesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
  function NoUnusedFragmentsRule(context) {
    const operationDefs = [];
    const fragmentDefs = [];
    return {
      OperationDefinition(node) {
        operationDefs.push(node);
        return false;
      },
      FragmentDefinition(node) {
        fragmentDefs.push(node);
        return false;
      },
      Document: {
        leave() {
          const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
          for (const operation of operationDefs) {
            for (const fragment of context.getRecursivelyReferencedFragments(
              operation
            )) {
              fragmentNameUsed[fragment.name.value] = true;
            }
          }
          for (const fragmentDef of fragmentDefs) {
            const fragName = fragmentDef.name.value;
            if (fragmentNameUsed[fragName] !== true) {
              context.reportError(
                new GraphQLError(`Fragment "${fragName}" is never used.`, {
                  nodes: fragmentDef
                })
              );
            }
          }
        }
      }
    };
  }
  var init_NoUnusedFragmentsRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
  function NoUnusedVariablesRule(context) {
    let variableDefs = [];
    return {
      OperationDefinition: {
        enter() {
          variableDefs = [];
        },
        leave(operation) {
          const variableNameUsed = /* @__PURE__ */ Object.create(null);
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node } of usages) {
            variableNameUsed[node.name.value] = true;
          }
          for (const variableDef of variableDefs) {
            const variableName = variableDef.variable.name.value;
            if (variableNameUsed[variableName] !== true) {
              context.reportError(
                new GraphQLError(
                  operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                  {
                    nodes: variableDef
                  }
                )
              );
            }
          }
        }
      },
      VariableDefinition(def) {
        variableDefs.push(def);
      }
    };
  }
  var init_NoUnusedVariablesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/sortValueNode.mjs
  function sortValueNode(valueNode) {
    switch (valueNode.kind) {
      case Kind.OBJECT:
        return __spreadProps(__spreadValues({}, valueNode), { fields: sortFields(valueNode.fields) });
      case Kind.LIST:
        return __spreadProps(__spreadValues({}, valueNode), { values: valueNode.values.map(sortValueNode) });
      case Kind.INT:
      case Kind.FLOAT:
      case Kind.STRING:
      case Kind.BOOLEAN:
      case Kind.NULL:
      case Kind.ENUM:
      case Kind.VARIABLE:
        return valueNode;
    }
  }
  function sortFields(fields) {
    return fields.map((fieldNode) => __spreadProps(__spreadValues({}, fieldNode), {
      value: sortValueNode(fieldNode.value)
    })).sort(
      (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
    );
  }
  var init_sortValueNode = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/sortValueNode.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_naturalCompare();
      init_kinds();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
  function reasonMessage(reason) {
    if (Array.isArray(reason)) {
      return reason.map(
        ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
      ).join(" and ");
    }
    return reason;
  }
  function OverlappingFieldsCanBeMergedRule(context) {
    const comparedFragmentPairs = new PairSet();
    const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
    return {
      SelectionSet(selectionSet) {
        const conflicts = findConflictsWithinSelectionSet(
          context,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          context.getParentType(),
          selectionSet
        );
        for (const [[responseName, reason], fields1, fields2] of conflicts) {
          const reasonMsg = reasonMessage(reason);
          context.reportError(
            new GraphQLError(
              `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
              {
                nodes: fields1.concat(fields2)
              }
            )
          );
        }
      }
    };
  }
  function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
    const conflicts = [];
    const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      parentType,
      selectionSet
    );
    collectConflictsWithin(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      fieldMap
    );
    if (fragmentNames.length !== 0) {
      for (let i2 = 0; i2 < fragmentNames.length; i2++) {
        collectConflictsBetweenFieldsAndFragment(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fieldMap,
          fragmentNames[i2]
        );
        for (let j = i2 + 1; j < fragmentNames.length; j++) {
          collectConflictsBetweenFragments(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            fragmentNames[i2],
            fragmentNames[j]
          );
        }
      }
    }
    return conflicts;
  }
  function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
    const fragment = context.getFragment(fragmentName);
    if (!fragment) {
      return;
    }
    const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      fragment
    );
    if (fieldMap === fieldMap2) {
      return;
    }
    collectConflictsBetween(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      fieldMap2
    );
    for (const referencedFragmentName of referencedFragmentNames) {
      if (comparedFragmentPairs.has(
        referencedFragmentName,
        fragmentName,
        areMutuallyExclusive
      )) {
        continue;
      }
      comparedFragmentPairs.add(
        referencedFragmentName,
        fragmentName,
        areMutuallyExclusive
      );
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap,
        referencedFragmentName
      );
    }
  }
  function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
    if (fragmentName1 === fragmentName2) {
      return;
    }
    if (comparedFragmentPairs.has(
      fragmentName1,
      fragmentName2,
      areMutuallyExclusive
    )) {
      return;
    }
    comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
    const fragment1 = context.getFragment(fragmentName1);
    const fragment2 = context.getFragment(fragmentName2);
    if (!fragment1 || !fragment2) {
      return;
    }
    const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      fragment1
    );
    const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      fragment2
    );
    collectConflictsBetween(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fieldMap2
    );
    for (const referencedFragmentName2 of referencedFragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        referencedFragmentName2
      );
    }
    for (const referencedFragmentName1 of referencedFragmentNames1) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        referencedFragmentName1,
        fragmentName2
      );
    }
  }
  function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
    const conflicts = [];
    const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      parentType1,
      selectionSet1
    );
    const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      parentType2,
      selectionSet2
    );
    collectConflictsBetween(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fieldMap2
    );
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap1,
        fragmentName2
      );
    }
    for (const fragmentName1 of fragmentNames1) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fieldMap2,
        fragmentName1
      );
    }
    for (const fragmentName1 of fragmentNames1) {
      for (const fragmentName2 of fragmentNames2) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fragmentName1,
          fragmentName2
        );
      }
    }
    return conflicts;
  }
  function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
    for (const [responseName, fields] of Object.entries(fieldMap)) {
      if (fields.length > 1) {
        for (let i2 = 0; i2 < fields.length; i2++) {
          for (let j = i2 + 1; j < fields.length; j++) {
            const conflict = findConflict(
              context,
              cachedFieldsAndFragmentNames,
              comparedFragmentPairs,
              false,
              // within one collection is never mutually exclusive
              responseName,
              fields[i2],
              fields[j]
            );
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    }
  }
  function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
    for (const [responseName, fields1] of Object.entries(fieldMap1)) {
      const fields2 = fieldMap2[responseName];
      if (fields2) {
        for (const field1 of fields1) {
          for (const field2 of fields2) {
            const conflict = findConflict(
              context,
              cachedFieldsAndFragmentNames,
              comparedFragmentPairs,
              parentFieldsAreMutuallyExclusive,
              responseName,
              field1,
              field2
            );
            if (conflict) {
              conflicts.push(conflict);
            }
          }
        }
      }
    }
  }
  function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
    const [parentType1, node1, def1] = field1;
    const [parentType2, node2, def2] = field2;
    const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
    if (!areMutuallyExclusive) {
      const name1 = node1.name.value;
      const name2 = node2.name.value;
      if (name1 !== name2) {
        return [
          [responseName, `"${name1}" and "${name2}" are different fields`],
          [node1],
          [node2]
        ];
      }
      if (stringifyArguments(node1) !== stringifyArguments(node2)) {
        return [
          [responseName, "they have differing arguments"],
          [node1],
          [node2]
        ];
      }
    }
    const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
    const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
    if (type1 && type2 && doTypesConflict(type1, type2)) {
      return [
        [
          responseName,
          `they return conflicting types "${inspect(type1)}" and "${inspect(
            type2
          )}"`
        ],
        [node1],
        [node2]
      ];
    }
    const selectionSet1 = node1.selectionSet;
    const selectionSet2 = node2.selectionSet;
    if (selectionSet1 && selectionSet2) {
      const conflicts = findConflictsBetweenSubSelectionSets(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        getNamedType(type1),
        selectionSet1,
        getNamedType(type2),
        selectionSet2
      );
      return subfieldConflicts(conflicts, responseName, node1, node2);
    }
  }
  function stringifyArguments(fieldNode) {
    var _fieldNode$arguments;
    const args = (
      /* c8 ignore next */
      (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : []
    );
    const inputObjectWithArgs = {
      kind: Kind.OBJECT,
      fields: args.map((argNode) => ({
        kind: Kind.OBJECT_FIELD,
        name: argNode.name,
        value: argNode.value
      }))
    };
    return print(sortValueNode(inputObjectWithArgs));
  }
  function doTypesConflict(type1, type2) {
    if (isListType(type1)) {
      return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if (isListType(type2)) {
      return true;
    }
    if (isNonNullType(type1)) {
      return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
    }
    if (isNonNullType(type2)) {
      return true;
    }
    if (isLeafType(type1) || isLeafType(type2)) {
      return type1 !== type2;
    }
    return false;
  }
  function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
    const cached = cachedFieldsAndFragmentNames.get(selectionSet);
    if (cached) {
      return cached;
    }
    const nodeAndDefs = /* @__PURE__ */ Object.create(null);
    const fragmentNames = /* @__PURE__ */ Object.create(null);
    _collectFieldsAndFragmentNames(
      context,
      parentType,
      selectionSet,
      nodeAndDefs,
      fragmentNames
    );
    const result = [nodeAndDefs, Object.keys(fragmentNames)];
    cachedFieldsAndFragmentNames.set(selectionSet, result);
    return result;
  }
  function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
    const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
    if (cached) {
      return cached;
    }
    const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
    return getFieldsAndFragmentNames(
      context,
      cachedFieldsAndFragmentNames,
      fragmentType,
      fragment.selectionSet
    );
  }
  function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
    for (const selection of selectionSet.selections) {
      switch (selection.kind) {
        case Kind.FIELD: {
          const fieldName = selection.name.value;
          let fieldDef;
          if (isObjectType(parentType) || isInterfaceType(parentType)) {
            fieldDef = parentType.getFields()[fieldName];
          }
          const responseName = selection.alias ? selection.alias.value : fieldName;
          if (!nodeAndDefs[responseName]) {
            nodeAndDefs[responseName] = [];
          }
          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
          break;
        }
        case Kind.FRAGMENT_SPREAD:
          fragmentNames[selection.name.value] = true;
          break;
        case Kind.INLINE_FRAGMENT: {
          const typeCondition = selection.typeCondition;
          const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
          _collectFieldsAndFragmentNames(
            context,
            inlineFragmentType,
            selection.selectionSet,
            nodeAndDefs,
            fragmentNames
          );
          break;
        }
      }
    }
  }
  function subfieldConflicts(conflicts, responseName, node1, node2) {
    if (conflicts.length > 0) {
      return [
        [responseName, conflicts.map(([reason]) => reason)],
        [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
        [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
      ];
    }
  }
  var PairSet;
  var init_OverlappingFieldsCanBeMergedRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_GraphQLError();
      init_kinds();
      init_printer();
      init_definition();
      init_sortValueNode();
      init_typeFromAST();
      PairSet = class {
        constructor() {
          this._data = /* @__PURE__ */ new Map();
        }
        has(a2, b, areMutuallyExclusive) {
          var _this$_data$get;
          const [key1, key2] = a2 < b ? [a2, b] : [b, a2];
          const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
          if (result === void 0) {
            return false;
          }
          return areMutuallyExclusive ? true : areMutuallyExclusive === result;
        }
        add(a2, b, areMutuallyExclusive) {
          const [key1, key2] = a2 < b ? [a2, b] : [b, a2];
          const map = this._data.get(key1);
          if (map === void 0) {
            this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
          } else {
            map.set(key2, areMutuallyExclusive);
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
  function PossibleFragmentSpreadsRule(context) {
    return {
      InlineFragment(node) {
        const fragType = context.getType();
        const parentType = context.getParentType();
        if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
          const parentTypeStr = inspect(parentType);
          const fragTypeStr = inspect(fragType);
          context.reportError(
            new GraphQLError(
              `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
              {
                nodes: node
              }
            )
          );
        }
      },
      FragmentSpread(node) {
        const fragName = node.name.value;
        const fragType = getFragmentType(context, fragName);
        const parentType = context.getParentType();
        if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
          const parentTypeStr = inspect(parentType);
          const fragTypeStr = inspect(fragType);
          context.reportError(
            new GraphQLError(
              `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
              {
                nodes: node
              }
            )
          );
        }
      }
    };
  }
  function getFragmentType(context, name2) {
    const frag = context.getFragment(name2);
    if (frag) {
      const type = typeFromAST(context.getSchema(), frag.typeCondition);
      if (isCompositeType(type)) {
        return type;
      }
    }
  }
  var init_PossibleFragmentSpreadsRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_GraphQLError();
      init_definition();
      init_typeComparators();
      init_typeFromAST();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
  function PossibleTypeExtensionsRule(context) {
    const schema = context.getSchema();
    const definedTypes = /* @__PURE__ */ Object.create(null);
    for (const def of context.getDocument().definitions) {
      if (isTypeDefinitionNode(def)) {
        definedTypes[def.name.value] = def;
      }
    }
    return {
      ScalarTypeExtension: checkExtension,
      ObjectTypeExtension: checkExtension,
      InterfaceTypeExtension: checkExtension,
      UnionTypeExtension: checkExtension,
      EnumTypeExtension: checkExtension,
      InputObjectTypeExtension: checkExtension
    };
    function checkExtension(node) {
      const typeName = node.name.value;
      const defNode = definedTypes[typeName];
      const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
      let expectedKind;
      if (defNode) {
        expectedKind = defKindToExtKind[defNode.kind];
      } else if (existingType) {
        expectedKind = typeToExtKind(existingType);
      }
      if (expectedKind) {
        if (expectedKind !== node.kind) {
          const kindStr = extensionKindToTypeName(node.kind);
          context.reportError(
            new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
              nodes: defNode ? [defNode, node] : node
            })
          );
        }
      } else {
        const allTypeNames = Object.keys(__spreadValues(__spreadValues({}, definedTypes), schema === null || schema === void 0 ? void 0 : schema.getTypeMap()));
        const suggestedTypes = suggestionList(typeName, allTypeNames);
        context.reportError(
          new GraphQLError(
            `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
            {
              nodes: node.name
            }
          )
        );
      }
    }
  }
  function typeToExtKind(type) {
    if (isScalarType(type)) {
      return Kind.SCALAR_TYPE_EXTENSION;
    }
    if (isObjectType(type)) {
      return Kind.OBJECT_TYPE_EXTENSION;
    }
    if (isInterfaceType(type)) {
      return Kind.INTERFACE_TYPE_EXTENSION;
    }
    if (isUnionType(type)) {
      return Kind.UNION_TYPE_EXTENSION;
    }
    if (isEnumType(type)) {
      return Kind.ENUM_TYPE_EXTENSION;
    }
    if (isInputObjectType(type)) {
      return Kind.INPUT_OBJECT_TYPE_EXTENSION;
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
  function extensionKindToTypeName(kind) {
    switch (kind) {
      case Kind.SCALAR_TYPE_EXTENSION:
        return "scalar";
      case Kind.OBJECT_TYPE_EXTENSION:
        return "object";
      case Kind.INTERFACE_TYPE_EXTENSION:
        return "interface";
      case Kind.UNION_TYPE_EXTENSION:
        return "union";
      case Kind.ENUM_TYPE_EXTENSION:
        return "enum";
      case Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return "input object";
      default:
        invariant(false, "Unexpected kind: " + inspect(kind));
    }
  }
  var defKindToExtKind;
  var init_PossibleTypeExtensionsRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_didYouMean();
      init_inspect();
      init_invariant();
      init_suggestionList();
      init_GraphQLError();
      init_kinds();
      init_predicates();
      init_definition();
      defKindToExtKind = {
        [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
        [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
        [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
        [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
        [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
        [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
  function ProvidedRequiredArgumentsRule(context) {
    return __spreadProps(__spreadValues({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {
      Field: {
        // Validate on leave to allow for deeper errors to appear first.
        leave(fieldNode) {
          var _fieldNode$arguments;
          const fieldDef = context.getFieldDef();
          if (!fieldDef) {
            return false;
          }
          const providedArgs = new Set(
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            /* c8 ignore next */
            (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
          );
          for (const argDef of fieldDef.args) {
            if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
              const argTypeStr = inspect(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                  {
                    nodes: fieldNode
                  }
                )
              );
            }
          }
        }
      }
    });
  }
  function ProvidedRequiredArgumentsOnDirectivesRule(context) {
    var _schema$getDirectives;
    const requiredArgsMap = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
    for (const directive of definedDirectives) {
      requiredArgsMap[directive.name] = keyMap(
        directive.args.filter(isRequiredArgument),
        (arg) => arg.name
      );
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === Kind.DIRECTIVE_DEFINITION) {
        var _def$arguments;
        const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
        requiredArgsMap[def.name.value] = keyMap(
          argNodes.filter(isRequiredArgumentNode),
          (arg) => arg.name.value
        );
      }
    }
    return {
      Directive: {
        // Validate on leave to allow for deeper errors to appear first.
        leave(directiveNode) {
          const directiveName = directiveNode.name.value;
          const requiredArgs = requiredArgsMap[directiveName];
          if (requiredArgs) {
            var _directiveNode$argume;
            const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
            const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
            for (const [argName, argDef] of Object.entries(requiredArgs)) {
              if (!argNodeMap.has(argName)) {
                const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
                context.reportError(
                  new GraphQLError(
                    `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                    {
                      nodes: directiveNode
                    }
                  )
                );
              }
            }
          }
        }
      }
    };
  }
  function isRequiredArgumentNode(arg) {
    return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
  }
  var init_ProvidedRequiredArgumentsRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_keyMap();
      init_GraphQLError();
      init_kinds();
      init_printer();
      init_definition();
      init_directives();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
  function ScalarLeafsRule(context) {
    return {
      Field(node) {
        const type = context.getType();
        const selectionSet = node.selectionSet;
        if (type) {
          if (isLeafType(getNamedType(type))) {
            if (selectionSet) {
              const fieldName = node.name.value;
              const typeStr = inspect(type);
              context.reportError(
                new GraphQLError(
                  `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                  {
                    nodes: selectionSet
                  }
                )
              );
            }
          } else if (!selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      }
    };
  }
  var init_ScalarLeafsRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_GraphQLError();
      init_definition();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/printPathArray.mjs
  function printPathArray(path) {
    return path.map(
      (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
    ).join("");
  }
  var init_printPathArray = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/printPathArray.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/Path.mjs
  function addPath(prev, key, typename) {
    return {
      prev,
      key,
      typename
    };
  }
  function pathToArray(path) {
    const flattened = [];
    let curr = path;
    while (curr) {
      flattened.push(curr.key);
      curr = curr.prev;
    }
    return flattened.reverse();
  }
  var init_Path = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/Path.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/coerceInputValue.mjs
  function coerceInputValue(inputValue, type, onError = defaultOnError) {
    return coerceInputValueImpl(inputValue, type, onError, void 0);
  }
  function defaultOnError(path, invalidValue, error) {
    let errorPrefix = "Invalid value " + inspect(invalidValue);
    if (path.length > 0) {
      errorPrefix += ` at "value${printPathArray(path)}"`;
    }
    error.message = errorPrefix + ": " + error.message;
    throw error;
  }
  function coerceInputValueImpl(inputValue, type, onError, path) {
    if (isNonNullType(type)) {
      if (inputValue != null) {
        return coerceInputValueImpl(inputValue, type.ofType, onError, path);
      }
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(
          `Expected non-nullable type "${inspect(type)}" not to be null.`
        )
      );
      return;
    }
    if (inputValue == null) {
      return null;
    }
    if (isListType(type)) {
      const itemType = type.ofType;
      if (isIterableObject(inputValue)) {
        return Array.from(inputValue, (itemValue, index) => {
          const itemPath = addPath(path, index, void 0);
          return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
        });
      }
      return [coerceInputValueImpl(inputValue, itemType, onError, path)];
    }
    if (isInputObjectType(type)) {
      if (!isObjectLike(inputValue)) {
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(`Expected type "${type.name}" to be an object.`)
        );
        return;
      }
      const coercedValue = {};
      const fieldDefs = type.getFields();
      for (const field of Object.values(fieldDefs)) {
        const fieldValue = inputValue[field.name];
        if (fieldValue === void 0) {
          if (field.defaultValue !== void 0) {
            coercedValue[field.name] = field.defaultValue;
          } else if (isNonNullType(field.type)) {
            const typeStr = inspect(field.type);
            onError(
              pathToArray(path),
              inputValue,
              new GraphQLError(
                `Field "${field.name}" of required type "${typeStr}" was not provided.`
              )
            );
          }
          continue;
        }
        coercedValue[field.name] = coerceInputValueImpl(
          fieldValue,
          field.type,
          onError,
          addPath(path, field.name, type.name)
        );
      }
      for (const fieldName of Object.keys(inputValue)) {
        if (!fieldDefs[fieldName]) {
          const suggestions = suggestionList(
            fieldName,
            Object.keys(type.getFields())
          );
          onError(
            pathToArray(path),
            inputValue,
            new GraphQLError(
              `Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)
            )
          );
        }
      }
      return coercedValue;
    }
    if (isLeafType(type)) {
      let parseResult;
      try {
        parseResult = type.parseValue(inputValue);
      } catch (error) {
        if (error instanceof GraphQLError) {
          onError(pathToArray(path), inputValue, error);
        } else {
          onError(
            pathToArray(path),
            inputValue,
            new GraphQLError(`Expected type "${type.name}". ` + error.message, {
              originalError: error
            })
          );
        }
        return;
      }
      if (parseResult === void 0) {
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(`Expected type "${type.name}".`)
        );
      }
      return parseResult;
    }
    invariant(false, "Unexpected input type: " + inspect(type));
  }
  var init_coerceInputValue = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/coerceInputValue.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_didYouMean();
      init_inspect();
      init_invariant();
      init_isIterableObject();
      init_isObjectLike();
      init_Path();
      init_printPathArray();
      init_suggestionList();
      init_GraphQLError();
      init_definition();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/valueFromAST.mjs
  function valueFromAST(valueNode, type, variables) {
    if (!valueNode) {
      return;
    }
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variables == null || variables[variableName] === void 0) {
        return;
      }
      const variableValue = variables[variableName];
      if (variableValue === null && isNonNullType(type)) {
        return;
      }
      return variableValue;
    }
    if (isNonNullType(type)) {
      if (valueNode.kind === Kind.NULL) {
        return;
      }
      return valueFromAST(valueNode, type.ofType, variables);
    }
    if (valueNode.kind === Kind.NULL) {
      return null;
    }
    if (isListType(type)) {
      const itemType = type.ofType;
      if (valueNode.kind === Kind.LIST) {
        const coercedValues = [];
        for (const itemNode of valueNode.values) {
          if (isMissingVariable(itemNode, variables)) {
            if (isNonNullType(itemType)) {
              return;
            }
            coercedValues.push(null);
          } else {
            const itemValue = valueFromAST(itemNode, itemType, variables);
            if (itemValue === void 0) {
              return;
            }
            coercedValues.push(itemValue);
          }
        }
        return coercedValues;
      }
      const coercedValue = valueFromAST(valueNode, itemType, variables);
      if (coercedValue === void 0) {
        return;
      }
      return [coercedValue];
    }
    if (isInputObjectType(type)) {
      if (valueNode.kind !== Kind.OBJECT) {
        return;
      }
      const coercedObj = /* @__PURE__ */ Object.create(null);
      const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
      for (const field of Object.values(type.getFields())) {
        const fieldNode = fieldNodes[field.name];
        if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
          if (field.defaultValue !== void 0) {
            coercedObj[field.name] = field.defaultValue;
          } else if (isNonNullType(field.type)) {
            return;
          }
          continue;
        }
        const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
        if (fieldValue === void 0) {
          return;
        }
        coercedObj[field.name] = fieldValue;
      }
      return coercedObj;
    }
    if (isLeafType(type)) {
      let result;
      try {
        result = type.parseLiteral(valueNode, variables);
      } catch (_error) {
        return;
      }
      if (result === void 0) {
        return;
      }
      return result;
    }
    invariant(false, "Unexpected input type: " + inspect(type));
  }
  function isMissingVariable(valueNode, variables) {
    return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
  }
  var init_valueFromAST = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/valueFromAST.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_invariant();
      init_keyMap();
      init_kinds();
      init_definition();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/values.mjs
  function getVariableValues(schema, varDefNodes, inputs, options) {
    const errors = [];
    const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
    try {
      const coerced = coerceVariableValues(
        schema,
        varDefNodes,
        inputs,
        (error) => {
          if (maxErrors != null && errors.length >= maxErrors) {
            throw new GraphQLError(
              "Too many errors processing variables, error limit reached. Execution aborted."
            );
          }
          errors.push(error);
        }
      );
      if (errors.length === 0) {
        return {
          coerced
        };
      }
    } catch (error) {
      errors.push(error);
    }
    return {
      errors
    };
  }
  function coerceVariableValues(schema, varDefNodes, inputs, onError) {
    const coercedValues = {};
    for (const varDefNode of varDefNodes) {
      const varName = varDefNode.variable.name.value;
      const varType = typeFromAST(schema, varDefNode.type);
      if (!isInputType(varType)) {
        const varTypeStr = print(varDefNode.type);
        onError(
          new GraphQLError(
            `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
            {
              nodes: varDefNode.type
            }
          )
        );
        continue;
      }
      if (!hasOwnProperty(inputs, varName)) {
        if (varDefNode.defaultValue) {
          coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
        } else if (isNonNullType(varType)) {
          const varTypeStr = inspect(varType);
          onError(
            new GraphQLError(
              `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
              {
                nodes: varDefNode
              }
            )
          );
        }
        continue;
      }
      const value = inputs[varName];
      if (value === null && isNonNullType(varType)) {
        const varTypeStr = inspect(varType);
        onError(
          new GraphQLError(
            `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
            {
              nodes: varDefNode
            }
          )
        );
        continue;
      }
      coercedValues[varName] = coerceInputValue(
        value,
        varType,
        (path, invalidValue, error) => {
          let prefix = `Variable "$${varName}" got invalid value ` + inspect(invalidValue);
          if (path.length > 0) {
            prefix += ` at "${varName}${printPathArray(path)}"`;
          }
          onError(
            new GraphQLError(prefix + "; " + error.message, {
              nodes: varDefNode,
              originalError: error
            })
          );
        }
      );
    }
    return coercedValues;
  }
  function getArgumentValues(def, node, variableValues) {
    var _node$arguments;
    const coercedValues = {};
    const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
    const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
    for (const argDef of def.args) {
      const name2 = argDef.name;
      const argType = argDef.type;
      const argumentNode = argNodeMap[name2];
      if (!argumentNode) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name2] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name2}" of required type "${inspect(argType)}" was not provided.`,
            {
              nodes: node
            }
          );
        }
        continue;
      }
      const valueNode = argumentNode.value;
      let isNull = valueNode.kind === Kind.NULL;
      if (valueNode.kind === Kind.VARIABLE) {
        const variableName = valueNode.name.value;
        if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
          if (argDef.defaultValue !== void 0) {
            coercedValues[name2] = argDef.defaultValue;
          } else if (isNonNullType(argType)) {
            throw new GraphQLError(
              `Argument "${name2}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
              {
                nodes: valueNode
              }
            );
          }
          continue;
        }
        isNull = variableValues[variableName] == null;
      }
      if (isNull && isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name2}" of non-null type "${inspect(argType)}" must not be null.`,
          {
            nodes: valueNode
          }
        );
      }
      const coercedValue = valueFromAST(valueNode, argType, variableValues);
      if (coercedValue === void 0) {
        throw new GraphQLError(
          `Argument "${name2}" has invalid value ${print(valueNode)}.`,
          {
            nodes: valueNode
          }
        );
      }
      coercedValues[name2] = coercedValue;
    }
    return coercedValues;
  }
  function getDirectiveValues(directiveDef, node, variableValues) {
    var _node$directives;
    const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
      (directive) => directive.name.value === directiveDef.name
    );
    if (directiveNode) {
      return getArgumentValues(directiveDef, directiveNode, variableValues);
    }
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var init_values = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/values.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_keyMap();
      init_printPathArray();
      init_GraphQLError();
      init_kinds();
      init_printer();
      init_definition();
      init_coerceInputValue();
      init_typeFromAST();
      init_valueFromAST();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/collectFields.mjs
  function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
    const fields = /* @__PURE__ */ new Map();
    collectFieldsImpl(
      schema,
      fragments,
      variableValues,
      runtimeType,
      selectionSet,
      fields,
      /* @__PURE__ */ new Set()
    );
    return fields;
  }
  function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
    const subFieldNodes = /* @__PURE__ */ new Map();
    const visitedFragmentNames = /* @__PURE__ */ new Set();
    for (const node of fieldNodes) {
      if (node.selectionSet) {
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          returnType,
          node.selectionSet,
          subFieldNodes,
          visitedFragmentNames
        );
      }
    }
    return subFieldNodes;
  }
  function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (const selection of selectionSet.selections) {
      switch (selection.kind) {
        case Kind.FIELD: {
          if (!shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          const name2 = getFieldEntryKey(selection);
          const fieldList = fields.get(name2);
          if (fieldList !== void 0) {
            fieldList.push(selection);
          } else {
            fields.set(name2, [selection]);
          }
          break;
        }
        case Kind.INLINE_FRAGMENT: {
          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
            continue;
          }
          collectFieldsImpl(
            schema,
            fragments,
            variableValues,
            runtimeType,
            selection.selectionSet,
            fields,
            visitedFragmentNames
          );
          break;
        }
        case Kind.FRAGMENT_SPREAD: {
          const fragName = selection.name.value;
          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
            continue;
          }
          visitedFragmentNames.add(fragName);
          const fragment = fragments[fragName];
          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
            continue;
          }
          collectFieldsImpl(
            schema,
            fragments,
            variableValues,
            runtimeType,
            fragment.selectionSet,
            fields,
            visitedFragmentNames
          );
          break;
        }
      }
    }
  }
  function shouldIncludeNode(variableValues, node) {
    const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
    if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
      return false;
    }
    const include = getDirectiveValues(
      GraphQLIncludeDirective,
      node,
      variableValues
    );
    if ((include === null || include === void 0 ? void 0 : include.if) === false) {
      return false;
    }
    return true;
  }
  function doesFragmentConditionMatch(schema, fragment, type) {
    const typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
      return true;
    }
    const conditionalType = typeFromAST(schema, typeConditionNode);
    if (conditionalType === type) {
      return true;
    }
    if (isAbstractType(conditionalType)) {
      return schema.isSubType(conditionalType, type);
    }
    return false;
  }
  function getFieldEntryKey(node) {
    return node.alias ? node.alias.value : node.name.value;
  }
  var init_collectFields = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/collectFields.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_kinds();
      init_definition();
      init_directives();
      init_typeFromAST();
      init_values();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
  function SingleFieldSubscriptionsRule(context) {
    return {
      OperationDefinition(node) {
        if (node.operation === "subscription") {
          const schema = context.getSchema();
          const subscriptionType = schema.getSubscriptionType();
          if (subscriptionType) {
            const operationName = node.name ? node.name.value : null;
            const variableValues = /* @__PURE__ */ Object.create(null);
            const document = context.getDocument();
            const fragments = /* @__PURE__ */ Object.create(null);
            for (const definition of document.definitions) {
              if (definition.kind === Kind.FRAGMENT_DEFINITION) {
                fragments[definition.name.value] = definition;
              }
            }
            const fields = collectFields(
              schema,
              fragments,
              variableValues,
              subscriptionType,
              node.selectionSet
            );
            if (fields.size > 1) {
              const fieldSelectionLists = [...fields.values()];
              const extraFieldSelectionLists = fieldSelectionLists.slice(1);
              const extraFieldSelections = extraFieldSelectionLists.flat();
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                  {
                    nodes: extraFieldSelections
                  }
                )
              );
            }
            for (const fieldNodes of fields.values()) {
              const field = fieldNodes[0];
              const fieldName = field.name.value;
              if (fieldName.startsWith("__")) {
                context.reportError(
                  new GraphQLError(
                    operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                    {
                      nodes: fieldNodes
                    }
                  )
                );
              }
            }
          }
        }
      }
    };
  }
  var init_SingleFieldSubscriptionsRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
      init_kinds();
      init_collectFields();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/groupBy.mjs
  function groupBy(list, keyFn) {
    const result = /* @__PURE__ */ new Map();
    for (const item of list) {
      const key = keyFn(item);
      const group = result.get(key);
      if (group === void 0) {
        result.set(key, [item]);
      } else {
        group.push(item);
      }
    }
    return result;
  }
  var init_groupBy = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/groupBy.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
  function UniqueArgumentDefinitionNamesRule(context) {
    return {
      DirectiveDefinition(directiveNode) {
        var _directiveNode$argume;
        const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
        return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
      },
      InterfaceTypeDefinition: checkArgUniquenessPerField,
      InterfaceTypeExtension: checkArgUniquenessPerField,
      ObjectTypeDefinition: checkArgUniquenessPerField,
      ObjectTypeExtension: checkArgUniquenessPerField
    };
    function checkArgUniquenessPerField(typeNode) {
      var _typeNode$fields;
      const typeName = typeNode.name.value;
      const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
      for (const fieldDef of fieldNodes) {
        var _fieldDef$arguments;
        const fieldName = fieldDef.name.value;
        const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
        checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
      }
      return false;
    }
    function checkArgUniqueness(parentName, argumentNodes) {
      const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
      for (const [argName, argNodes] of seenArgs) {
        if (argNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `Argument "${parentName}(${argName}:)" can only be defined once.`,
              {
                nodes: argNodes.map((node) => node.name)
              }
            )
          );
        }
      }
      return false;
    }
  }
  var init_UniqueArgumentDefinitionNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_groupBy();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
  function UniqueArgumentNamesRule(context) {
    return {
      Field: checkArgUniqueness,
      Directive: checkArgUniqueness
    };
    function checkArgUniqueness(parentNode) {
      var _parentNode$arguments;
      const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
      const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
      for (const [argName, argNodes] of seenArgs) {
        if (argNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one argument named "${argName}".`,
              {
                nodes: argNodes.map((node) => node.name)
              }
            )
          );
        }
      }
    }
  }
  var init_UniqueArgumentNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_groupBy();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
  function UniqueDirectiveNamesRule(context) {
    const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    return {
      DirectiveDefinition(node) {
        const directiveName = node.name.value;
        if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
          context.reportError(
            new GraphQLError(
              `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
              {
                nodes: node.name
              }
            )
          );
          return;
        }
        if (knownDirectiveNames[directiveName]) {
          context.reportError(
            new GraphQLError(
              `There can be only one directive named "@${directiveName}".`,
              {
                nodes: [knownDirectiveNames[directiveName], node.name]
              }
            )
          );
        } else {
          knownDirectiveNames[directiveName] = node.name;
        }
        return false;
      }
    };
  }
  var init_UniqueDirectiveNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
  function UniqueDirectivesPerLocationRule(context) {
    const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
    for (const directive of definedDirectives) {
      uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
    }
    const astDefinitions = context.getDocument().definitions;
    for (const def of astDefinitions) {
      if (def.kind === Kind.DIRECTIVE_DEFINITION) {
        uniqueDirectiveMap[def.name.value] = !def.repeatable;
      }
    }
    const schemaDirectives = /* @__PURE__ */ Object.create(null);
    const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
    return {
      // Many different AST nodes may contain directives. Rather than listing
      // them all, just listen for entering any node, and check to see if it
      // defines any directives.
      enter(node) {
        if (!("directives" in node) || !node.directives) {
          return;
        }
        let seenDirectives;
        if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
          seenDirectives = schemaDirectives;
        } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
          const typeName = node.name.value;
          seenDirectives = typeDirectivesMap[typeName];
          if (seenDirectives === void 0) {
            typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
          }
        } else {
          seenDirectives = /* @__PURE__ */ Object.create(null);
        }
        for (const directive of node.directives) {
          const directiveName = directive.name.value;
          if (uniqueDirectiveMap[directiveName]) {
            if (seenDirectives[directiveName]) {
              context.reportError(
                new GraphQLError(
                  `The directive "@${directiveName}" can only be used once at this location.`,
                  {
                    nodes: [seenDirectives[directiveName], directive]
                  }
                )
              );
            } else {
              seenDirectives[directiveName] = directive;
            }
          }
        }
      }
    };
  }
  var init_UniqueDirectivesPerLocationRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
      init_kinds();
      init_predicates();
      init_directives();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
  function UniqueEnumValueNamesRule(context) {
    const schema = context.getSchema();
    const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
    const knownValueNames = /* @__PURE__ */ Object.create(null);
    return {
      EnumTypeDefinition: checkValueUniqueness,
      EnumTypeExtension: checkValueUniqueness
    };
    function checkValueUniqueness(node) {
      var _node$values;
      const typeName = node.name.value;
      if (!knownValueNames[typeName]) {
        knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
      }
      const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
      const valueNames = knownValueNames[typeName];
      for (const valueDef of valueNodes) {
        const valueName = valueDef.name.value;
        const existingType = existingTypeMap[typeName];
        if (isEnumType(existingType) && existingType.getValue(valueName)) {
          context.reportError(
            new GraphQLError(
              `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
              {
                nodes: valueDef.name
              }
            )
          );
        } else if (valueNames[valueName]) {
          context.reportError(
            new GraphQLError(
              `Enum value "${typeName}.${valueName}" can only be defined once.`,
              {
                nodes: [valueNames[valueName], valueDef.name]
              }
            )
          );
        } else {
          valueNames[valueName] = valueDef.name;
        }
      }
      return false;
    }
  }
  var init_UniqueEnumValueNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
      init_definition();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
  function UniqueFieldDefinitionNamesRule(context) {
    const schema = context.getSchema();
    const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
    const knownFieldNames = /* @__PURE__ */ Object.create(null);
    return {
      InputObjectTypeDefinition: checkFieldUniqueness,
      InputObjectTypeExtension: checkFieldUniqueness,
      InterfaceTypeDefinition: checkFieldUniqueness,
      InterfaceTypeExtension: checkFieldUniqueness,
      ObjectTypeDefinition: checkFieldUniqueness,
      ObjectTypeExtension: checkFieldUniqueness
    };
    function checkFieldUniqueness(node) {
      var _node$fields;
      const typeName = node.name.value;
      if (!knownFieldNames[typeName]) {
        knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
      }
      const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
      const fieldNames = knownFieldNames[typeName];
      for (const fieldDef of fieldNodes) {
        const fieldName = fieldDef.name.value;
        if (hasField(existingTypeMap[typeName], fieldName)) {
          context.reportError(
            new GraphQLError(
              `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
              {
                nodes: fieldDef.name
              }
            )
          );
        } else if (fieldNames[fieldName]) {
          context.reportError(
            new GraphQLError(
              `Field "${typeName}.${fieldName}" can only be defined once.`,
              {
                nodes: [fieldNames[fieldName], fieldDef.name]
              }
            )
          );
        } else {
          fieldNames[fieldName] = fieldDef.name;
        }
      }
      return false;
    }
  }
  function hasField(type, fieldName) {
    if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
      return type.getFields()[fieldName] != null;
    }
    return false;
  }
  var init_UniqueFieldDefinitionNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
      init_definition();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
  function UniqueFragmentNamesRule(context) {
    const knownFragmentNames = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: () => false,
      FragmentDefinition(node) {
        const fragmentName = node.name.value;
        if (knownFragmentNames[fragmentName]) {
          context.reportError(
            new GraphQLError(
              `There can be only one fragment named "${fragmentName}".`,
              {
                nodes: [knownFragmentNames[fragmentName], node.name]
              }
            )
          );
        } else {
          knownFragmentNames[fragmentName] = node.name;
        }
        return false;
      }
    };
  }
  var init_UniqueFragmentNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
  function UniqueInputFieldNamesRule(context) {
    const knownNameStack = [];
    let knownNames = /* @__PURE__ */ Object.create(null);
    return {
      ObjectValue: {
        enter() {
          knownNameStack.push(knownNames);
          knownNames = /* @__PURE__ */ Object.create(null);
        },
        leave() {
          const prevKnownNames = knownNameStack.pop();
          prevKnownNames || invariant(false);
          knownNames = prevKnownNames;
        }
      },
      ObjectField(node) {
        const fieldName = node.name.value;
        if (knownNames[fieldName]) {
          context.reportError(
            new GraphQLError(
              `There can be only one input field named "${fieldName}".`,
              {
                nodes: [knownNames[fieldName], node.name]
              }
            )
          );
        } else {
          knownNames[fieldName] = node.name;
        }
      }
    };
  }
  var init_UniqueInputFieldNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_invariant();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
  function UniqueOperationNamesRule(context) {
    const knownOperationNames = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition(node) {
        const operationName = node.name;
        if (operationName) {
          if (knownOperationNames[operationName.value]) {
            context.reportError(
              new GraphQLError(
                `There can be only one operation named "${operationName.value}".`,
                {
                  nodes: [
                    knownOperationNames[operationName.value],
                    operationName
                  ]
                }
              )
            );
          } else {
            knownOperationNames[operationName.value] = operationName;
          }
        }
        return false;
      },
      FragmentDefinition: () => false
    };
  }
  var init_UniqueOperationNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
  function UniqueOperationTypesRule(context) {
    const schema = context.getSchema();
    const definedOperationTypes = /* @__PURE__ */ Object.create(null);
    const existingOperationTypes = schema ? {
      query: schema.getQueryType(),
      mutation: schema.getMutationType(),
      subscription: schema.getSubscriptionType()
    } : {};
    return {
      SchemaDefinition: checkOperationTypes,
      SchemaExtension: checkOperationTypes
    };
    function checkOperationTypes(node) {
      var _node$operationTypes;
      const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
      for (const operationType of operationTypesNodes) {
        const operation = operationType.operation;
        const alreadyDefinedOperationType = definedOperationTypes[operation];
        if (existingOperationTypes[operation]) {
          context.reportError(
            new GraphQLError(
              `Type for ${operation} already defined in the schema. It cannot be redefined.`,
              {
                nodes: operationType
              }
            )
          );
        } else if (alreadyDefinedOperationType) {
          context.reportError(
            new GraphQLError(
              `There can be only one ${operation} type in schema.`,
              {
                nodes: [alreadyDefinedOperationType, operationType]
              }
            )
          );
        } else {
          definedOperationTypes[operation] = operationType;
        }
      }
      return false;
    }
  }
  var init_UniqueOperationTypesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
  function UniqueTypeNamesRule(context) {
    const knownTypeNames = /* @__PURE__ */ Object.create(null);
    const schema = context.getSchema();
    return {
      ScalarTypeDefinition: checkTypeName,
      ObjectTypeDefinition: checkTypeName,
      InterfaceTypeDefinition: checkTypeName,
      UnionTypeDefinition: checkTypeName,
      EnumTypeDefinition: checkTypeName,
      InputObjectTypeDefinition: checkTypeName
    };
    function checkTypeName(node) {
      const typeName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
        context.reportError(
          new GraphQLError(
            `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownTypeNames[typeName]) {
        context.reportError(
          new GraphQLError(`There can be only one type named "${typeName}".`, {
            nodes: [knownTypeNames[typeName], node.name]
          })
        );
      } else {
        knownTypeNames[typeName] = node.name;
      }
      return false;
    }
  }
  var init_UniqueTypeNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
  function UniqueVariableNamesRule(context) {
    return {
      OperationDefinition(operationNode) {
        var _operationNode$variab;
        const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
        const seenVariableDefinitions = groupBy(
          variableDefinitions,
          (node) => node.variable.name.value
        );
        for (const [variableName, variableNodes] of seenVariableDefinitions) {
          if (variableNodes.length > 1) {
            context.reportError(
              new GraphQLError(
                `There can be only one variable named "$${variableName}".`,
                {
                  nodes: variableNodes.map((node) => node.variable.name)
                }
              )
            );
          }
        }
      }
    };
  }
  var init_UniqueVariableNamesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_groupBy();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
  function ValuesOfCorrectTypeRule(context) {
    return {
      ListValue(node) {
        const type = getNullableType(context.getParentInputType());
        if (!isListType(type)) {
          isValidValueNode(context, node);
          return false;
        }
      },
      ObjectValue(node) {
        const type = getNamedType(context.getInputType());
        if (!isInputObjectType(type)) {
          isValidValueNode(context, node);
          return false;
        }
        const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
        for (const fieldDef of Object.values(type.getFields())) {
          const fieldNode = fieldNodeMap[fieldDef.name];
          if (!fieldNode && isRequiredInputField(fieldDef)) {
            const typeStr = inspect(fieldDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      },
      ObjectField(node) {
        const parentType = getNamedType(context.getParentInputType());
        const fieldType = context.getInputType();
        if (!fieldType && isInputObjectType(parentType)) {
          const suggestions = suggestionList(
            node.name.value,
            Object.keys(parentType.getFields())
          );
          context.reportError(
            new GraphQLError(
              `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
              {
                nodes: node
              }
            )
          );
        }
      },
      NullValue(node) {
        const type = context.getInputType();
        if (isNonNullType(type)) {
          context.reportError(
            new GraphQLError(
              `Expected value of type "${inspect(type)}", found ${print(node)}.`,
              {
                nodes: node
              }
            )
          );
        }
      },
      EnumValue: (node) => isValidValueNode(context, node),
      IntValue: (node) => isValidValueNode(context, node),
      FloatValue: (node) => isValidValueNode(context, node),
      StringValue: (node) => isValidValueNode(context, node),
      BooleanValue: (node) => isValidValueNode(context, node)
    };
  }
  function isValidValueNode(context, node) {
    const locationType = context.getInputType();
    if (!locationType) {
      return;
    }
    const type = getNamedType(locationType);
    if (!isLeafType(type)) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
      return;
    }
    try {
      const parseResult = type.parseLiteral(
        node,
        void 0
        /* variables */
      );
      if (parseResult === void 0) {
        const typeStr = inspect(locationType);
        context.reportError(
          new GraphQLError(
            `Expected value of type "${typeStr}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    } catch (error) {
      const typeStr = inspect(locationType);
      if (error instanceof GraphQLError) {
        context.reportError(error);
      } else {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
            {
              nodes: node,
              originalError: error
            }
          )
        );
      }
    }
  }
  var init_ValuesOfCorrectTypeRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_didYouMean();
      init_inspect();
      init_keyMap();
      init_suggestionList();
      init_GraphQLError();
      init_printer();
      init_definition();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
  function VariablesAreInputTypesRule(context) {
    return {
      VariableDefinition(node) {
        const type = typeFromAST(context.getSchema(), node.type);
        if (type !== void 0 && !isInputType(type)) {
          const variableName = node.variable.name.value;
          const typeName = print(node.type);
          context.reportError(
            new GraphQLError(
              `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
              {
                nodes: node.type
              }
            )
          );
        }
      }
    };
  }
  var init_VariablesAreInputTypesRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
      init_printer();
      init_definition();
      init_typeFromAST();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
  function VariablesInAllowedPositionRule(context) {
    let varDefMap = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          varDefMap = /* @__PURE__ */ Object.create(null);
        },
        leave(operation) {
          const usages = context.getRecursiveVariableUsages(operation);
          for (const { node, type, defaultValue } of usages) {
            const varName = node.name.value;
            const varDef = varDefMap[varName];
            if (varDef && type) {
              const schema = context.getSchema();
              const varType = typeFromAST(schema, varDef.type);
              if (varType && !allowedVariableUsage(
                schema,
                varType,
                varDef.defaultValue,
                type,
                defaultValue
              )) {
                const varTypeStr = inspect(varType);
                const typeStr = inspect(type);
                context.reportError(
                  new GraphQLError(
                    `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                    {
                      nodes: [varDef, node]
                    }
                  )
                );
              }
            }
          }
        }
      },
      VariableDefinition(node) {
        varDefMap[node.variable.name.value] = node;
      }
    };
  }
  function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
    if (isNonNullType(locationType) && !isNonNullType(varType)) {
      const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
      const hasLocationDefaultValue = locationDefaultValue !== void 0;
      if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
        return false;
      }
      const nullableLocationType = locationType.ofType;
      return isTypeSubTypeOf(schema, varType, nullableLocationType);
    }
    return isTypeSubTypeOf(schema, varType, locationType);
  }
  var init_VariablesInAllowedPositionRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_GraphQLError();
      init_kinds();
      init_definition();
      init_typeComparators();
      init_typeFromAST();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/specifiedRules.mjs
  var specifiedRules, specifiedSDLRules;
  var init_specifiedRules = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/specifiedRules.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_ExecutableDefinitionsRule();
      init_FieldsOnCorrectTypeRule();
      init_FragmentsOnCompositeTypesRule();
      init_KnownArgumentNamesRule();
      init_KnownDirectivesRule();
      init_KnownFragmentNamesRule();
      init_KnownTypeNamesRule();
      init_LoneAnonymousOperationRule();
      init_LoneSchemaDefinitionRule();
      init_NoFragmentCyclesRule();
      init_NoUndefinedVariablesRule();
      init_NoUnusedFragmentsRule();
      init_NoUnusedVariablesRule();
      init_OverlappingFieldsCanBeMergedRule();
      init_PossibleFragmentSpreadsRule();
      init_PossibleTypeExtensionsRule();
      init_ProvidedRequiredArgumentsRule();
      init_ScalarLeafsRule();
      init_SingleFieldSubscriptionsRule();
      init_UniqueArgumentDefinitionNamesRule();
      init_UniqueArgumentNamesRule();
      init_UniqueDirectiveNamesRule();
      init_UniqueDirectivesPerLocationRule();
      init_UniqueEnumValueNamesRule();
      init_UniqueFieldDefinitionNamesRule();
      init_UniqueFragmentNamesRule();
      init_UniqueInputFieldNamesRule();
      init_UniqueOperationNamesRule();
      init_UniqueOperationTypesRule();
      init_UniqueTypeNamesRule();
      init_UniqueVariableNamesRule();
      init_ValuesOfCorrectTypeRule();
      init_VariablesAreInputTypesRule();
      init_VariablesInAllowedPositionRule();
      specifiedRules = Object.freeze([
        ExecutableDefinitionsRule,
        UniqueOperationNamesRule,
        LoneAnonymousOperationRule,
        SingleFieldSubscriptionsRule,
        KnownTypeNamesRule,
        FragmentsOnCompositeTypesRule,
        VariablesAreInputTypesRule,
        ScalarLeafsRule,
        FieldsOnCorrectTypeRule,
        UniqueFragmentNamesRule,
        KnownFragmentNamesRule,
        NoUnusedFragmentsRule,
        PossibleFragmentSpreadsRule,
        NoFragmentCyclesRule,
        UniqueVariableNamesRule,
        NoUndefinedVariablesRule,
        NoUnusedVariablesRule,
        KnownDirectivesRule,
        UniqueDirectivesPerLocationRule,
        KnownArgumentNamesRule,
        UniqueArgumentNamesRule,
        ValuesOfCorrectTypeRule,
        ProvidedRequiredArgumentsRule,
        VariablesInAllowedPositionRule,
        OverlappingFieldsCanBeMergedRule,
        UniqueInputFieldNamesRule
      ]);
      specifiedSDLRules = Object.freeze([
        LoneSchemaDefinitionRule,
        UniqueOperationTypesRule,
        UniqueTypeNamesRule,
        UniqueEnumValueNamesRule,
        UniqueFieldDefinitionNamesRule,
        UniqueArgumentDefinitionNamesRule,
        UniqueDirectiveNamesRule,
        KnownTypeNamesRule,
        KnownDirectivesRule,
        UniqueDirectivesPerLocationRule,
        PossibleTypeExtensionsRule,
        KnownArgumentNamesOnDirectivesRule,
        UniqueArgumentNamesRule,
        UniqueInputFieldNamesRule,
        ProvidedRequiredArgumentsOnDirectivesRule
      ]);
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/ValidationContext.mjs
  var ASTValidationContext, SDLValidationContext, ValidationContext;
  var init_ValidationContext = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/ValidationContext.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_kinds();
      init_visitor();
      init_TypeInfo();
      ASTValidationContext = class {
        constructor(ast, onError) {
          this._ast = ast;
          this._fragments = void 0;
          this._fragmentSpreads = /* @__PURE__ */ new Map();
          this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
          this._onError = onError;
        }
        get [Symbol.toStringTag]() {
          return "ASTValidationContext";
        }
        reportError(error) {
          this._onError(error);
        }
        getDocument() {
          return this._ast;
        }
        getFragment(name2) {
          let fragments;
          if (this._fragments) {
            fragments = this._fragments;
          } else {
            fragments = /* @__PURE__ */ Object.create(null);
            for (const defNode of this.getDocument().definitions) {
              if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
                fragments[defNode.name.value] = defNode;
              }
            }
            this._fragments = fragments;
          }
          return fragments[name2];
        }
        getFragmentSpreads(node) {
          let spreads = this._fragmentSpreads.get(node);
          if (!spreads) {
            spreads = [];
            const setsToVisit = [node];
            let set;
            while (set = setsToVisit.pop()) {
              for (const selection of set.selections) {
                if (selection.kind === Kind.FRAGMENT_SPREAD) {
                  spreads.push(selection);
                } else if (selection.selectionSet) {
                  setsToVisit.push(selection.selectionSet);
                }
              }
            }
            this._fragmentSpreads.set(node, spreads);
          }
          return spreads;
        }
        getRecursivelyReferencedFragments(operation) {
          let fragments = this._recursivelyReferencedFragments.get(operation);
          if (!fragments) {
            fragments = [];
            const collectedNames = /* @__PURE__ */ Object.create(null);
            const nodesToVisit = [operation.selectionSet];
            let node;
            while (node = nodesToVisit.pop()) {
              for (const spread of this.getFragmentSpreads(node)) {
                const fragName = spread.name.value;
                if (collectedNames[fragName] !== true) {
                  collectedNames[fragName] = true;
                  const fragment = this.getFragment(fragName);
                  if (fragment) {
                    fragments.push(fragment);
                    nodesToVisit.push(fragment.selectionSet);
                  }
                }
              }
            }
            this._recursivelyReferencedFragments.set(operation, fragments);
          }
          return fragments;
        }
      };
      SDLValidationContext = class extends ASTValidationContext {
        constructor(ast, schema, onError) {
          super(ast, onError);
          this._schema = schema;
        }
        get [Symbol.toStringTag]() {
          return "SDLValidationContext";
        }
        getSchema() {
          return this._schema;
        }
      };
      ValidationContext = class extends ASTValidationContext {
        constructor(schema, ast, typeInfo, onError) {
          super(ast, onError);
          this._schema = schema;
          this._typeInfo = typeInfo;
          this._variableUsages = /* @__PURE__ */ new Map();
          this._recursiveVariableUsages = /* @__PURE__ */ new Map();
        }
        get [Symbol.toStringTag]() {
          return "ValidationContext";
        }
        getSchema() {
          return this._schema;
        }
        getVariableUsages(node) {
          let usages = this._variableUsages.get(node);
          if (!usages) {
            const newUsages = [];
            const typeInfo = new TypeInfo(this._schema);
            visit(
              node,
              visitWithTypeInfo(typeInfo, {
                VariableDefinition: () => false,
                Variable(variable) {
                  newUsages.push({
                    node: variable,
                    type: typeInfo.getInputType(),
                    defaultValue: typeInfo.getDefaultValue()
                  });
                }
              })
            );
            usages = newUsages;
            this._variableUsages.set(node, usages);
          }
          return usages;
        }
        getRecursiveVariableUsages(operation) {
          let usages = this._recursiveVariableUsages.get(operation);
          if (!usages) {
            usages = this.getVariableUsages(operation);
            for (const frag of this.getRecursivelyReferencedFragments(operation)) {
              usages = usages.concat(this.getVariableUsages(frag));
            }
            this._recursiveVariableUsages.set(operation, usages);
          }
          return usages;
        }
        getType() {
          return this._typeInfo.getType();
        }
        getParentType() {
          return this._typeInfo.getParentType();
        }
        getInputType() {
          return this._typeInfo.getInputType();
        }
        getParentInputType() {
          return this._typeInfo.getParentInputType();
        }
        getFieldDef() {
          return this._typeInfo.getFieldDef();
        }
        getDirective() {
          return this._typeInfo.getDirective();
        }
        getArgument() {
          return this._typeInfo.getArgument();
        }
        getEnumValue() {
          return this._typeInfo.getEnumValue();
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/validate.mjs
  function validate(schema, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema)) {
    var _options$maxErrors;
    const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
    documentAST || devAssert(false, "Must provide document.");
    assertValidSchema(schema);
    const abortObj = Object.freeze({});
    const errors = [];
    const context = new ValidationContext(
      schema,
      documentAST,
      typeInfo,
      (error) => {
        if (errors.length >= maxErrors) {
          errors.push(
            new GraphQLError(
              "Too many validation errors, error limit reached. Validation aborted."
            )
          );
          throw abortObj;
        }
        errors.push(error);
      }
    );
    const visitor = visitInParallel(rules.map((rule) => rule(context)));
    try {
      visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
    } catch (e2) {
      if (e2 !== abortObj) {
        throw e2;
      }
    }
    return errors;
  }
  function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules) {
    const errors = [];
    const context = new SDLValidationContext(
      documentAST,
      schemaToExtend,
      (error) => {
        errors.push(error);
      }
    );
    const visitors = rules.map((rule) => rule(context));
    visit(documentAST, visitInParallel(visitors));
    return errors;
  }
  function assertValidSDL(documentAST) {
    const errors = validateSDL(documentAST);
    if (errors.length !== 0) {
      throw new Error(errors.map((error) => error.message).join("\n\n"));
    }
  }
  function assertValidSDLExtension(documentAST, schema) {
    const errors = validateSDL(documentAST, schema);
    if (errors.length !== 0) {
      throw new Error(errors.map((error) => error.message).join("\n\n"));
    }
  }
  var init_validate2 = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/validate.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_GraphQLError();
      init_visitor();
      init_validate();
      init_TypeInfo();
      init_specifiedRules();
      init_ValidationContext();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/memoize3.mjs
  function memoize3(fn) {
    let cache0;
    return function memoized(a1, a2, a3) {
      if (cache0 === void 0) {
        cache0 = /* @__PURE__ */ new WeakMap();
      }
      let cache1 = cache0.get(a1);
      if (cache1 === void 0) {
        cache1 = /* @__PURE__ */ new WeakMap();
        cache0.set(a1, cache1);
      }
      let cache2 = cache1.get(a2);
      if (cache2 === void 0) {
        cache2 = /* @__PURE__ */ new WeakMap();
        cache1.set(a2, cache2);
      }
      let fnResult = cache2.get(a3);
      if (fnResult === void 0) {
        fnResult = fn(a1, a2, a3);
        cache2.set(a3, fnResult);
      }
      return fnResult;
    };
  }
  var init_memoize3 = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/memoize3.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/promiseForObject.mjs
  function promiseForObject(object) {
    return Promise.all(Object.values(object)).then((resolvedValues) => {
      const resolvedObject = /* @__PURE__ */ Object.create(null);
      for (const [i2, key] of Object.keys(object).entries()) {
        resolvedObject[key] = resolvedValues[i2];
      }
      return resolvedObject;
    });
  }
  var init_promiseForObject = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/promiseForObject.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/promiseReduce.mjs
  function promiseReduce(values, callbackFn, initialValue) {
    let accumulator = initialValue;
    for (const value of values) {
      accumulator = isPromise(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
    }
    return accumulator;
  }
  var init_promiseReduce = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/promiseReduce.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_isPromise();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/toError.mjs
  function toError(thrownValue) {
    return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
  }
  var NonErrorThrown;
  var init_toError = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/toError.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      NonErrorThrown = class extends Error {
        constructor(thrownValue) {
          super("Unexpected error value: " + inspect(thrownValue));
          this.name = "NonErrorThrown";
          this.thrownValue = thrownValue;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/error/locatedError.mjs
  function locatedError(rawOriginalError, nodes, path) {
    var _nodes;
    const originalError = toError(rawOriginalError);
    if (isLocatedGraphQLError(originalError)) {
      return originalError;
    }
    return new GraphQLError(originalError.message, {
      nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
      source: originalError.source,
      positions: originalError.positions,
      path,
      originalError
    });
  }
  function isLocatedGraphQLError(error) {
    return Array.isArray(error.path);
  }
  var init_locatedError = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/error/locatedError.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_toError();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/execute.mjs
  function execute(args) {
    arguments.length < 2 || devAssert(
      false,
      "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
    );
    const { schema, document, variableValues, rootValue } = args;
    assertValidExecutionArguments(schema, document, variableValues);
    const exeContext = buildExecutionContext(args);
    if (!("schema" in exeContext)) {
      return {
        errors: exeContext
      };
    }
    try {
      const { operation } = exeContext;
      const result = executeOperation(exeContext, operation, rootValue);
      if (isPromise(result)) {
        return result.then(
          (data) => buildResponse(data, exeContext.errors),
          (error) => {
            exeContext.errors.push(error);
            return buildResponse(null, exeContext.errors);
          }
        );
      }
      return buildResponse(result, exeContext.errors);
    } catch (error) {
      exeContext.errors.push(error);
      return buildResponse(null, exeContext.errors);
    }
  }
  function executeSync(args) {
    const result = execute(args);
    if (isPromise(result)) {
      throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return result;
  }
  function buildResponse(data, errors) {
    return errors.length === 0 ? {
      data
    } : {
      errors,
      data
    };
  }
  function assertValidExecutionArguments(schema, document, rawVariableValues) {
    document || devAssert(false, "Must provide document.");
    assertValidSchema(schema);
    rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(
      false,
      "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
    );
  }
  function buildExecutionContext(args) {
    var _definition$name, _operation$variableDe;
    const {
      schema,
      document,
      rootValue,
      contextValue,
      variableValues: rawVariableValues,
      operationName,
      fieldResolver,
      typeResolver,
      subscribeFieldResolver
    } = args;
    let operation;
    const fragments = /* @__PURE__ */ Object.create(null);
    for (const definition of document.definitions) {
      switch (definition.kind) {
        case Kind.OPERATION_DEFINITION:
          if (operationName == null) {
            if (operation !== void 0) {
              return [
                new GraphQLError(
                  "Must provide operation name if query contains multiple operations."
                )
              ];
            }
            operation = definition;
          } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
            operation = definition;
          }
          break;
        case Kind.FRAGMENT_DEFINITION:
          fragments[definition.name.value] = definition;
          break;
        default:
      }
    }
    if (!operation) {
      if (operationName != null) {
        return [new GraphQLError(`Unknown operation named "${operationName}".`)];
      }
      return [new GraphQLError("Must provide an operation.")];
    }
    const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
    const coercedVariableValues = getVariableValues(
      schema,
      variableDefinitions,
      rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
      {
        maxErrors: 50
      }
    );
    if (coercedVariableValues.errors) {
      return coercedVariableValues.errors;
    }
    return {
      schema,
      fragments,
      rootValue,
      contextValue,
      operation,
      variableValues: coercedVariableValues.coerced,
      fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
      typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
      subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
      errors: []
    };
  }
  function executeOperation(exeContext, operation, rootValue) {
    const rootType = exeContext.schema.getRootType(operation.operation);
    if (rootType == null) {
      throw new GraphQLError(
        `Schema is not configured to execute ${operation.operation} operation.`,
        {
          nodes: operation
        }
      );
    }
    const rootFields = collectFields(
      exeContext.schema,
      exeContext.fragments,
      exeContext.variableValues,
      rootType,
      operation.selectionSet
    );
    const path = void 0;
    switch (operation.operation) {
      case OperationTypeNode.QUERY:
        return executeFields(exeContext, rootType, rootValue, path, rootFields);
      case OperationTypeNode.MUTATION:
        return executeFieldsSerially(
          exeContext,
          rootType,
          rootValue,
          path,
          rootFields
        );
      case OperationTypeNode.SUBSCRIPTION:
        return executeFields(exeContext, rootType, rootValue, path, rootFields);
    }
  }
  function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
    return promiseReduce(
      fields.entries(),
      (results, [responseName, fieldNodes]) => {
        const fieldPath = addPath(path, responseName, parentType.name);
        const result = executeField(
          exeContext,
          parentType,
          sourceValue,
          fieldNodes,
          fieldPath
        );
        if (result === void 0) {
          return results;
        }
        if (isPromise(result)) {
          return result.then((resolvedResult) => {
            results[responseName] = resolvedResult;
            return results;
          });
        }
        results[responseName] = result;
        return results;
      },
      /* @__PURE__ */ Object.create(null)
    );
  }
  function executeFields(exeContext, parentType, sourceValue, path, fields) {
    const results = /* @__PURE__ */ Object.create(null);
    let containsPromise = false;
    try {
      for (const [responseName, fieldNodes] of fields.entries()) {
        const fieldPath = addPath(path, responseName, parentType.name);
        const result = executeField(
          exeContext,
          parentType,
          sourceValue,
          fieldNodes,
          fieldPath
        );
        if (result !== void 0) {
          results[responseName] = result;
          if (isPromise(result)) {
            containsPromise = true;
          }
        }
      }
    } catch (error) {
      if (containsPromise) {
        return promiseForObject(results).finally(() => {
          throw error;
        });
      }
      throw error;
    }
    if (!containsPromise) {
      return results;
    }
    return promiseForObject(results);
  }
  function executeField(exeContext, parentType, source, fieldNodes, path) {
    var _fieldDef$resolve;
    const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
    if (!fieldDef) {
      return;
    }
    const returnType = fieldDef.type;
    const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
    const info = buildResolveInfo(
      exeContext,
      fieldDef,
      fieldNodes,
      parentType,
      path
    );
    try {
      const args = getArgumentValues(
        fieldDef,
        fieldNodes[0],
        exeContext.variableValues
      );
      const contextValue = exeContext.contextValue;
      const result = resolveFn(source, args, contextValue, info);
      let completed;
      if (isPromise(result)) {
        completed = result.then(
          (resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved)
        );
      } else {
        completed = completeValue(
          exeContext,
          returnType,
          fieldNodes,
          info,
          path,
          result
        );
      }
      if (isPromise(completed)) {
        return completed.then(void 0, (rawError) => {
          const error = locatedError(rawError, fieldNodes, pathToArray(path));
          return handleFieldError(error, returnType, exeContext);
        });
      }
      return completed;
    } catch (rawError) {
      const error = locatedError(rawError, fieldNodes, pathToArray(path));
      return handleFieldError(error, returnType, exeContext);
    }
  }
  function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
    return {
      fieldName: fieldDef.name,
      fieldNodes,
      returnType: fieldDef.type,
      parentType,
      path,
      schema: exeContext.schema,
      fragments: exeContext.fragments,
      rootValue: exeContext.rootValue,
      operation: exeContext.operation,
      variableValues: exeContext.variableValues
    };
  }
  function handleFieldError(error, returnType, exeContext) {
    if (isNonNullType(returnType)) {
      throw error;
    }
    exeContext.errors.push(error);
    return null;
  }
  function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (result instanceof Error) {
      throw result;
    }
    if (isNonNullType(returnType)) {
      const completed = completeValue(
        exeContext,
        returnType.ofType,
        fieldNodes,
        info,
        path,
        result
      );
      if (completed === null) {
        throw new Error(
          `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`
        );
      }
      return completed;
    }
    if (result == null) {
      return null;
    }
    if (isListType(returnType)) {
      return completeListValue(
        exeContext,
        returnType,
        fieldNodes,
        info,
        path,
        result
      );
    }
    if (isLeafType(returnType)) {
      return completeLeafValue(returnType, result);
    }
    if (isAbstractType(returnType)) {
      return completeAbstractValue(
        exeContext,
        returnType,
        fieldNodes,
        info,
        path,
        result
      );
    }
    if (isObjectType(returnType)) {
      return completeObjectValue(
        exeContext,
        returnType,
        fieldNodes,
        info,
        path,
        result
      );
    }
    invariant(
      false,
      "Cannot complete value of unexpected output type: " + inspect(returnType)
    );
  }
  function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (!isIterableObject(result)) {
      throw new GraphQLError(
        `Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`
      );
    }
    const itemType = returnType.ofType;
    let containsPromise = false;
    const completedResults = Array.from(result, (item, index) => {
      const itemPath = addPath(path, index, void 0);
      try {
        let completedItem;
        if (isPromise(item)) {
          completedItem = item.then(
            (resolved) => completeValue(
              exeContext,
              itemType,
              fieldNodes,
              info,
              itemPath,
              resolved
            )
          );
        } else {
          completedItem = completeValue(
            exeContext,
            itemType,
            fieldNodes,
            info,
            itemPath,
            item
          );
        }
        if (isPromise(completedItem)) {
          containsPromise = true;
          return completedItem.then(void 0, (rawError) => {
            const error = locatedError(
              rawError,
              fieldNodes,
              pathToArray(itemPath)
            );
            return handleFieldError(error, itemType, exeContext);
          });
        }
        return completedItem;
      } catch (rawError) {
        const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));
        return handleFieldError(error, itemType, exeContext);
      }
    });
    return containsPromise ? Promise.all(completedResults) : completedResults;
  }
  function completeLeafValue(returnType, result) {
    const serializedResult = returnType.serialize(result);
    if (serializedResult == null) {
      throw new Error(
        `Expected \`${inspect(returnType)}.serialize(${inspect(result)})\` to return non-nullable value, returned: ${inspect(serializedResult)}`
      );
    }
    return serializedResult;
  }
  function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
    var _returnType$resolveTy;
    const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
    const contextValue = exeContext.contextValue;
    const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
    if (isPromise(runtimeType)) {
      return runtimeType.then(
        (resolvedRuntimeType) => completeObjectValue(
          exeContext,
          ensureValidRuntimeType(
            resolvedRuntimeType,
            exeContext,
            returnType,
            fieldNodes,
            info,
            result
          ),
          fieldNodes,
          info,
          path,
          result
        )
      );
    }
    return completeObjectValue(
      exeContext,
      ensureValidRuntimeType(
        runtimeType,
        exeContext,
        returnType,
        fieldNodes,
        info,
        result
      ),
      fieldNodes,
      info,
      path,
      result
    );
  }
  function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
    if (runtimeTypeName == null) {
      throw new GraphQLError(
        `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
        fieldNodes
      );
    }
    if (isObjectType(runtimeTypeName)) {
      throw new GraphQLError(
        "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
      );
    }
    if (typeof runtimeTypeName !== "string") {
      throw new GraphQLError(
        `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${inspect(result)}, received "${inspect(runtimeTypeName)}".`
      );
    }
    const runtimeType = exeContext.schema.getType(runtimeTypeName);
    if (runtimeType == null) {
      throw new GraphQLError(
        `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
        {
          nodes: fieldNodes
        }
      );
    }
    if (!isObjectType(runtimeType)) {
      throw new GraphQLError(
        `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
        {
          nodes: fieldNodes
        }
      );
    }
    if (!exeContext.schema.isSubType(returnType, runtimeType)) {
      throw new GraphQLError(
        `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
        {
          nodes: fieldNodes
        }
      );
    }
    return runtimeType;
  }
  function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
    const subFieldNodes = collectSubfields2(exeContext, returnType, fieldNodes);
    if (returnType.isTypeOf) {
      const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
      if (isPromise(isTypeOf)) {
        return isTypeOf.then((resolvedIsTypeOf) => {
          if (!resolvedIsTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
          }
          return executeFields(
            exeContext,
            returnType,
            result,
            path,
            subFieldNodes
          );
        });
      }
      if (!isTypeOf) {
        throw invalidReturnTypeError(returnType, result, fieldNodes);
      }
    }
    return executeFields(exeContext, returnType, result, path, subFieldNodes);
  }
  function invalidReturnTypeError(returnType, result, fieldNodes) {
    return new GraphQLError(
      `Expected value of type "${returnType.name}" but got: ${inspect(result)}.`,
      {
        nodes: fieldNodes
      }
    );
  }
  function getFieldDef2(schema, parentType, fieldNode) {
    const fieldName = fieldNode.name.value;
    if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
      return SchemaMetaFieldDef;
    } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
      return TypeMetaFieldDef;
    } else if (fieldName === TypeNameMetaFieldDef.name) {
      return TypeNameMetaFieldDef;
    }
    return parentType.getFields()[fieldName];
  }
  var collectSubfields2, defaultTypeResolver, defaultFieldResolver;
  var init_execute = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/execute.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_inspect();
      init_invariant();
      init_isIterableObject();
      init_isObjectLike();
      init_isPromise();
      init_memoize3();
      init_Path();
      init_promiseForObject();
      init_promiseReduce();
      init_GraphQLError();
      init_locatedError();
      init_ast();
      init_kinds();
      init_definition();
      init_introspection();
      init_validate();
      init_collectFields();
      init_values();
      collectSubfields2 = memoize3(
        (exeContext, returnType, fieldNodes) => collectSubfields(
          exeContext.schema,
          exeContext.fragments,
          exeContext.variableValues,
          returnType,
          fieldNodes
        )
      );
      defaultTypeResolver = function(value, contextValue, info, abstractType) {
        if (isObjectLike(value) && typeof value.__typename === "string") {
          return value.__typename;
        }
        const possibleTypes = info.schema.getPossibleTypes(abstractType);
        const promisedIsTypeOfResults = [];
        for (let i2 = 0; i2 < possibleTypes.length; i2++) {
          const type = possibleTypes[i2];
          if (type.isTypeOf) {
            const isTypeOfResult = type.isTypeOf(value, contextValue, info);
            if (isPromise(isTypeOfResult)) {
              promisedIsTypeOfResults[i2] = isTypeOfResult;
            } else if (isTypeOfResult) {
              return type.name;
            }
          }
        }
        if (promisedIsTypeOfResults.length) {
          return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
            for (let i2 = 0; i2 < isTypeOfResults.length; i2++) {
              if (isTypeOfResults[i2]) {
                return possibleTypes[i2].name;
              }
            }
          });
        }
      };
      defaultFieldResolver = function(source, args, contextValue, info) {
        if (isObjectLike(source) || typeof source === "function") {
          const property = source[info.fieldName];
          if (typeof property === "function") {
            return source[info.fieldName](args, contextValue, info);
          }
          return property;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/graphql.mjs
  function graphql(args) {
    return new Promise((resolve) => resolve(graphqlImpl(args)));
  }
  function graphqlSync(args) {
    const result = graphqlImpl(args);
    if (isPromise(result)) {
      throw new Error("GraphQL execution failed to complete synchronously.");
    }
    return result;
  }
  function graphqlImpl(args) {
    arguments.length < 2 || devAssert(
      false,
      "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
    );
    const {
      schema,
      source,
      rootValue,
      contextValue,
      variableValues,
      operationName,
      fieldResolver,
      typeResolver
    } = args;
    const schemaValidationErrors = validateSchema(schema);
    if (schemaValidationErrors.length > 0) {
      return {
        errors: schemaValidationErrors
      };
    }
    let document;
    try {
      document = parse(source);
    } catch (syntaxError2) {
      return {
        errors: [syntaxError2]
      };
    }
    const validationErrors = validate(schema, document);
    if (validationErrors.length > 0) {
      return {
        errors: validationErrors
      };
    }
    return execute({
      schema,
      document,
      rootValue,
      contextValue,
      variableValues,
      operationName,
      fieldResolver,
      typeResolver
    });
  }
  var init_graphql = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/graphql.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_isPromise();
      init_parser();
      init_validate();
      init_validate2();
      init_execute();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/index.mjs
  var init_type = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/index.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_schema();
      init_definition();
      init_directives();
      init_scalars();
      init_introspection();
      init_validate();
      init_assertName();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/index.mjs
  var init_language = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/index.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_source();
      init_location();
      init_printLocation();
      init_kinds();
      init_tokenKind();
      init_lexer();
      init_parser();
      init_printer();
      init_visitor();
      init_ast();
      init_predicates();
      init_directiveLocation();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isAsyncIterable.mjs
  function isAsyncIterable(maybeAsyncIterable) {
    return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
  }
  var init_isAsyncIterable = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isAsyncIterable.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/mapAsyncIterator.mjs
  function mapAsyncIterator(iterable, callback) {
    const iterator = iterable[Symbol.asyncIterator]();
    function mapResult(result) {
      return __async(this, null, function* () {
        if (result.done) {
          return result;
        }
        try {
          return {
            value: yield callback(result.value),
            done: false
          };
        } catch (error) {
          if (typeof iterator.return === "function") {
            try {
              yield iterator.return();
            } catch (_e) {
            }
          }
          throw error;
        }
      });
    }
    return {
      next() {
        return __async(this, null, function* () {
          return mapResult(yield iterator.next());
        });
      },
      return() {
        return __async(this, null, function* () {
          return typeof iterator.return === "function" ? mapResult(yield iterator.return()) : {
            value: void 0,
            done: true
          };
        });
      },
      throw(error) {
        return __async(this, null, function* () {
          if (typeof iterator.throw === "function") {
            return mapResult(yield iterator.throw(error));
          }
          throw error;
        });
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  var init_mapAsyncIterator = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/mapAsyncIterator.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/subscribe.mjs
  function subscribe(_0) {
    return __async(this, arguments, function* (args) {
      arguments.length < 2 || devAssert(
        false,
        "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
      );
      const resultOrStream = yield createSourceEventStream(args);
      if (!isAsyncIterable(resultOrStream)) {
        return resultOrStream;
      }
      const mapSourceToResponse = (payload) => execute(__spreadProps(__spreadValues({}, args), { rootValue: payload }));
      return mapAsyncIterator(resultOrStream, mapSourceToResponse);
    });
  }
  function toNormalizedArgs(args) {
    const firstArg = args[0];
    if (firstArg && "document" in firstArg) {
      return firstArg;
    }
    return {
      schema: firstArg,
      // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
      document: args[1],
      rootValue: args[2],
      contextValue: args[3],
      variableValues: args[4],
      operationName: args[5],
      subscribeFieldResolver: args[6]
    };
  }
  function createSourceEventStream(...rawArgs) {
    return __async(this, null, function* () {
      const args = toNormalizedArgs(rawArgs);
      const { schema, document, variableValues } = args;
      assertValidExecutionArguments(schema, document, variableValues);
      const exeContext = buildExecutionContext(args);
      if (!("schema" in exeContext)) {
        return {
          errors: exeContext
        };
      }
      try {
        const eventStream = yield executeSubscription(exeContext);
        if (!isAsyncIterable(eventStream)) {
          throw new Error(
            `Subscription field must return Async Iterable. Received: ${inspect(eventStream)}.`
          );
        }
        return eventStream;
      } catch (error) {
        if (error instanceof GraphQLError) {
          return {
            errors: [error]
          };
        }
        throw error;
      }
    });
  }
  function executeSubscription(exeContext) {
    return __async(this, null, function* () {
      const { schema, fragments, operation, variableValues, rootValue } = exeContext;
      const rootType = schema.getSubscriptionType();
      if (rootType == null) {
        throw new GraphQLError(
          "Schema is not configured to execute subscription operation.",
          {
            nodes: operation
          }
        );
      }
      const rootFields = collectFields(
        schema,
        fragments,
        variableValues,
        rootType,
        operation.selectionSet
      );
      const [responseName, fieldNodes] = [...rootFields.entries()][0];
      const fieldDef = getFieldDef2(schema, rootType, fieldNodes[0]);
      if (!fieldDef) {
        const fieldName = fieldNodes[0].name.value;
        throw new GraphQLError(
          `The subscription field "${fieldName}" is not defined.`,
          {
            nodes: fieldNodes
          }
        );
      }
      const path = addPath(void 0, responseName, rootType.name);
      const info = buildResolveInfo(
        exeContext,
        fieldDef,
        fieldNodes,
        rootType,
        path
      );
      try {
        var _fieldDef$subscribe;
        const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);
        const contextValue = exeContext.contextValue;
        const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
        const eventStream = yield resolveFn(rootValue, args, contextValue, info);
        if (eventStream instanceof Error) {
          throw eventStream;
        }
        return eventStream;
      } catch (error) {
        throw locatedError(error, fieldNodes, pathToArray(path));
      }
    });
  }
  var init_subscribe = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/subscribe.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_inspect();
      init_isAsyncIterable();
      init_Path();
      init_GraphQLError();
      init_locatedError();
      init_collectFields();
      init_execute();
      init_mapAsyncIterator();
      init_values();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/index.mjs
  var init_execution = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/index.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_Path();
      init_execute();
      init_subscribe();
      init_values();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs
  function NoDeprecatedCustomRule(context) {
    return {
      Field(node) {
        const fieldDef = context.getFieldDef();
        const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
        if (fieldDef && deprecationReason != null) {
          const parentType = context.getParentType();
          parentType != null || invariant(false);
          context.reportError(
            new GraphQLError(
              `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      },
      Argument(node) {
        const argDef = context.getArgument();
        const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
        if (argDef && deprecationReason != null) {
          const directiveDef = context.getDirective();
          if (directiveDef != null) {
            context.reportError(
              new GraphQLError(
                `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          } else {
            const parentType = context.getParentType();
            const fieldDef = context.getFieldDef();
            parentType != null && fieldDef != null || invariant(false);
            context.reportError(
              new GraphQLError(
                `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      },
      ObjectField(node) {
        const inputObjectDef = getNamedType(context.getParentInputType());
        if (isInputObjectType(inputObjectDef)) {
          const inputFieldDef = inputObjectDef.getFields()[node.name.value];
          const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
          if (deprecationReason != null) {
            context.reportError(
              new GraphQLError(
                `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
                {
                  nodes: node
                }
              )
            );
          }
        }
      },
      EnumValue(node) {
        const enumValueDef = context.getEnumValue();
        const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
        if (enumValueDef && deprecationReason != null) {
          const enumTypeDef = getNamedType(context.getInputType());
          enumTypeDef != null || invariant(false);
          context.reportError(
            new GraphQLError(
              `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    };
  }
  var init_NoDeprecatedCustomRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_invariant();
      init_GraphQLError();
      init_definition();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs
  function NoSchemaIntrospectionCustomRule(context) {
    return {
      Field(node) {
        const type = getNamedType(context.getType());
        if (type && isIntrospectionType(type)) {
          context.reportError(
            new GraphQLError(
              `GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`,
              {
                nodes: node
              }
            )
          );
        }
      }
    };
  }
  var init_NoSchemaIntrospectionCustomRule = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
      init_definition();
      init_introspection();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/index.mjs
  var init_validation = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/index.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_validate2();
      init_ValidationContext();
      init_specifiedRules();
      init_ExecutableDefinitionsRule();
      init_FieldsOnCorrectTypeRule();
      init_FragmentsOnCompositeTypesRule();
      init_KnownArgumentNamesRule();
      init_KnownDirectivesRule();
      init_KnownFragmentNamesRule();
      init_KnownTypeNamesRule();
      init_LoneAnonymousOperationRule();
      init_NoFragmentCyclesRule();
      init_NoUndefinedVariablesRule();
      init_NoUnusedFragmentsRule();
      init_NoUnusedVariablesRule();
      init_OverlappingFieldsCanBeMergedRule();
      init_PossibleFragmentSpreadsRule();
      init_ProvidedRequiredArgumentsRule();
      init_ScalarLeafsRule();
      init_SingleFieldSubscriptionsRule();
      init_UniqueArgumentNamesRule();
      init_UniqueDirectivesPerLocationRule();
      init_UniqueFragmentNamesRule();
      init_UniqueInputFieldNamesRule();
      init_UniqueOperationNamesRule();
      init_UniqueVariableNamesRule();
      init_ValuesOfCorrectTypeRule();
      init_VariablesAreInputTypesRule();
      init_VariablesInAllowedPositionRule();
      init_LoneSchemaDefinitionRule();
      init_UniqueOperationTypesRule();
      init_UniqueTypeNamesRule();
      init_UniqueEnumValueNamesRule();
      init_UniqueFieldDefinitionNamesRule();
      init_UniqueArgumentDefinitionNamesRule();
      init_UniqueDirectiveNamesRule();
      init_PossibleTypeExtensionsRule();
      init_NoDeprecatedCustomRule();
      init_NoSchemaIntrospectionCustomRule();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/error/index.mjs
  var init_error = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/error/index.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
      init_syntaxError();
      init_locatedError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/getIntrospectionQuery.mjs
  function getIntrospectionQuery(options) {
    const optionsWithDefault = __spreadValues({
      descriptions: true,
      specifiedByUrl: false,
      directiveIsRepeatable: false,
      schemaDescription: false,
      inputValueDeprecation: false
    }, options);
    const descriptions = optionsWithDefault.descriptions ? "description" : "";
    const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
    const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
    const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
    function inputDeprecation(str) {
      return optionsWithDefault.inputValueDeprecation ? str : "";
    }
    return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
  }
  var init_getIntrospectionQuery = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/getIntrospectionQuery.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/getOperationAST.mjs
  function getOperationAST(documentAST, operationName) {
    let operation = null;
    for (const definition of documentAST.definitions) {
      if (definition.kind === Kind.OPERATION_DEFINITION) {
        var _definition$name;
        if (operationName == null) {
          if (operation) {
            return null;
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
          return definition;
        }
      }
    }
    return operation;
  }
  var init_getOperationAST = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/getOperationAST.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_kinds();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/getOperationRootType.mjs
  function getOperationRootType(schema, operation) {
    if (operation.operation === "query") {
      const queryType = schema.getQueryType();
      if (!queryType) {
        throw new GraphQLError(
          "Schema does not define the required query root type.",
          {
            nodes: operation
          }
        );
      }
      return queryType;
    }
    if (operation.operation === "mutation") {
      const mutationType = schema.getMutationType();
      if (!mutationType) {
        throw new GraphQLError("Schema is not configured for mutations.", {
          nodes: operation
        });
      }
      return mutationType;
    }
    if (operation.operation === "subscription") {
      const subscriptionType = schema.getSubscriptionType();
      if (!subscriptionType) {
        throw new GraphQLError("Schema is not configured for subscriptions.", {
          nodes: operation
        });
      }
      return subscriptionType;
    }
    throw new GraphQLError(
      "Can only have query, mutation and subscription operations.",
      {
        nodes: operation
      }
    );
  }
  var init_getOperationRootType = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/getOperationRootType.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_GraphQLError();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/introspectionFromSchema.mjs
  function introspectionFromSchema(schema, options) {
    const optionsWithDefaults = __spreadValues({
      specifiedByUrl: true,
      directiveIsRepeatable: true,
      schemaDescription: true,
      inputValueDeprecation: true
    }, options);
    const document = parse(getIntrospectionQuery(optionsWithDefaults));
    const result = executeSync({
      schema,
      document
    });
    !result.errors && result.data || invariant(false);
    return result.data;
  }
  var init_introspectionFromSchema = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/introspectionFromSchema.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_invariant();
      init_parser();
      init_execute();
      init_getIntrospectionQuery();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/buildClientSchema.mjs
  function buildClientSchema(introspection, options) {
    isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(
      false,
      `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${inspect(
        introspection
      )}.`
    );
    const schemaIntrospection = introspection.__schema;
    const typeMap = keyValMap(
      schemaIntrospection.types,
      (typeIntrospection) => typeIntrospection.name,
      (typeIntrospection) => buildType(typeIntrospection)
    );
    for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {
      if (typeMap[stdType.name]) {
        typeMap[stdType.name] = stdType;
      }
    }
    const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
    const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
    const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
    const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
    return new GraphQLSchema({
      description: schemaIntrospection.description,
      query: queryType,
      mutation: mutationType,
      subscription: subscriptionType,
      types: Object.values(typeMap),
      directives,
      assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
    });
    function getType(typeRef) {
      if (typeRef.kind === TypeKind.LIST) {
        const itemRef = typeRef.ofType;
        if (!itemRef) {
          throw new Error("Decorated type deeper than introspection query.");
        }
        return new GraphQLList(getType(itemRef));
      }
      if (typeRef.kind === TypeKind.NON_NULL) {
        const nullableRef = typeRef.ofType;
        if (!nullableRef) {
          throw new Error("Decorated type deeper than introspection query.");
        }
        const nullableType = getType(nullableRef);
        return new GraphQLNonNull(assertNullableType(nullableType));
      }
      return getNamedType2(typeRef);
    }
    function getNamedType2(typeRef) {
      const typeName = typeRef.name;
      if (!typeName) {
        throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);
      }
      const type = typeMap[typeName];
      if (!type) {
        throw new Error(
          `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
        );
      }
      return type;
    }
    function getObjectType(typeRef) {
      return assertObjectType(getNamedType2(typeRef));
    }
    function getInterfaceType(typeRef) {
      return assertInterfaceType(getNamedType2(typeRef));
    }
    function buildType(type) {
      if (type != null && type.name != null && type.kind != null) {
        switch (type.kind) {
          case TypeKind.SCALAR:
            return buildScalarDef(type);
          case TypeKind.OBJECT:
            return buildObjectDef(type);
          case TypeKind.INTERFACE:
            return buildInterfaceDef(type);
          case TypeKind.UNION:
            return buildUnionDef(type);
          case TypeKind.ENUM:
            return buildEnumDef(type);
          case TypeKind.INPUT_OBJECT:
            return buildInputObjectDef(type);
        }
      }
      const typeStr = inspect(type);
      throw new Error(
        `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
      );
    }
    function buildScalarDef(scalarIntrospection) {
      return new GraphQLScalarType({
        name: scalarIntrospection.name,
        description: scalarIntrospection.description,
        specifiedByURL: scalarIntrospection.specifiedByURL
      });
    }
    function buildImplementationsList(implementingIntrospection) {
      if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {
        return [];
      }
      if (!implementingIntrospection.interfaces) {
        const implementingIntrospectionStr = inspect(implementingIntrospection);
        throw new Error(
          `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
        );
      }
      return implementingIntrospection.interfaces.map(getInterfaceType);
    }
    function buildObjectDef(objectIntrospection) {
      return new GraphQLObjectType({
        name: objectIntrospection.name,
        description: objectIntrospection.description,
        interfaces: () => buildImplementationsList(objectIntrospection),
        fields: () => buildFieldDefMap(objectIntrospection)
      });
    }
    function buildInterfaceDef(interfaceIntrospection) {
      return new GraphQLInterfaceType({
        name: interfaceIntrospection.name,
        description: interfaceIntrospection.description,
        interfaces: () => buildImplementationsList(interfaceIntrospection),
        fields: () => buildFieldDefMap(interfaceIntrospection)
      });
    }
    function buildUnionDef(unionIntrospection) {
      if (!unionIntrospection.possibleTypes) {
        const unionIntrospectionStr = inspect(unionIntrospection);
        throw new Error(
          `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
        );
      }
      return new GraphQLUnionType({
        name: unionIntrospection.name,
        description: unionIntrospection.description,
        types: () => unionIntrospection.possibleTypes.map(getObjectType)
      });
    }
    function buildEnumDef(enumIntrospection) {
      if (!enumIntrospection.enumValues) {
        const enumIntrospectionStr = inspect(enumIntrospection);
        throw new Error(
          `Introspection result missing enumValues: ${enumIntrospectionStr}.`
        );
      }
      return new GraphQLEnumType({
        name: enumIntrospection.name,
        description: enumIntrospection.description,
        values: keyValMap(
          enumIntrospection.enumValues,
          (valueIntrospection) => valueIntrospection.name,
          (valueIntrospection) => ({
            description: valueIntrospection.description,
            deprecationReason: valueIntrospection.deprecationReason
          })
        )
      });
    }
    function buildInputObjectDef(inputObjectIntrospection) {
      if (!inputObjectIntrospection.inputFields) {
        const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);
        throw new Error(
          `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
        );
      }
      return new GraphQLInputObjectType({
        name: inputObjectIntrospection.name,
        description: inputObjectIntrospection.description,
        fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
      });
    }
    function buildFieldDefMap(typeIntrospection) {
      if (!typeIntrospection.fields) {
        throw new Error(
          `Introspection result missing fields: ${inspect(typeIntrospection)}.`
        );
      }
      return keyValMap(
        typeIntrospection.fields,
        (fieldIntrospection) => fieldIntrospection.name,
        buildField
      );
    }
    function buildField(fieldIntrospection) {
      const type = getType(fieldIntrospection.type);
      if (!isOutputType(type)) {
        const typeStr = inspect(type);
        throw new Error(
          `Introspection must provide output type for fields, but received: ${typeStr}.`
        );
      }
      if (!fieldIntrospection.args) {
        const fieldIntrospectionStr = inspect(fieldIntrospection);
        throw new Error(
          `Introspection result missing field args: ${fieldIntrospectionStr}.`
        );
      }
      return {
        description: fieldIntrospection.description,
        deprecationReason: fieldIntrospection.deprecationReason,
        type,
        args: buildInputValueDefMap(fieldIntrospection.args)
      };
    }
    function buildInputValueDefMap(inputValueIntrospections) {
      return keyValMap(
        inputValueIntrospections,
        (inputValue) => inputValue.name,
        buildInputValue
      );
    }
    function buildInputValue(inputValueIntrospection) {
      const type = getType(inputValueIntrospection.type);
      if (!isInputType(type)) {
        const typeStr = inspect(type);
        throw new Error(
          `Introspection must provide input type for arguments, but received: ${typeStr}.`
        );
      }
      const defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : void 0;
      return {
        description: inputValueIntrospection.description,
        type,
        defaultValue,
        deprecationReason: inputValueIntrospection.deprecationReason
      };
    }
    function buildDirective(directiveIntrospection) {
      if (!directiveIntrospection.args) {
        const directiveIntrospectionStr = inspect(directiveIntrospection);
        throw new Error(
          `Introspection result missing directive args: ${directiveIntrospectionStr}.`
        );
      }
      if (!directiveIntrospection.locations) {
        const directiveIntrospectionStr = inspect(directiveIntrospection);
        throw new Error(
          `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
        );
      }
      return new GraphQLDirective({
        name: directiveIntrospection.name,
        description: directiveIntrospection.description,
        isRepeatable: directiveIntrospection.isRepeatable,
        locations: directiveIntrospection.locations.slice(),
        args: buildInputValueDefMap(directiveIntrospection.args)
      });
    }
  }
  var init_buildClientSchema = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/buildClientSchema.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_inspect();
      init_isObjectLike();
      init_keyValMap();
      init_parser();
      init_definition();
      init_directives();
      init_introspection();
      init_scalars();
      init_schema();
      init_valueFromAST();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/extendSchema.mjs
  function extendSchema(schema, documentAST, options) {
    assertSchema(schema);
    documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
    if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
      assertValidSDLExtension(documentAST, schema);
    }
    const schemaConfig = schema.toConfig();
    const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
    return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);
  }
  function extendSchemaImpl(schemaConfig, documentAST, options) {
    var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
    const typeDefs = [];
    const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
    const directiveDefs = [];
    let schemaDef;
    const schemaExtensions = [];
    for (const def of documentAST.definitions) {
      if (def.kind === Kind.SCHEMA_DEFINITION) {
        schemaDef = def;
      } else if (def.kind === Kind.SCHEMA_EXTENSION) {
        schemaExtensions.push(def);
      } else if (isTypeDefinitionNode(def)) {
        typeDefs.push(def);
      } else if (isTypeExtensionNode(def)) {
        const extendedTypeName = def.name.value;
        const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
        typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
      } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
        directiveDefs.push(def);
      }
    }
    if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
      return schemaConfig;
    }
    const typeMap = /* @__PURE__ */ Object.create(null);
    for (const existingType of schemaConfig.types) {
      typeMap[existingType.name] = extendNamedType(existingType);
    }
    for (const typeNode of typeDefs) {
      var _stdTypeMap$name;
      const name2 = typeNode.name.value;
      typeMap[name2] = (_stdTypeMap$name = stdTypeMap[name2]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
    }
    const operationTypes = __spreadValues(__spreadValues({
      // Get the extended root operation types.
      query: schemaConfig.query && replaceNamedType(schemaConfig.query),
      mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
      subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)
    }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions));
    return __spreadProps(__spreadValues({
      description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value
    }, operationTypes), {
      types: Object.values(typeMap),
      directives: [
        ...schemaConfig.directives.map(replaceDirective),
        ...directiveDefs.map(buildDirective)
      ],
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
      extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
      assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
    });
    function replaceType(type) {
      if (isListType(type)) {
        return new GraphQLList(replaceType(type.ofType));
      }
      if (isNonNullType(type)) {
        return new GraphQLNonNull(replaceType(type.ofType));
      }
      return replaceNamedType(type);
    }
    function replaceNamedType(type) {
      return typeMap[type.name];
    }
    function replaceDirective(directive) {
      const config2 = directive.toConfig();
      return new GraphQLDirective(__spreadProps(__spreadValues({}, config2), {
        args: mapValue(config2.args, extendArg)
      }));
    }
    function extendNamedType(type) {
      if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {
        return type;
      }
      if (isScalarType(type)) {
        return extendScalarType(type);
      }
      if (isObjectType(type)) {
        return extendObjectType(type);
      }
      if (isInterfaceType(type)) {
        return extendInterfaceType(type);
      }
      if (isUnionType(type)) {
        return extendUnionType(type);
      }
      if (isEnumType(type)) {
        return extendEnumType(type);
      }
      if (isInputObjectType(type)) {
        return extendInputObjectType(type);
      }
      invariant(false, "Unexpected type: " + inspect(type));
    }
    function extendInputObjectType(type) {
      var _typeExtensionsMap$co;
      const config2 = type.toConfig();
      const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
      return new GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {
        fields: () => __spreadValues(__spreadValues({}, mapValue(config2.fields, (field) => __spreadProps(__spreadValues({}, field), {
          type: replaceType(field.type)
        }))), buildInputFieldMap(extensions)),
        extensionASTNodes: config2.extensionASTNodes.concat(extensions)
      }));
    }
    function extendEnumType(type) {
      var _typeExtensionsMap$ty;
      const config2 = type.toConfig();
      const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
      return new GraphQLEnumType(__spreadProps(__spreadValues({}, config2), {
        values: __spreadValues(__spreadValues({}, config2.values), buildEnumValueMap(extensions)),
        extensionASTNodes: config2.extensionASTNodes.concat(extensions)
      }));
    }
    function extendScalarType(type) {
      var _typeExtensionsMap$co2;
      const config2 = type.toConfig();
      const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
      let specifiedByURL = config2.specifiedByURL;
      for (const extensionNode of extensions) {
        var _getSpecifiedByURL;
        specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
      }
      return new GraphQLScalarType(__spreadProps(__spreadValues({}, config2), {
        specifiedByURL,
        extensionASTNodes: config2.extensionASTNodes.concat(extensions)
      }));
    }
    function extendObjectType(type) {
      var _typeExtensionsMap$co3;
      const config2 = type.toConfig();
      const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
      return new GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
        interfaces: () => [
          ...type.getInterfaces().map(replaceNamedType),
          ...buildInterfaces(extensions)
        ],
        fields: () => __spreadValues(__spreadValues({}, mapValue(config2.fields, extendField)), buildFieldMap(extensions)),
        extensionASTNodes: config2.extensionASTNodes.concat(extensions)
      }));
    }
    function extendInterfaceType(type) {
      var _typeExtensionsMap$co4;
      const config2 = type.toConfig();
      const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
      return new GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {
        interfaces: () => [
          ...type.getInterfaces().map(replaceNamedType),
          ...buildInterfaces(extensions)
        ],
        fields: () => __spreadValues(__spreadValues({}, mapValue(config2.fields, extendField)), buildFieldMap(extensions)),
        extensionASTNodes: config2.extensionASTNodes.concat(extensions)
      }));
    }
    function extendUnionType(type) {
      var _typeExtensionsMap$co5;
      const config2 = type.toConfig();
      const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
      return new GraphQLUnionType(__spreadProps(__spreadValues({}, config2), {
        types: () => [
          ...type.getTypes().map(replaceNamedType),
          ...buildUnionTypes(extensions)
        ],
        extensionASTNodes: config2.extensionASTNodes.concat(extensions)
      }));
    }
    function extendField(field) {
      return __spreadProps(__spreadValues({}, field), {
        type: replaceType(field.type),
        args: field.args && mapValue(field.args, extendArg)
      });
    }
    function extendArg(arg) {
      return __spreadProps(__spreadValues({}, arg), { type: replaceType(arg.type) });
    }
    function getOperationTypes(nodes) {
      const opTypes = {};
      for (const node of nodes) {
        var _node$operationTypes;
        const operationTypesNodes = (
          /* c8 ignore next */
          (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
        );
        for (const operationType of operationTypesNodes) {
          opTypes[operationType.operation] = getNamedType2(operationType.type);
        }
      }
      return opTypes;
    }
    function getNamedType2(node) {
      var _stdTypeMap$name2;
      const name2 = node.name.value;
      const type = (_stdTypeMap$name2 = stdTypeMap[name2]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name2];
      if (type === void 0) {
        throw new Error(`Unknown type: "${name2}".`);
      }
      return type;
    }
    function getWrappedType(node) {
      if (node.kind === Kind.LIST_TYPE) {
        return new GraphQLList(getWrappedType(node.type));
      }
      if (node.kind === Kind.NON_NULL_TYPE) {
        return new GraphQLNonNull(getWrappedType(node.type));
      }
      return getNamedType2(node);
    }
    function buildDirective(node) {
      var _node$description;
      return new GraphQLDirective({
        name: node.name.value,
        description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
        // @ts-expect-error
        locations: node.locations.map(({ value }) => value),
        isRepeatable: node.repeatable,
        args: buildArgumentMap(node.arguments),
        astNode: node
      });
    }
    function buildFieldMap(nodes) {
      const fieldConfigMap = /* @__PURE__ */ Object.create(null);
      for (const node of nodes) {
        var _node$fields;
        const nodeFields = (
          /* c8 ignore next */
          (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
        );
        for (const field of nodeFields) {
          var _field$description;
          fieldConfigMap[field.name.value] = {
            // Note: While this could make assertions to get the correctly typed
            // value, that would throw immediately while type system validation
            // with validateSchema() will produce more actionable results.
            type: getWrappedType(field.type),
            description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
            args: buildArgumentMap(field.arguments),
            deprecationReason: getDeprecationReason(field),
            astNode: field
          };
        }
      }
      return fieldConfigMap;
    }
    function buildArgumentMap(args) {
      const argsNodes = (
        /* c8 ignore next */
        args !== null && args !== void 0 ? args : []
      );
      const argConfigMap = /* @__PURE__ */ Object.create(null);
      for (const arg of argsNodes) {
        var _arg$description;
        const type = getWrappedType(arg.type);
        argConfigMap[arg.name.value] = {
          type,
          description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
          defaultValue: valueFromAST(arg.defaultValue, type),
          deprecationReason: getDeprecationReason(arg),
          astNode: arg
        };
      }
      return argConfigMap;
    }
    function buildInputFieldMap(nodes) {
      const inputFieldMap = /* @__PURE__ */ Object.create(null);
      for (const node of nodes) {
        var _node$fields2;
        const fieldsNodes = (
          /* c8 ignore next */
          (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
        );
        for (const field of fieldsNodes) {
          var _field$description2;
          const type = getWrappedType(field.type);
          inputFieldMap[field.name.value] = {
            type,
            description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
            defaultValue: valueFromAST(field.defaultValue, type),
            deprecationReason: getDeprecationReason(field),
            astNode: field
          };
        }
      }
      return inputFieldMap;
    }
    function buildEnumValueMap(nodes) {
      const enumValueMap = /* @__PURE__ */ Object.create(null);
      for (const node of nodes) {
        var _node$values;
        const valuesNodes = (
          /* c8 ignore next */
          (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
        );
        for (const value of valuesNodes) {
          var _value$description;
          enumValueMap[value.name.value] = {
            description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
            deprecationReason: getDeprecationReason(value),
            astNode: value
          };
        }
      }
      return enumValueMap;
    }
    function buildInterfaces(nodes) {
      return nodes.flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (node) => {
          var _node$interfaces$map, _node$interfaces;
          return (
            /* c8 ignore next */
            (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType2)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
          );
        }
      );
    }
    function buildUnionTypes(nodes) {
      return nodes.flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (node) => {
          var _node$types$map, _node$types;
          return (
            /* c8 ignore next */
            (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType2)) !== null && _node$types$map !== void 0 ? _node$types$map : []
          );
        }
      );
    }
    function buildType(astNode) {
      var _typeExtensionsMap$na;
      const name2 = astNode.name.value;
      const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name2]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
      switch (astNode.kind) {
        case Kind.OBJECT_TYPE_DEFINITION: {
          var _astNode$description;
          const allNodes = [astNode, ...extensionASTNodes];
          return new GraphQLObjectType({
            name: name2,
            description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
            interfaces: () => buildInterfaces(allNodes),
            fields: () => buildFieldMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case Kind.INTERFACE_TYPE_DEFINITION: {
          var _astNode$description2;
          const allNodes = [astNode, ...extensionASTNodes];
          return new GraphQLInterfaceType({
            name: name2,
            description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
            interfaces: () => buildInterfaces(allNodes),
            fields: () => buildFieldMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case Kind.ENUM_TYPE_DEFINITION: {
          var _astNode$description3;
          const allNodes = [astNode, ...extensionASTNodes];
          return new GraphQLEnumType({
            name: name2,
            description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
            values: buildEnumValueMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case Kind.UNION_TYPE_DEFINITION: {
          var _astNode$description4;
          const allNodes = [astNode, ...extensionASTNodes];
          return new GraphQLUnionType({
            name: name2,
            description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
            types: () => buildUnionTypes(allNodes),
            astNode,
            extensionASTNodes
          });
        }
        case Kind.SCALAR_TYPE_DEFINITION: {
          var _astNode$description5;
          return new GraphQLScalarType({
            name: name2,
            description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
            specifiedByURL: getSpecifiedByURL(astNode),
            astNode,
            extensionASTNodes
          });
        }
        case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
          var _astNode$description6;
          const allNodes = [astNode, ...extensionASTNodes];
          return new GraphQLInputObjectType({
            name: name2,
            description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
            fields: () => buildInputFieldMap(allNodes),
            astNode,
            extensionASTNodes
          });
        }
      }
    }
  }
  function getDeprecationReason(node) {
    const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
    return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
  }
  function getSpecifiedByURL(node) {
    const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
    return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
  }
  var stdTypeMap;
  var init_extendSchema = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/extendSchema.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_inspect();
      init_invariant();
      init_keyMap();
      init_mapValue();
      init_kinds();
      init_predicates();
      init_definition();
      init_directives();
      init_introspection();
      init_scalars();
      init_schema();
      init_validate2();
      init_values();
      init_valueFromAST();
      stdTypeMap = keyMap(
        [...specifiedScalarTypes, ...introspectionTypes],
        (type) => type.name
      );
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/buildASTSchema.mjs
  function buildASTSchema(documentAST, options) {
    documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
    if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
      assertValidSDL(documentAST);
    }
    const emptySchemaConfig = {
      description: void 0,
      types: [],
      directives: [],
      extensions: /* @__PURE__ */ Object.create(null),
      extensionASTNodes: [],
      assumeValid: false
    };
    const config2 = extendSchemaImpl(emptySchemaConfig, documentAST, options);
    if (config2.astNode == null) {
      for (const type of config2.types) {
        switch (type.name) {
          case "Query":
            config2.query = type;
            break;
          case "Mutation":
            config2.mutation = type;
            break;
          case "Subscription":
            config2.subscription = type;
            break;
        }
      }
    }
    const directives = [
      ...config2.directives,
      // If specified directives were not explicitly declared, add them.
      ...specifiedDirectives.filter(
        (stdDirective) => config2.directives.every(
          (directive) => directive.name !== stdDirective.name
        )
      )
    ];
    return new GraphQLSchema(__spreadProps(__spreadValues({}, config2), { directives }));
  }
  function buildSchema(source, options) {
    const document = parse(source, {
      noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
      allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
    });
    return buildASTSchema(document, {
      assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
      assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
    });
  }
  var init_buildASTSchema = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/buildASTSchema.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_kinds();
      init_parser();
      init_directives();
      init_schema();
      init_validate2();
      init_extendSchema();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/lexicographicSortSchema.mjs
  function lexicographicSortSchema(schema) {
    const schemaConfig = schema.toConfig();
    const typeMap = keyValMap(
      sortByName(schemaConfig.types),
      (type) => type.name,
      sortNamedType
    );
    return new GraphQLSchema(__spreadProps(__spreadValues({}, schemaConfig), {
      types: Object.values(typeMap),
      directives: sortByName(schemaConfig.directives).map(sortDirective),
      query: replaceMaybeType(schemaConfig.query),
      mutation: replaceMaybeType(schemaConfig.mutation),
      subscription: replaceMaybeType(schemaConfig.subscription)
    }));
    function replaceType(type) {
      if (isListType(type)) {
        return new GraphQLList(replaceType(type.ofType));
      } else if (isNonNullType(type)) {
        return new GraphQLNonNull(replaceType(type.ofType));
      }
      return replaceNamedType(type);
    }
    function replaceNamedType(type) {
      return typeMap[type.name];
    }
    function replaceMaybeType(maybeType) {
      return maybeType && replaceNamedType(maybeType);
    }
    function sortDirective(directive) {
      const config2 = directive.toConfig();
      return new GraphQLDirective(__spreadProps(__spreadValues({}, config2), {
        locations: sortBy(config2.locations, (x) => x),
        args: sortArgs(config2.args)
      }));
    }
    function sortArgs(args) {
      return sortObjMap(args, (arg) => __spreadProps(__spreadValues({}, arg), { type: replaceType(arg.type) }));
    }
    function sortFields2(fieldsMap) {
      return sortObjMap(fieldsMap, (field) => __spreadProps(__spreadValues({}, field), {
        type: replaceType(field.type),
        args: field.args && sortArgs(field.args)
      }));
    }
    function sortInputFields(fieldsMap) {
      return sortObjMap(fieldsMap, (field) => __spreadProps(__spreadValues({}, field), {
        type: replaceType(field.type)
      }));
    }
    function sortTypes(array) {
      return sortByName(array).map(replaceNamedType);
    }
    function sortNamedType(type) {
      if (isScalarType(type) || isIntrospectionType(type)) {
        return type;
      }
      if (isObjectType(type)) {
        const config2 = type.toConfig();
        return new GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
          interfaces: () => sortTypes(config2.interfaces),
          fields: () => sortFields2(config2.fields)
        }));
      }
      if (isInterfaceType(type)) {
        const config2 = type.toConfig();
        return new GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {
          interfaces: () => sortTypes(config2.interfaces),
          fields: () => sortFields2(config2.fields)
        }));
      }
      if (isUnionType(type)) {
        const config2 = type.toConfig();
        return new GraphQLUnionType(__spreadProps(__spreadValues({}, config2), {
          types: () => sortTypes(config2.types)
        }));
      }
      if (isEnumType(type)) {
        const config2 = type.toConfig();
        return new GraphQLEnumType(__spreadProps(__spreadValues({}, config2), {
          values: sortObjMap(config2.values, (value) => value)
        }));
      }
      if (isInputObjectType(type)) {
        const config2 = type.toConfig();
        return new GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {
          fields: () => sortInputFields(config2.fields)
        }));
      }
      invariant(false, "Unexpected type: " + inspect(type));
    }
  }
  function sortObjMap(map, sortValueFn) {
    const sortedMap = /* @__PURE__ */ Object.create(null);
    for (const key of Object.keys(map).sort(naturalCompare)) {
      sortedMap[key] = sortValueFn(map[key]);
    }
    return sortedMap;
  }
  function sortByName(array) {
    return sortBy(array, (obj) => obj.name);
  }
  function sortBy(array, mapToKey) {
    return array.slice().sort((obj1, obj2) => {
      const key1 = mapToKey(obj1);
      const key2 = mapToKey(obj2);
      return naturalCompare(key1, key2);
    });
  }
  var init_lexicographicSortSchema = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/lexicographicSortSchema.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_invariant();
      init_keyValMap();
      init_naturalCompare();
      init_definition();
      init_directives();
      init_introspection();
      init_schema();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/printSchema.mjs
  function printSchema(schema) {
    return printFilteredSchema(
      schema,
      (n2) => !isSpecifiedDirective(n2),
      isDefinedType
    );
  }
  function printIntrospectionSchema(schema) {
    return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);
  }
  function isDefinedType(type) {
    return !isSpecifiedScalarType(type) && !isIntrospectionType(type);
  }
  function printFilteredSchema(schema, directiveFilter, typeFilter) {
    const directives = schema.getDirectives().filter(directiveFilter);
    const types = Object.values(schema.getTypeMap()).filter(typeFilter);
    return [
      printSchemaDefinition(schema),
      ...directives.map((directive) => printDirective(directive)),
      ...types.map((type) => printType(type))
    ].filter(Boolean).join("\n\n");
  }
  function printSchemaDefinition(schema) {
    if (schema.description == null && isSchemaOfCommonNames(schema)) {
      return;
    }
    const operationTypes = [];
    const queryType = schema.getQueryType();
    if (queryType) {
      operationTypes.push(`  query: ${queryType.name}`);
    }
    const mutationType = schema.getMutationType();
    if (mutationType) {
      operationTypes.push(`  mutation: ${mutationType.name}`);
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType) {
      operationTypes.push(`  subscription: ${subscriptionType.name}`);
    }
    return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
  }
  function isSchemaOfCommonNames(schema) {
    const queryType = schema.getQueryType();
    if (queryType && queryType.name !== "Query") {
      return false;
    }
    const mutationType = schema.getMutationType();
    if (mutationType && mutationType.name !== "Mutation") {
      return false;
    }
    const subscriptionType = schema.getSubscriptionType();
    if (subscriptionType && subscriptionType.name !== "Subscription") {
      return false;
    }
    return true;
  }
  function printType(type) {
    if (isScalarType(type)) {
      return printScalar(type);
    }
    if (isObjectType(type)) {
      return printObject(type);
    }
    if (isInterfaceType(type)) {
      return printInterface(type);
    }
    if (isUnionType(type)) {
      return printUnion(type);
    }
    if (isEnumType(type)) {
      return printEnum(type);
    }
    if (isInputObjectType(type)) {
      return printInputObject(type);
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
  function printScalar(type) {
    return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
  }
  function printImplementedInterfaces(type) {
    const interfaces = type.getInterfaces();
    return interfaces.length ? " implements " + interfaces.map((i2) => i2.name).join(" & ") : "";
  }
  function printObject(type) {
    return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
  }
  function printInterface(type) {
    return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
  }
  function printUnion(type) {
    const types = type.getTypes();
    const possibleTypes = types.length ? " = " + types.join(" | ") : "";
    return printDescription(type) + "union " + type.name + possibleTypes;
  }
  function printEnum(type) {
    const values = type.getValues().map(
      (value, i2) => printDescription(value, "  ", !i2) + "  " + value.name + printDeprecated(value.deprecationReason)
    );
    return printDescription(type) + `enum ${type.name}` + printBlock(values);
  }
  function printInputObject(type) {
    const fields = Object.values(type.getFields()).map(
      (f2, i2) => printDescription(f2, "  ", !i2) + "  " + printInputValue(f2)
    );
    return printDescription(type) + `input ${type.name}` + printBlock(fields);
  }
  function printFields(type) {
    const fields = Object.values(type.getFields()).map(
      (f2, i2) => printDescription(f2, "  ", !i2) + "  " + f2.name + printArgs(f2.args, "  ") + ": " + String(f2.type) + printDeprecated(f2.deprecationReason)
    );
    return printBlock(fields);
  }
  function printBlock(items) {
    return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
  }
  function printArgs(args, indentation = "") {
    if (args.length === 0) {
      return "";
    }
    if (args.every((arg) => !arg.description)) {
      return "(" + args.map(printInputValue).join(", ") + ")";
    }
    return "(\n" + args.map(
      (arg, i2) => printDescription(arg, "  " + indentation, !i2) + "  " + indentation + printInputValue(arg)
    ).join("\n") + "\n" + indentation + ")";
  }
  function printInputValue(arg) {
    const defaultAST = astFromValue(arg.defaultValue, arg.type);
    let argDecl = arg.name + ": " + String(arg.type);
    if (defaultAST) {
      argDecl += ` = ${print(defaultAST)}`;
    }
    return argDecl + printDeprecated(arg.deprecationReason);
  }
  function printDirective(directive) {
    return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
  }
  function printDeprecated(reason) {
    if (reason == null) {
      return "";
    }
    if (reason !== DEFAULT_DEPRECATION_REASON) {
      const astValue = print({
        kind: Kind.STRING,
        value: reason
      });
      return ` @deprecated(reason: ${astValue})`;
    }
    return " @deprecated";
  }
  function printSpecifiedByURL(scalar) {
    if (scalar.specifiedByURL == null) {
      return "";
    }
    const astValue = print({
      kind: Kind.STRING,
      value: scalar.specifiedByURL
    });
    return ` @specifiedBy(url: ${astValue})`;
  }
  function printDescription(def, indentation = "", firstInBlock = true) {
    const { description } = def;
    if (description == null) {
      return "";
    }
    const blockString = print({
      kind: Kind.STRING,
      value: description,
      block: isPrintableAsBlockString(description)
    });
    const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
    return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
  }
  var init_printSchema = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/printSchema.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_invariant();
      init_blockString();
      init_kinds();
      init_printer();
      init_definition();
      init_directives();
      init_introspection();
      init_scalars();
      init_astFromValue();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/concatAST.mjs
  function concatAST(documents) {
    const definitions = [];
    for (const doc of documents) {
      definitions.push(...doc.definitions);
    }
    return {
      kind: Kind.DOCUMENT,
      definitions
    };
  }
  var init_concatAST = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/concatAST.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_kinds();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/separateOperations.mjs
  function separateOperations(documentAST) {
    const operations = [];
    const depGraph = /* @__PURE__ */ Object.create(null);
    for (const definitionNode of documentAST.definitions) {
      switch (definitionNode.kind) {
        case Kind.OPERATION_DEFINITION:
          operations.push(definitionNode);
          break;
        case Kind.FRAGMENT_DEFINITION:
          depGraph[definitionNode.name.value] = collectDependencies(
            definitionNode.selectionSet
          );
          break;
        default:
      }
    }
    const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
    for (const operation of operations) {
      const dependencies = /* @__PURE__ */ new Set();
      for (const fragmentName of collectDependencies(operation.selectionSet)) {
        collectTransitiveDependencies(dependencies, depGraph, fragmentName);
      }
      const operationName = operation.name ? operation.name.value : "";
      separatedDocumentASTs[operationName] = {
        kind: Kind.DOCUMENT,
        definitions: documentAST.definitions.filter(
          (node) => node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
        )
      };
    }
    return separatedDocumentASTs;
  }
  function collectTransitiveDependencies(collected, depGraph, fromName) {
    if (!collected.has(fromName)) {
      collected.add(fromName);
      const immediateDeps = depGraph[fromName];
      if (immediateDeps !== void 0) {
        for (const toName of immediateDeps) {
          collectTransitiveDependencies(collected, depGraph, toName);
        }
      }
    }
  }
  function collectDependencies(selectionSet) {
    const dependencies = [];
    visit(selectionSet, {
      FragmentSpread(node) {
        dependencies.push(node.name.value);
      }
    });
    return dependencies;
  }
  var init_separateOperations = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/separateOperations.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_kinds();
      init_visitor();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/stripIgnoredCharacters.mjs
  function stripIgnoredCharacters(source) {
    const sourceObj = isSource(source) ? source : new Source(source);
    const body = sourceObj.body;
    const lexer = new Lexer(sourceObj);
    let strippedBody = "";
    let wasLastAddedTokenNonPunctuator = false;
    while (lexer.advance().kind !== TokenKind.EOF) {
      const currentToken = lexer.token;
      const tokenKind = currentToken.kind;
      const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);
      if (wasLastAddedTokenNonPunctuator) {
        if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {
          strippedBody += " ";
        }
      }
      const tokenBody = body.slice(currentToken.start, currentToken.end);
      if (tokenKind === TokenKind.BLOCK_STRING) {
        strippedBody += printBlockString(currentToken.value, {
          minimize: true
        });
      } else {
        strippedBody += tokenBody;
      }
      wasLastAddedTokenNonPunctuator = isNonPunctuator;
    }
    return strippedBody;
  }
  var init_stripIgnoredCharacters = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/stripIgnoredCharacters.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_blockString();
      init_lexer();
      init_source();
      init_tokenKind();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/assertValidName.mjs
  function assertValidName(name2) {
    const error = isValidNameError(name2);
    if (error) {
      throw error;
    }
    return name2;
  }
  function isValidNameError(name2) {
    typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
    if (name2.startsWith("__")) {
      return new GraphQLError(
        `Name "${name2}" must not begin with "__", which is reserved by GraphQL introspection.`
      );
    }
    try {
      assertName(name2);
    } catch (error) {
      return error;
    }
  }
  var init_assertValidName = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/assertValidName.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_devAssert();
      init_GraphQLError();
      init_assertName();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/findBreakingChanges.mjs
  function findBreakingChanges(oldSchema, newSchema) {
    return findSchemaChanges(oldSchema, newSchema).filter(
      (change) => change.type in BreakingChangeType
    );
  }
  function findDangerousChanges(oldSchema, newSchema) {
    return findSchemaChanges(oldSchema, newSchema).filter(
      (change) => change.type in DangerousChangeType
    );
  }
  function findSchemaChanges(oldSchema, newSchema) {
    return [
      ...findTypeChanges(oldSchema, newSchema),
      ...findDirectiveChanges(oldSchema, newSchema)
    ];
  }
  function findDirectiveChanges(oldSchema, newSchema) {
    const schemaChanges = [];
    const directivesDiff = diff(
      oldSchema.getDirectives(),
      newSchema.getDirectives()
    );
    for (const oldDirective of directivesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_REMOVED,
        description: `${oldDirective.name} was removed.`
      });
    }
    for (const [oldDirective, newDirective] of directivesDiff.persisted) {
      const argsDiff = diff(oldDirective.args, newDirective.args);
      for (const newArg of argsDiff.added) {
        if (isRequiredArgument(newArg)) {
          schemaChanges.push({
            type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
            description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
          });
        }
      }
      for (const oldArg of argsDiff.removed) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
          description: `${oldArg.name} was removed from ${oldDirective.name}.`
        });
      }
      if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
          description: `Repeatable flag was removed from ${oldDirective.name}.`
        });
      }
      for (const location of oldDirective.locations) {
        if (!newDirective.locations.includes(location)) {
          schemaChanges.push({
            type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
            description: `${location} was removed from ${oldDirective.name}.`
          });
        }
      }
    }
    return schemaChanges;
  }
  function findTypeChanges(oldSchema, newSchema) {
    const schemaChanges = [];
    const typesDiff = diff(
      Object.values(oldSchema.getTypeMap()),
      Object.values(newSchema.getTypeMap())
    );
    for (const oldType of typesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_REMOVED,
        description: isSpecifiedScalarType(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
      });
    }
    for (const [oldType, newType] of typesDiff.persisted) {
      if (isEnumType(oldType) && isEnumType(newType)) {
        schemaChanges.push(...findEnumTypeChanges(oldType, newType));
      } else if (isUnionType(oldType) && isUnionType(newType)) {
        schemaChanges.push(...findUnionTypeChanges(oldType, newType));
      } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {
        schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
      } else if (isObjectType(oldType) && isObjectType(newType)) {
        schemaChanges.push(
          ...findFieldChanges(oldType, newType),
          ...findImplementedInterfacesChanges(oldType, newType)
        );
      } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {
        schemaChanges.push(
          ...findFieldChanges(oldType, newType),
          ...findImplementedInterfacesChanges(oldType, newType)
        );
      } else if (oldType.constructor !== newType.constructor) {
        schemaChanges.push({
          type: BreakingChangeType.TYPE_CHANGED_KIND,
          description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
        });
      }
    }
    return schemaChanges;
  }
  function findInputObjectTypeChanges(oldType, newType) {
    const schemaChanges = [];
    const fieldsDiff = diff(
      Object.values(oldType.getFields()),
      Object.values(newType.getFields())
    );
    for (const newField of fieldsDiff.added) {
      if (isRequiredInputField(newField)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
          description: `A required field ${newField.name} on input type ${oldType.name} was added.`
        });
      } else {
        schemaChanges.push({
          type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
          description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
        });
      }
    }
    for (const oldField of fieldsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_REMOVED,
        description: `${oldType.name}.${oldField.name} was removed.`
      });
    }
    for (const [oldField, newField] of fieldsDiff.persisted) {
      const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
        oldField.type,
        newField.type
      );
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_CHANGED_KIND,
          description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
        });
      }
    }
    return schemaChanges;
  }
  function findUnionTypeChanges(oldType, newType) {
    const schemaChanges = [];
    const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
    for (const newPossibleType of possibleTypesDiff.added) {
      schemaChanges.push({
        type: DangerousChangeType.TYPE_ADDED_TO_UNION,
        description: `${newPossibleType.name} was added to union type ${oldType.name}.`
      });
    }
    for (const oldPossibleType of possibleTypesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
        description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
      });
    }
    return schemaChanges;
  }
  function findEnumTypeChanges(oldType, newType) {
    const schemaChanges = [];
    const valuesDiff = diff(oldType.getValues(), newType.getValues());
    for (const newValue of valuesDiff.added) {
      schemaChanges.push({
        type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
        description: `${newValue.name} was added to enum type ${oldType.name}.`
      });
    }
    for (const oldValue of valuesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
        description: `${oldValue.name} was removed from enum type ${oldType.name}.`
      });
    }
    return schemaChanges;
  }
  function findImplementedInterfacesChanges(oldType, newType) {
    const schemaChanges = [];
    const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
    for (const newInterface of interfacesDiff.added) {
      schemaChanges.push({
        type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
        description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
      });
    }
    for (const oldInterface of interfacesDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
        description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
      });
    }
    return schemaChanges;
  }
  function findFieldChanges(oldType, newType) {
    const schemaChanges = [];
    const fieldsDiff = diff(
      Object.values(oldType.getFields()),
      Object.values(newType.getFields())
    );
    for (const oldField of fieldsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_REMOVED,
        description: `${oldType.name}.${oldField.name} was removed.`
      });
    }
    for (const [oldField, newField] of fieldsDiff.persisted) {
      schemaChanges.push(...findArgChanges(oldType, oldField, newField));
      const isSafe = isChangeSafeForObjectOrInterfaceField(
        oldField.type,
        newField.type
      );
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.FIELD_CHANGED_KIND,
          description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
        });
      }
    }
    return schemaChanges;
  }
  function findArgChanges(oldType, oldField, newField) {
    const schemaChanges = [];
    const argsDiff = diff(oldField.args, newField.args);
    for (const oldArg of argsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.ARG_REMOVED,
        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
      });
    }
    for (const [oldArg, newArg] of argsDiff.persisted) {
      const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
        oldArg.type,
        newArg.type
      );
      if (!isSafe) {
        schemaChanges.push({
          type: BreakingChangeType.ARG_CHANGED_KIND,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
        });
      } else if (oldArg.defaultValue !== void 0) {
        if (newArg.defaultValue === void 0) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
          });
        } else {
          const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
          const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
          if (oldValueStr !== newValueStr) {
            schemaChanges.push({
              type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
              description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
            });
          }
        }
      }
    }
    for (const newArg of argsDiff.added) {
      if (isRequiredArgument(newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_ARG_ADDED,
          description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
        });
      } else {
        schemaChanges.push({
          type: DangerousChangeType.OPTIONAL_ARG_ADDED,
          description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
        });
      }
    }
    return schemaChanges;
  }
  function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
    if (isListType(oldType)) {
      return (
        // if they're both lists, make sure the underlying types are compatible
        isListType(newType) && isChangeSafeForObjectOrInterfaceField(
          oldType.ofType,
          newType.ofType
        ) || // moving from nullable to non-null of the same underlying type is safe
        isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
      );
    }
    if (isNonNullType(oldType)) {
      return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
    }
    return (
      // if they're both named types, see if their names are equivalent
      isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
    );
  }
  function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
    if (isListType(oldType)) {
      return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
    }
    if (isNonNullType(oldType)) {
      return (
        // if they're both non-null, make sure the underlying types are
        // compatible
        isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
          oldType.ofType,
          newType.ofType
        ) || // moving from non-null to nullable of the same underlying type is safe
        !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
      );
    }
    return isNamedType(newType) && oldType.name === newType.name;
  }
  function typeKindName(type) {
    if (isScalarType(type)) {
      return "a Scalar type";
    }
    if (isObjectType(type)) {
      return "an Object type";
    }
    if (isInterfaceType(type)) {
      return "an Interface type";
    }
    if (isUnionType(type)) {
      return "a Union type";
    }
    if (isEnumType(type)) {
      return "an Enum type";
    }
    if (isInputObjectType(type)) {
      return "an Input type";
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
  function stringifyValue(value, type) {
    const ast = astFromValue(value, type);
    ast != null || invariant(false);
    return print(sortValueNode(ast));
  }
  function diff(oldArray, newArray) {
    const added = [];
    const removed = [];
    const persisted = [];
    const oldMap = keyMap(oldArray, ({ name: name2 }) => name2);
    const newMap = keyMap(newArray, ({ name: name2 }) => name2);
    for (const oldItem of oldArray) {
      const newItem = newMap[oldItem.name];
      if (newItem === void 0) {
        removed.push(oldItem);
      } else {
        persisted.push([oldItem, newItem]);
      }
    }
    for (const newItem of newArray) {
      if (oldMap[newItem.name] === void 0) {
        added.push(newItem);
      }
    }
    return {
      added,
      persisted,
      removed
    };
  }
  var BreakingChangeType, DangerousChangeType;
  var init_findBreakingChanges = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/findBreakingChanges.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_inspect();
      init_invariant();
      init_keyMap();
      init_printer();
      init_definition();
      init_scalars();
      init_astFromValue();
      init_sortValueNode();
      (function(BreakingChangeType2) {
        BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
        BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
        BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
        BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
        BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
        BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
        BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
        BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
        BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
        BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
        BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
        BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
        BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
        BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
        BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
        BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
      })(BreakingChangeType || (BreakingChangeType = {}));
      (function(DangerousChangeType2) {
        DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
        DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
        DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
        DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
        DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
        DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
      })(DangerousChangeType || (DangerousChangeType = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/index.mjs
  var init_utilities = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/index.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_getIntrospectionQuery();
      init_getOperationAST();
      init_getOperationRootType();
      init_introspectionFromSchema();
      init_buildClientSchema();
      init_buildASTSchema();
      init_extendSchema();
      init_lexicographicSortSchema();
      init_printSchema();
      init_typeFromAST();
      init_valueFromAST();
      init_valueFromASTUntyped();
      init_astFromValue();
      init_TypeInfo();
      init_coerceInputValue();
      init_concatAST();
      init_separateOperations();
      init_stripIgnoredCharacters();
      init_typeComparators();
      init_assertValidName();
      init_findBreakingChanges();
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/index.mjs
  var graphql_exports = {};
  __export(graphql_exports, {
    BREAK: () => BREAK,
    BreakingChangeType: () => BreakingChangeType,
    DEFAULT_DEPRECATION_REASON: () => DEFAULT_DEPRECATION_REASON,
    DangerousChangeType: () => DangerousChangeType,
    DirectiveLocation: () => DirectiveLocation,
    ExecutableDefinitionsRule: () => ExecutableDefinitionsRule,
    FieldsOnCorrectTypeRule: () => FieldsOnCorrectTypeRule,
    FragmentsOnCompositeTypesRule: () => FragmentsOnCompositeTypesRule,
    GRAPHQL_MAX_INT: () => GRAPHQL_MAX_INT,
    GRAPHQL_MIN_INT: () => GRAPHQL_MIN_INT,
    GraphQLBoolean: () => GraphQLBoolean,
    GraphQLDeprecatedDirective: () => GraphQLDeprecatedDirective,
    GraphQLDirective: () => GraphQLDirective,
    GraphQLEnumType: () => GraphQLEnumType,
    GraphQLError: () => GraphQLError,
    GraphQLFloat: () => GraphQLFloat,
    GraphQLID: () => GraphQLID,
    GraphQLIncludeDirective: () => GraphQLIncludeDirective,
    GraphQLInputObjectType: () => GraphQLInputObjectType,
    GraphQLInt: () => GraphQLInt,
    GraphQLInterfaceType: () => GraphQLInterfaceType,
    GraphQLList: () => GraphQLList,
    GraphQLNonNull: () => GraphQLNonNull,
    GraphQLObjectType: () => GraphQLObjectType,
    GraphQLScalarType: () => GraphQLScalarType,
    GraphQLSchema: () => GraphQLSchema,
    GraphQLSkipDirective: () => GraphQLSkipDirective,
    GraphQLSpecifiedByDirective: () => GraphQLSpecifiedByDirective,
    GraphQLString: () => GraphQLString,
    GraphQLUnionType: () => GraphQLUnionType,
    Kind: () => Kind,
    KnownArgumentNamesRule: () => KnownArgumentNamesRule,
    KnownDirectivesRule: () => KnownDirectivesRule,
    KnownFragmentNamesRule: () => KnownFragmentNamesRule,
    KnownTypeNamesRule: () => KnownTypeNamesRule,
    Lexer: () => Lexer,
    Location: () => Location,
    LoneAnonymousOperationRule: () => LoneAnonymousOperationRule,
    LoneSchemaDefinitionRule: () => LoneSchemaDefinitionRule,
    NoDeprecatedCustomRule: () => NoDeprecatedCustomRule,
    NoFragmentCyclesRule: () => NoFragmentCyclesRule,
    NoSchemaIntrospectionCustomRule: () => NoSchemaIntrospectionCustomRule,
    NoUndefinedVariablesRule: () => NoUndefinedVariablesRule,
    NoUnusedFragmentsRule: () => NoUnusedFragmentsRule,
    NoUnusedVariablesRule: () => NoUnusedVariablesRule,
    OperationTypeNode: () => OperationTypeNode,
    OverlappingFieldsCanBeMergedRule: () => OverlappingFieldsCanBeMergedRule,
    PossibleFragmentSpreadsRule: () => PossibleFragmentSpreadsRule,
    PossibleTypeExtensionsRule: () => PossibleTypeExtensionsRule,
    ProvidedRequiredArgumentsRule: () => ProvidedRequiredArgumentsRule,
    ScalarLeafsRule: () => ScalarLeafsRule,
    SchemaMetaFieldDef: () => SchemaMetaFieldDef,
    SingleFieldSubscriptionsRule: () => SingleFieldSubscriptionsRule,
    Source: () => Source,
    Token: () => Token,
    TokenKind: () => TokenKind,
    TypeInfo: () => TypeInfo,
    TypeKind: () => TypeKind,
    TypeMetaFieldDef: () => TypeMetaFieldDef,
    TypeNameMetaFieldDef: () => TypeNameMetaFieldDef,
    UniqueArgumentDefinitionNamesRule: () => UniqueArgumentDefinitionNamesRule,
    UniqueArgumentNamesRule: () => UniqueArgumentNamesRule,
    UniqueDirectiveNamesRule: () => UniqueDirectiveNamesRule,
    UniqueDirectivesPerLocationRule: () => UniqueDirectivesPerLocationRule,
    UniqueEnumValueNamesRule: () => UniqueEnumValueNamesRule,
    UniqueFieldDefinitionNamesRule: () => UniqueFieldDefinitionNamesRule,
    UniqueFragmentNamesRule: () => UniqueFragmentNamesRule,
    UniqueInputFieldNamesRule: () => UniqueInputFieldNamesRule,
    UniqueOperationNamesRule: () => UniqueOperationNamesRule,
    UniqueOperationTypesRule: () => UniqueOperationTypesRule,
    UniqueTypeNamesRule: () => UniqueTypeNamesRule,
    UniqueVariableNamesRule: () => UniqueVariableNamesRule,
    ValidationContext: () => ValidationContext,
    ValuesOfCorrectTypeRule: () => ValuesOfCorrectTypeRule,
    VariablesAreInputTypesRule: () => VariablesAreInputTypesRule,
    VariablesInAllowedPositionRule: () => VariablesInAllowedPositionRule,
    __Directive: () => __Directive,
    __DirectiveLocation: () => __DirectiveLocation,
    __EnumValue: () => __EnumValue,
    __Field: () => __Field,
    __InputValue: () => __InputValue,
    __Schema: () => __Schema,
    __Type: () => __Type,
    __TypeKind: () => __TypeKind,
    assertAbstractType: () => assertAbstractType,
    assertCompositeType: () => assertCompositeType,
    assertDirective: () => assertDirective,
    assertEnumType: () => assertEnumType,
    assertEnumValueName: () => assertEnumValueName,
    assertInputObjectType: () => assertInputObjectType,
    assertInputType: () => assertInputType,
    assertInterfaceType: () => assertInterfaceType,
    assertLeafType: () => assertLeafType,
    assertListType: () => assertListType,
    assertName: () => assertName,
    assertNamedType: () => assertNamedType,
    assertNonNullType: () => assertNonNullType,
    assertNullableType: () => assertNullableType,
    assertObjectType: () => assertObjectType,
    assertOutputType: () => assertOutputType,
    assertScalarType: () => assertScalarType,
    assertSchema: () => assertSchema,
    assertType: () => assertType,
    assertUnionType: () => assertUnionType,
    assertValidName: () => assertValidName,
    assertValidSchema: () => assertValidSchema,
    assertWrappingType: () => assertWrappingType,
    astFromValue: () => astFromValue,
    buildASTSchema: () => buildASTSchema,
    buildClientSchema: () => buildClientSchema,
    buildSchema: () => buildSchema,
    coerceInputValue: () => coerceInputValue,
    concatAST: () => concatAST,
    createSourceEventStream: () => createSourceEventStream,
    defaultFieldResolver: () => defaultFieldResolver,
    defaultTypeResolver: () => defaultTypeResolver,
    doTypesOverlap: () => doTypesOverlap,
    execute: () => execute,
    executeSync: () => executeSync,
    extendSchema: () => extendSchema,
    findBreakingChanges: () => findBreakingChanges,
    findDangerousChanges: () => findDangerousChanges,
    formatError: () => formatError,
    getArgumentValues: () => getArgumentValues,
    getDirectiveValues: () => getDirectiveValues,
    getEnterLeaveForKind: () => getEnterLeaveForKind,
    getIntrospectionQuery: () => getIntrospectionQuery,
    getLocation: () => getLocation,
    getNamedType: () => getNamedType,
    getNullableType: () => getNullableType,
    getOperationAST: () => getOperationAST,
    getOperationRootType: () => getOperationRootType,
    getVariableValues: () => getVariableValues,
    getVisitFn: () => getVisitFn,
    graphql: () => graphql,
    graphqlSync: () => graphqlSync,
    introspectionFromSchema: () => introspectionFromSchema,
    introspectionTypes: () => introspectionTypes,
    isAbstractType: () => isAbstractType,
    isCompositeType: () => isCompositeType,
    isConstValueNode: () => isConstValueNode,
    isDefinitionNode: () => isDefinitionNode,
    isDirective: () => isDirective,
    isEnumType: () => isEnumType,
    isEqualType: () => isEqualType,
    isExecutableDefinitionNode: () => isExecutableDefinitionNode,
    isInputObjectType: () => isInputObjectType,
    isInputType: () => isInputType,
    isInterfaceType: () => isInterfaceType,
    isIntrospectionType: () => isIntrospectionType,
    isLeafType: () => isLeafType,
    isListType: () => isListType,
    isNamedType: () => isNamedType,
    isNonNullType: () => isNonNullType,
    isNullableType: () => isNullableType,
    isObjectType: () => isObjectType,
    isOutputType: () => isOutputType,
    isRequiredArgument: () => isRequiredArgument,
    isRequiredInputField: () => isRequiredInputField,
    isScalarType: () => isScalarType,
    isSchema: () => isSchema,
    isSelectionNode: () => isSelectionNode,
    isSpecifiedDirective: () => isSpecifiedDirective,
    isSpecifiedScalarType: () => isSpecifiedScalarType,
    isType: () => isType,
    isTypeDefinitionNode: () => isTypeDefinitionNode,
    isTypeExtensionNode: () => isTypeExtensionNode,
    isTypeNode: () => isTypeNode,
    isTypeSubTypeOf: () => isTypeSubTypeOf,
    isTypeSystemDefinitionNode: () => isTypeSystemDefinitionNode,
    isTypeSystemExtensionNode: () => isTypeSystemExtensionNode,
    isUnionType: () => isUnionType,
    isValidNameError: () => isValidNameError,
    isValueNode: () => isValueNode,
    isWrappingType: () => isWrappingType,
    lexicographicSortSchema: () => lexicographicSortSchema,
    locatedError: () => locatedError,
    parse: () => parse,
    parseConstValue: () => parseConstValue,
    parseType: () => parseType,
    parseValue: () => parseValue,
    print: () => print,
    printError: () => printError,
    printIntrospectionSchema: () => printIntrospectionSchema,
    printLocation: () => printLocation,
    printSchema: () => printSchema,
    printSourceLocation: () => printSourceLocation,
    printType: () => printType,
    resolveObjMapThunk: () => resolveObjMapThunk,
    resolveReadonlyArrayThunk: () => resolveReadonlyArrayThunk,
    responsePathAsArray: () => pathToArray,
    separateOperations: () => separateOperations,
    specifiedDirectives: () => specifiedDirectives,
    specifiedRules: () => specifiedRules,
    specifiedScalarTypes: () => specifiedScalarTypes,
    stripIgnoredCharacters: () => stripIgnoredCharacters,
    subscribe: () => subscribe,
    syntaxError: () => syntaxError,
    typeFromAST: () => typeFromAST,
    validate: () => validate,
    validateSchema: () => validateSchema,
    valueFromAST: () => valueFromAST,
    valueFromASTUntyped: () => valueFromASTUntyped,
    version: () => version2,
    versionInfo: () => versionInfo,
    visit: () => visit,
    visitInParallel: () => visitInParallel,
    visitWithTypeInfo: () => visitWithTypeInfo
  });
  var init_graphql2 = __esm({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/index.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_version();
      init_graphql();
      init_type();
      init_language();
      init_execution();
      init_validation();
      init_error();
      init_utilities();
    }
  });

  // ../../composition/dist/utils/string-constants.js
  var require_string_constants = __commonJS({
    "../../composition/dist/utils/string-constants.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SELECTION_REPRESENTATION = exports2.SCHEMA_UPPER = exports2.SCHEMA = exports2.SCALAR_UPPER = exports2.RESOLVABLE = exports2.REQUIRES = exports2.QUOTATION_JOIN = exports2.QUERY_UPPER = exports2.QUERY = exports2.PROVIDES = exports2.PARENTS = exports2.OVERRIDE = exports2.OBJECT_UPPER = exports2.OPERATION_TO_DEFAULT = exports2.NAME = exports2.MUTATION_UPPER = exports2.MUTATION = exports2.KEY = exports2.LINK = exports2.INACCESSIBLE = exports2.INTERFACE_UPPER = exports2.INPUT_OBJECT_UPPER = exports2.INPUT_FIELD_DEFINITION_UPPER = exports2.INLINE_FRAGMENT_UPPER = exports2.INLINE_FRAGMENT = exports2.FRAGMENT_REPRESENTATION = exports2.FRAGMENT_SPREAD_UPPER = exports2.FRAGMENT_DEFINITION_UPPER = exports2.FIELD_DEFINITION_UPPER = exports2.FIELDS = exports2.FIELD_SET = exports2.FIELD_UPPER = exports2.FIELD = exports2.EXTENSIONS = exports2.EXTENDS = exports2.EXTERNAL = exports2.ENUM_VALUE_UPPER = exports2.ENUM_UPPER = exports2.ENTITY_UNION = exports2.ENTITIES_FIELD = exports2.ENTITIES = exports2.DIRECTIVE_DEFINITION = exports2.DEPRECATED = exports2.DEFAULT_SUBSCRIPTION = exports2.DEFAULT_QUERY = exports2.DEFAULT_MUTATION = exports2.COMPOSE_DIRECTIVE = exports2.BOOLEAN_TYPE = exports2.ARGUMENT_DEFINITION_UPPER = exports2.ANY_SCALAR = void 0;
      exports2.ROOT_TYPES = exports2.VARIABLE_DEFINITION_UPPER = exports2.UNION_UPPER = exports2.UNION = exports2.TAG = exports2.SUBSCRIPTION_UPPER = exports2.SUBSCRIPTION = exports2.STRING_TYPE = exports2.SHAREABLE = exports2.SERVICE_FIELD = exports2.SERVICE_OBJECT = void 0;
      exports2.ANY_SCALAR = "_Any";
      exports2.ARGUMENT_DEFINITION_UPPER = "ARGUMENT_DEFINITION";
      exports2.BOOLEAN_TYPE = "Boolean";
      exports2.COMPOSE_DIRECTIVE = "composeDirective";
      exports2.DEFAULT_MUTATION = "Mutation";
      exports2.DEFAULT_QUERY = "Query";
      exports2.DEFAULT_SUBSCRIPTION = "Subscription";
      exports2.DEPRECATED = "deprecated";
      exports2.DIRECTIVE_DEFINITION = "directive definition";
      exports2.ENTITIES = "entities";
      exports2.ENTITIES_FIELD = "_entities";
      exports2.ENTITY_UNION = "_Entity";
      exports2.ENUM_UPPER = "ENUM";
      exports2.ENUM_VALUE_UPPER = "ENUM_VALUE";
      exports2.EXTERNAL = "external";
      exports2.EXTENDS = "extends";
      exports2.EXTENSIONS = "extensions";
      exports2.FIELD = "field";
      exports2.FIELD_UPPER = "FIELD";
      exports2.FIELD_SET = "FieldSet";
      exports2.FIELDS = "fields";
      exports2.FIELD_DEFINITION_UPPER = "FIELD_DEFINITION";
      exports2.FRAGMENT_DEFINITION_UPPER = "FRAGMENT_DEFINITION";
      exports2.FRAGMENT_SPREAD_UPPER = "FRAGMENT_SPREAD";
      exports2.FRAGMENT_REPRESENTATION = " { ... }";
      exports2.INLINE_FRAGMENT = "inlineFragment";
      exports2.INLINE_FRAGMENT_UPPER = "INLINE_FRAGMENT";
      exports2.INPUT_FIELD_DEFINITION_UPPER = "INPUT_FIELD_DEFINITION";
      exports2.INPUT_OBJECT_UPPER = "INPUT_OBJECT";
      exports2.INTERFACE_UPPER = "INTERFACE";
      exports2.INACCESSIBLE = "inaccessible";
      exports2.LINK = "link";
      exports2.KEY = "key";
      exports2.MUTATION = "Mutation";
      exports2.MUTATION_UPPER = "MUTATION";
      exports2.NAME = "name";
      exports2.OPERATION_TO_DEFAULT = "operationTypeNodeToDefaultType";
      exports2.OBJECT_UPPER = "OBJECT";
      exports2.OVERRIDE = "override";
      exports2.PARENTS = "parents";
      exports2.PROVIDES = "provides";
      exports2.QUERY = "Query";
      exports2.QUERY_UPPER = "QUERY";
      exports2.QUOTATION_JOIN = `", "`;
      exports2.REQUIRES = "requires";
      exports2.RESOLVABLE = "resolvable";
      exports2.SCALAR_UPPER = "SCALAR";
      exports2.SCHEMA = "schema";
      exports2.SCHEMA_UPPER = "SCHEMA";
      exports2.SELECTION_REPRESENTATION = " { ... }";
      exports2.SERVICE_OBJECT = "_Service";
      exports2.SERVICE_FIELD = "_service";
      exports2.SHAREABLE = "shareable";
      exports2.STRING_TYPE = "String";
      exports2.SUBSCRIPTION = "Subscription";
      exports2.SUBSCRIPTION_UPPER = "SUBSCRIPTION";
      exports2.TAG = "tag";
      exports2.UNION = "union";
      exports2.UNION_UPPER = "UNION";
      exports2.VARIABLE_DEFINITION_UPPER = "VARIABLE_DEFINITION";
      exports2.ROOT_TYPES = /* @__PURE__ */ new Set([exports2.MUTATION, exports2.QUERY, exports2.SUBSCRIPTION]);
    }
  });

  // ../../composition/dist/utils/utils.js
  var require_utils = __commonJS({
    "../../composition/dist/utils/utils.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hasSimplePath = exports2.kindToTypeString = exports2.addIterableValuesToSet = exports2.numberToOrdinal = exports2.mapToArrayOfValues = exports2.doSetsHaveAnyOverlap = exports2.getEntriesNotInHashSet = exports2.getAllSetDisparities = exports2.getOrThrowError = exports2.getAllMutualEntries = exports2.areSetsEqual = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var string_constants_1 = require_string_constants();
      var errors_1 = require_errors();
      function areSetsEqual(set, other) {
        if (set.size !== other.size) {
          return false;
        }
        for (const entry of set) {
          if (!other.has(entry)) {
            return false;
          }
        }
        return true;
      }
      exports2.areSetsEqual = areSetsEqual;
      function getAllMutualEntries(set, other) {
        const mutualEntries = /* @__PURE__ */ new Set();
        for (const entry of set) {
          if (other.has(entry)) {
            mutualEntries.add(entry);
          }
        }
        return mutualEntries;
      }
      exports2.getAllMutualEntries = getAllMutualEntries;
      function getOrThrowError(map, key, mapName) {
        const value = map.get(key);
        if (value === void 0) {
          throw (0, errors_1.invalidKeyFatalError)(key, mapName);
        }
        return value;
      }
      exports2.getOrThrowError = getOrThrowError;
      function getAllSetDisparities(set, other) {
        const otherCopy = new Set(other);
        const disparities = [];
        for (const entry of set) {
          if (!otherCopy.delete(entry)) {
            disparities.push(entry);
          }
        }
        for (const entry of otherCopy) {
          disparities.push(entry);
        }
        return disparities;
      }
      exports2.getAllSetDisparities = getAllSetDisparities;
      function getEntriesNotInHashSet(iterable, comparison) {
        const disparities = [];
        for (const entry of iterable) {
          if (!comparison.has(entry)) {
            disparities.push(entry);
          }
        }
        return disparities;
      }
      exports2.getEntriesNotInHashSet = getEntriesNotInHashSet;
      function doSetsHaveAnyOverlap(set, other) {
        for (const entry of set) {
          if (other.has(entry)) {
            return true;
          }
        }
        return false;
      }
      exports2.doSetsHaveAnyOverlap = doSetsHaveAnyOverlap;
      function mapToArrayOfValues(map) {
        const output = [];
        for (const value of map.values()) {
          output.push(value);
        }
        return output;
      }
      exports2.mapToArrayOfValues = mapToArrayOfValues;
      function numberToOrdinal(num) {
        const numString = num.toString();
        const lastNumber = numString[numString.length - 1];
        switch (lastNumber) {
          case "1":
            return `${numString}st`;
          case "2":
            return `${numString}nd`;
          case "3":
            return `${numString}rd`;
          default:
            return `${numString}th`;
        }
      }
      exports2.numberToOrdinal = numberToOrdinal;
      function addIterableValuesToSet(iterable, set) {
        for (const value of iterable) {
          set.add(value);
        }
      }
      exports2.addIterableValuesToSet = addIterableValuesToSet;
      function kindToTypeString(kind) {
        switch (kind) {
          case graphql_1.Kind.ENUM_TYPE_DEFINITION:
            return "enum";
          case graphql_1.Kind.ENUM_TYPE_EXTENSION:
            return "enum extension";
          case graphql_1.Kind.FIELD_DEFINITION:
            return string_constants_1.FIELD;
          case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
            return "input object";
          case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return "input object extension";
          case graphql_1.Kind.INPUT_VALUE_DEFINITION:
            return "input value";
          case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
            return "interface";
          case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
            return "interface extension";
          case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
            return "object";
          case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
            return "object extension";
          case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
            return "scalar";
          case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
            return "scalar extension";
          case graphql_1.Kind.UNION_TYPE_DEFINITION:
            return string_constants_1.UNION;
          case graphql_1.Kind.UNION_TYPE_EXTENSION:
            return "union extension";
          default:
            return kind;
        }
      }
      exports2.kindToTypeString = kindToTypeString;
      var StackSet = class {
        constructor(value) {
          __publicField(this, "set", /* @__PURE__ */ new Set());
          __publicField(this, "stack", []);
          this.push(value);
        }
        has(value) {
          return this.set.has(value);
        }
        push(value) {
          this.stack.push(value);
          this.set.add(value);
        }
        pop() {
          const value = this.stack.pop();
          if (value) {
            this.set.delete(value);
          }
        }
      };
      function hasSimplePath(graph, source, target) {
        if (!graph.hasNode(source) || !graph.hasNode(target)) {
          return false;
        }
        const stack = [graph.outboundNeighbors(source)];
        const visited = new StackSet(source);
        let children, child;
        while (stack.length > 0) {
          children = stack[stack.length - 1];
          child = children.pop();
          if (!child) {
            stack.pop();
            visited.pop();
            continue;
          }
          if (visited.has(child)) {
            continue;
          }
          if (child === target) {
            return true;
          }
          visited.push(child);
          if (!visited.has(target)) {
            stack.push(graph.outboundNeighbors(child));
          } else {
            visited.pop();
          }
        }
        return false;
      }
      exports2.hasSimplePath = hasSimplePath;
    }
  });

  // ../../composition/dist/errors/errors.js
  var require_errors = __commonJS({
    "../../composition/dist/errors/errors.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.unexpectedKindFatalError = exports2.undefinedParentFatalError = exports2.invalidKeyDirectiveError = exports2.invalidEntityKeyError = exports2.invalidNestingErrorMessage = exports2.invalidNestingClosureErrorMessage = exports2.invalidClosingBraceErrorMessage = exports2.invalidOpeningBraceErrorMessage = exports2.invalidGraphQLNameErrorMessage = exports2.invalidKeyDirectiveArgumentErrorMessage = exports2.duplicateDirectiveArgumentDefinitionErrorMessage = exports2.unexpectedDirectiveArgumentErrorMessage = exports2.undefinedRequiredArgumentsErrorMessage = exports2.unexpectedDirectiveArgumentsErrorMessage = exports2.invalidDirectiveLocationErrorMessage = exports2.invalidDirectiveError = exports2.invalidTagDirectiveError = exports2.invalidDeprecatedDirectiveError = exports2.invalidUnionError = exports2.invalidRepeatedDirectiveErrorMessage = exports2.federationRequiredInputFieldError = exports2.federationInvalidParentTypeError = exports2.federationUnexpectedNodeKindError = exports2.undefinedTypeError = exports2.unresolvableFieldError = exports2.undefinedEntityKeyErrorMessage = exports2.undefinedDirectiveError = exports2.shareableFieldDefinitionsError = exports2.operationDefinitionError = exports2.noDefinedUnionMembersError = exports2.noBaseTypeExtensionError = exports2.duplicateOperationTypeDefinitionError = exports2.duplicateTypeDefinitionError = exports2.duplicateValueExtensionError = exports2.duplicateUnionMemberError = exports2.duplicateInterfaceError = exports2.duplicateInterfaceExtensionError = exports2.duplicateFieldExtensionError = exports2.duplicateEnumValueDefinitionError = exports2.duplicateDirectiveDefinitionError = exports2.duplicateFieldDefinitionError = exports2.invalidSubgraphNamesError = exports2.incompatibleExtensionKindsError = exports2.incompatibleSharedEnumError = exports2.incompatibleArgumentDefaultValueTypeError = exports2.incompatibleArgumentDefaultValueError = exports2.incompatibleChildTypesError = exports2.incompatibleArgumentTypesError = exports2.incompatibleExtensionError = exports2.minimumSubgraphRequirementError = void 0;
      exports2.expectedEntityError = exports2.noConcreteTypesForAbstractTypeError = exports2.unexpectedObjectResponseType = exports2.noQueryRootTypeError = exports2.invalidArgumentsError = exports2.duplicateArgumentsError = exports2.invalidRequiredArgumentsError = exports2.unimplementedInterfaceFieldsError = exports2.subgraphInvalidSyntaxError = exports2.invalidRootTypeDefinitionError = exports2.invalidOperationTypeDefinitionError = exports2.invalidSubgraphNameErrorMessage = exports2.subgraphValidationFailureErrorMessage = exports2.subgraphValidationError = exports2.objectInCompositeKeyWithoutSelectionsErrorMessage = exports2.unexpectedParentKindErrorMessage = exports2.invalidKeyFatalError = exports2.unexpectedTypeNodeKindError = exports2.unexpectedDirectiveLocationError = exports2.unexpectedArgumentKindFatalError = exports2.argumentTypeMergeFatalError = exports2.fieldTypeMergeFatalError = exports2.incompatibleParentKindFatalError = exports2.invalidMultiGraphNodeFatalError = void 0;
      var utils_1 = require_utils3();
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var utils_2 = require_utils();
      var string_constants_1 = require_string_constants();
      exports2.minimumSubgraphRequirementError = new Error("At least one subgraph is required for federation.");
      function incompatibleExtensionError(typeName, baseKind, extensionKind) {
        return new Error(`Extension error:
 Incompatible types: "${typeName}" is type "${baseKind}", but an extension of the same name is type "${extensionKind}.`);
      }
      exports2.incompatibleExtensionError = incompatibleExtensionError;
      function incompatibleArgumentTypesError(argName, parentName, childName, expectedType, actualType) {
        return new Error(`Incompatible types when merging two instances of argument "${argName}" for "${parentName}.${childName}":
 Expected type "${expectedType}" but received "${actualType}"`);
      }
      exports2.incompatibleArgumentTypesError = incompatibleArgumentTypesError;
      function incompatibleChildTypesError(parentName, childName, expectedType, actualType) {
        return new Error(`Incompatible types when merging two instances of "${parentName}.${childName}":
 Expected type "${expectedType}" but received "${actualType}"`);
      }
      exports2.incompatibleChildTypesError = incompatibleChildTypesError;
      function incompatibleArgumentDefaultValueError(argName, parentName, childName, expectedValue, actualValue) {
        return new Error(`Incompatible default values when merging two instances of argument "${argName} for "${parentName}.${childName}":
 Expected value "${expectedValue}" but received "${actualValue}"`);
      }
      exports2.incompatibleArgumentDefaultValueError = incompatibleArgumentDefaultValueError;
      function incompatibleArgumentDefaultValueTypeError(argName, parentName, childName, expectedType, actualType) {
        return new Error(`Incompatible default values when merging two instances of argument "${argName} for "${parentName}.${childName}":
 Expected type "${expectedType}" but received "${actualType}"`);
      }
      exports2.incompatibleArgumentDefaultValueTypeError = incompatibleArgumentDefaultValueTypeError;
      function incompatibleSharedEnumError(parentName) {
        return new Error(`Enum "${parentName}" was used as both an input and output but was inconsistently defined across inclusive subgraphs.`);
      }
      exports2.incompatibleSharedEnumError = incompatibleSharedEnumError;
      function incompatibleExtensionKindsError(node, existingKind) {
        const name2 = node.kind === graphql_1.Kind.SCHEMA_EXTENSION ? "schema" : node.name.value;
        return new Error(`Expected extension "${name2}" to be type ${existingKind} but received ${node.kind}.`);
      }
      exports2.incompatibleExtensionKindsError = incompatibleExtensionKindsError;
      function invalidSubgraphNamesError(names, invalidNameErrorMessages) {
        let message = "Subgraphs to be federated must each have a unique, non-empty name.";
        if (names.length > 0) {
          message += '\n The following subgraph names are not unique:\n  "' + names.join('", "') + `"`;
        }
        for (const invalidNameErrorMessage of invalidNameErrorMessages) {
          message += `
 ${invalidNameErrorMessage}`;
        }
        return new Error(message);
      }
      exports2.invalidSubgraphNamesError = invalidSubgraphNamesError;
      function duplicateFieldDefinitionError(fieldName, typeName) {
        return new Error(`Extension error:
 Field "${fieldName} already exists on type "${typeName}".`);
      }
      exports2.duplicateFieldDefinitionError = duplicateFieldDefinitionError;
      function duplicateDirectiveDefinitionError(directiveName) {
        return new Error(`The directive "${directiveName}" has already been defined.`);
      }
      exports2.duplicateDirectiveDefinitionError = duplicateDirectiveDefinitionError;
      function duplicateEnumValueDefinitionError(valueName, typeName) {
        return new Error(`Extension error:
 Value "${valueName}" already exists on enum "${typeName}".`);
      }
      exports2.duplicateEnumValueDefinitionError = duplicateEnumValueDefinitionError;
      function duplicateFieldExtensionError(typeName, childName) {
        return new Error(`Extension error:
 More than one extension attempts to extend type "${typeName}" with the field "${childName}".`);
      }
      exports2.duplicateFieldExtensionError = duplicateFieldExtensionError;
      function duplicateInterfaceExtensionError(interfaceName, typeName) {
        return new Error(`Extension error:
 Interface "${interfaceName}" is already implemented by type "${typeName}".`);
      }
      exports2.duplicateInterfaceExtensionError = duplicateInterfaceExtensionError;
      function duplicateInterfaceError(interfaceName, typeName) {
        return new Error(`Interface "${interfaceName}" can only be defined on type "${typeName}" once.`);
      }
      exports2.duplicateInterfaceError = duplicateInterfaceError;
      function duplicateUnionMemberError(memberName, typeName) {
        return new Error(`Extension error:
 Member "${memberName}" already exists on union "${typeName}".`);
      }
      exports2.duplicateUnionMemberError = duplicateUnionMemberError;
      function duplicateValueExtensionError(parentType, typeName, childName) {
        return new Error(`Extension error:
 More than one extension attempts to extend ${parentType} "${typeName}" with the value "${childName}".`);
      }
      exports2.duplicateValueExtensionError = duplicateValueExtensionError;
      function duplicateTypeDefinitionError(type, typeName) {
        return new Error(`The ${type} "${typeName}" can only be defined once.`);
      }
      exports2.duplicateTypeDefinitionError = duplicateTypeDefinitionError;
      function duplicateOperationTypeDefinitionError(operationTypeName, newTypeName, oldTypeName) {
        return new Error(`The operation type "${operationTypeName}" cannot be defined as "${newTypeName}" because it has already been defined as "${oldTypeName}".`);
      }
      exports2.duplicateOperationTypeDefinitionError = duplicateOperationTypeDefinitionError;
      function noBaseTypeExtensionError(typeName) {
        return new Error(`Extension error:
 Could not extend the type "${typeName}" because no base definition exists.`);
      }
      exports2.noBaseTypeExtensionError = noBaseTypeExtensionError;
      function noDefinedUnionMembersError(unionName) {
        return new Error(`The union "${unionName}" must define at least one union member.`);
      }
      exports2.noDefinedUnionMembersError = noDefinedUnionMembersError;
      function operationDefinitionError(typeName, operationType, actualType) {
        return new Error(`Expected the response type "${typeName}" for operation "${operationType}" to be type object but received "${actualType}.`);
      }
      exports2.operationDefinitionError = operationDefinitionError;
      function shareableFieldDefinitionsError(parent, children) {
        const parentTypeName = parent.node.name.value;
        const errorMessages = [];
        for (const field of parent.fields.values()) {
          const fieldName = field.node.name.value;
          if (!children.has(fieldName)) {
            continue;
          }
          const shareableSubgraphs = [];
          const nonShareableSubgraphs = [];
          for (const [subgraphName, isShareable] of field.subgraphsByShareable) {
            isShareable ? shareableSubgraphs.push(subgraphName) : nonShareableSubgraphs.push(subgraphName);
          }
          if (shareableSubgraphs.length < 1) {
            errorMessages.push(`
 The field "${fieldName}" is defined in the following subgraphs: "${[...field.subgraphs].join('", "')}".
 However, it it is not declared "@shareable" in any of them.`);
          } else {
            errorMessages.push(`
 The field "${fieldName}" is defined and declared "@shareable" in the following subgraphs: "${shareableSubgraphs.join('", "')}".
 However, it is not declared "@shareable" in the following subgraphs: "${nonShareableSubgraphs.join('", "')}".`);
          }
        }
        return new Error(`The object "${parentTypeName}" defines the same fields in multiple subgraphs without the "@shareable" directive:${errorMessages.join("\n")}`);
      }
      exports2.shareableFieldDefinitionsError = shareableFieldDefinitionsError;
      function undefinedDirectiveError(directiveName, hostPath) {
        return new Error(`The directive "${directiveName}" is declared on "${hostPath}", but the directive is not defined in the schema.`);
      }
      exports2.undefinedDirectiveError = undefinedDirectiveError;
      function undefinedEntityKeyErrorMessage(fieldName, objectName) {
        return ` The "fields" argument defines "${fieldName}" as part of a key, but the field "${fieldName}" is not defined on the object "${objectName}".`;
      }
      exports2.undefinedEntityKeyErrorMessage = undefinedEntityKeyErrorMessage;
      function unresolvableFieldError(rootTypeFieldData, fieldName, fieldSubgraphs, unresolvablePath, parentTypeName) {
        const fieldPath = `${parentTypeName}.${fieldName}`;
        return new Error(`The path "${unresolvablePath}" cannot be resolved because:
 The root type field "${rootTypeFieldData.path}" is defined in the following subgraph` + (rootTypeFieldData.subgraphs.size > 1 ? "s" : "") + `: "` + [...rootTypeFieldData.subgraphs].join(string_constants_1.QUOTATION_JOIN) + `".
 However, "${fieldPath}" is only defined in the following subgraph` + (fieldSubgraphs.length > 1 ? "s" : "") + `: "` + fieldSubgraphs + `".
 Consequently, "${fieldPath}" cannot be resolved through the root type field "${rootTypeFieldData.path}".
Potential solutions:
 Convert "${parentTypeName}" into an entity using the "@key" directive.
 Add the shareable root type field "${rootTypeFieldData.path}" to ` + (fieldSubgraphs.length > 1 ? "one of the following subgraphs" : "the following subgraph") + `: "` + fieldSubgraphs.join(string_constants_1.QUOTATION_JOIN) + `".
  For example (note that V1 fields are shareable by default and do not require a directive):
   type ${rootTypeFieldData.typeName} {
     ...
     ${rootTypeFieldData.fieldName}: ${rootTypeFieldData.fieldTypeNodeString} @shareable
   }`);
      }
      exports2.unresolvableFieldError = unresolvableFieldError;
      function undefinedTypeError(typeName) {
        return new Error(`The type "${typeName}" was referenced in the schema, but it was never defined.`);
      }
      exports2.undefinedTypeError = undefinedTypeError;
      var federationUnexpectedNodeKindError = (parentName, fieldName) => new Error(`Unexpected node kind for field "${parentName}.${fieldName}".`);
      exports2.federationUnexpectedNodeKindError = federationUnexpectedNodeKindError;
      var federationInvalidParentTypeError = (parentName, fieldName) => new Error(`Could not find parent type "${parentName}" for field "${fieldName}".`);
      exports2.federationInvalidParentTypeError = federationInvalidParentTypeError;
      var federationRequiredInputFieldError = (parentName, fieldName) => new Error(`Input object field "${parentName}.${fieldName}" is required in at least one subgraph; consequently, "${fieldName}" must be defined in all subgraphs that also define "${parentName}".`);
      exports2.federationRequiredInputFieldError = federationRequiredInputFieldError;
      function invalidRepeatedDirectiveErrorMessage(directiveName, hostPath) {
        return `The definition for the directive "${directiveName}" does not define it as repeatable, but the same directive is declared more than once on type "${hostPath}".`;
      }
      exports2.invalidRepeatedDirectiveErrorMessage = invalidRepeatedDirectiveErrorMessage;
      function invalidUnionError(unionName) {
        return new Error(`Union "${unionName}" must have at least one member.`);
      }
      exports2.invalidUnionError = invalidUnionError;
      exports2.invalidDeprecatedDirectiveError = new Error(`
  Expected the @deprecated directive to have a single optional argument "reason" of the type "String!"
`);
      exports2.invalidTagDirectiveError = new Error(`
  Expected the @tag directive to have a single required argument "name" of the type "String!"
`);
      function invalidDirectiveError(directiveName, hostPath, errorMessages) {
        return new Error(`The directive "${directiveName}" declared on "${hostPath}" is invalid for the following reason` + (errorMessages.length > 1 ? "s:\n" : ":\n") + errorMessages.join("\n"));
      }
      exports2.invalidDirectiveError = invalidDirectiveError;
      function invalidDirectiveLocationErrorMessage(hostPath, kind, directiveName) {
        return ` "${hostPath}" is type "${kind}", but the directive "${directiveName}" does not define "${(0, utils_1.nodeKindToDirectiveLocation)(kind)}" as a valid location.`;
      }
      exports2.invalidDirectiveLocationErrorMessage = invalidDirectiveLocationErrorMessage;
      function unexpectedDirectiveArgumentsErrorMessage(directive, hostPath) {
        var _a;
        const directiveName = directive.name.value;
        const argumentNumber = ((_a = directive.arguments) == null ? void 0 : _a.length) || 1;
        return ` The definition for the directive "${directiveName}" does not define any arguments.
 However, the same directive declared on "${hostPath}" defines ${argumentNumber} argument` + (argumentNumber > 1 ? "s." : ".");
      }
      exports2.unexpectedDirectiveArgumentsErrorMessage = unexpectedDirectiveArgumentsErrorMessage;
      function undefinedRequiredArgumentsErrorMessage(directiveName, hostPath, requiredArguments, missingRequiredArguments = []) {
        return ` The definition for the directive "${directiveName}" defines the following ` + requiredArguments.length + ` required argument` + (requiredArguments.length > 1 ? "s: " : ": ") + `"` + requiredArguments.join('", "') + `".
 However, the same directive that is declared on "${hostPath}" does not define` + (missingRequiredArguments.length > 0 ? ` the following required arguments: "${missingRequiredArguments.join('", "')}"` : ` any arguments.`);
      }
      exports2.undefinedRequiredArgumentsErrorMessage = undefinedRequiredArgumentsErrorMessage;
      function unexpectedDirectiveArgumentErrorMessage(directiveName, argumentName) {
        return ` The definition for the directive "${directiveName}" does not define an argument named "${argumentName}".`;
      }
      exports2.unexpectedDirectiveArgumentErrorMessage = unexpectedDirectiveArgumentErrorMessage;
      function duplicateDirectiveArgumentDefinitionErrorMessage(directiveName, hostPath, argumentName) {
        return ` The directive "${directiveName}" that is declared on "${hostPath}" defines the argument named "${argumentName}" more than once.`;
      }
      exports2.duplicateDirectiveArgumentDefinitionErrorMessage = duplicateDirectiveArgumentDefinitionErrorMessage;
      function invalidKeyDirectiveArgumentErrorMessage(directiveKind) {
        return ` The required argument named "fields" must be type "String" and not type "${directiveKind}".`;
      }
      exports2.invalidKeyDirectiveArgumentErrorMessage = invalidKeyDirectiveArgumentErrorMessage;
      function invalidGraphQLNameErrorMessage(type, name2) {
        return ` The ${type} "${name2}" is an invalid GraphQL name:
  GraphQL names must match the following regex: /[_a-zA-Z][_a-zA-Z0-9]*/`;
      }
      exports2.invalidGraphQLNameErrorMessage = invalidGraphQLNameErrorMessage;
      exports2.invalidOpeningBraceErrorMessage = ` Unexpected brace opening:
  Received an opening brace "{" before the parent value was defined.`;
      exports2.invalidClosingBraceErrorMessage = ` Unexpected brace closure:
  Received a closing brace "}" before any nested values were defined.`;
      exports2.invalidNestingClosureErrorMessage = ` Unexpected brace closure:
  Received a closing brace "}" before its corresponding opening brace "{" was defined.`;
      exports2.invalidNestingErrorMessage = ` Invalid nesting:
  A nested key was terminated without a closing brace "}".`;
      function invalidEntityKeyError(parentTypeName, entityKey, errorMessage) {
        return new Error(`The directive "key" declared on the object "${parentTypeName}" with the "fields" argument value of "${entityKey}" is invalid for the following reason:
` + errorMessage);
      }
      exports2.invalidEntityKeyError = invalidEntityKeyError;
      function invalidKeyDirectiveError(parentTypeName, errorMessages) {
        return new Error(`One or more "key" directives defined on "${parentTypeName}" are invalid for the following reason` + (errorMessages.length > 1 ? "s:\n" : ":\n") + errorMessages.join("\n"));
      }
      exports2.invalidKeyDirectiveError = invalidKeyDirectiveError;
      function undefinedParentFatalError(parentTypeName) {
        return new Error(`Fatal: Expected parent type "${parentTypeName}" to be defined.`);
      }
      exports2.undefinedParentFatalError = undefinedParentFatalError;
      function unexpectedKindFatalError(typeName) {
        return new Error(`Fatal: Unexpected type for "${typeName}"`);
      }
      exports2.unexpectedKindFatalError = unexpectedKindFatalError;
      function invalidMultiGraphNodeFatalError(nodeName) {
        return new Error(`Fatal: Expected node "${nodeName}" to exist in the multi graph.`);
      }
      exports2.invalidMultiGraphNodeFatalError = invalidMultiGraphNodeFatalError;
      function incompatibleParentKindFatalError(parentTypeName, expectedKind, actualKind) {
        return new Error(`Fatal: Expected "${parentTypeName}" to be type ${(0, utils_2.kindToTypeString)(expectedKind)} but received "${(0, utils_2.kindToTypeString)(actualKind)}".`);
      }
      exports2.incompatibleParentKindFatalError = incompatibleParentKindFatalError;
      function fieldTypeMergeFatalError(fieldName) {
        return new Error(`Fatal: Unsuccessfully merged the cross-subgraph types of field "${fieldName}" without producing a type error object.`);
      }
      exports2.fieldTypeMergeFatalError = fieldTypeMergeFatalError;
      function argumentTypeMergeFatalError(argumentName, fieldName) {
        return new Error(`Fatal: Unsuccessfully merged the cross-subgraph types of argument "${argumentName}" on field "${fieldName}" without producing a type error object.`);
      }
      exports2.argumentTypeMergeFatalError = argumentTypeMergeFatalError;
      function unexpectedArgumentKindFatalError(argumentName, fieldName) {
        return new Error(`Fatal: Unexpected type for argument "${argumentName}" on field "${fieldName}".`);
      }
      exports2.unexpectedArgumentKindFatalError = unexpectedArgumentKindFatalError;
      function unexpectedDirectiveLocationError(locationName) {
        return new Error(`Fatal: Unknown directive location "${locationName}".`);
      }
      exports2.unexpectedDirectiveLocationError = unexpectedDirectiveLocationError;
      function unexpectedTypeNodeKindError(childPath) {
        return new Error(`Fatal: Expected all constituent types of "${childPath}" to be one of the following: "LIST_TYPE", "NAMED_TYPE", or "NON_NULL_TYPE".`);
      }
      exports2.unexpectedTypeNodeKindError = unexpectedTypeNodeKindError;
      function invalidKeyFatalError(key, mapName) {
        return new Error(`Fatal: Expected key "${key}" to exist in the map "${mapName}".`);
      }
      exports2.invalidKeyFatalError = invalidKeyFatalError;
      function unexpectedParentKindErrorMessage(parentTypeName, expectedTypeString, actualTypeString) {
        return ` Expected "${parentTypeName}" to be type ${expectedTypeString} but received "${actualTypeString}".`;
      }
      exports2.unexpectedParentKindErrorMessage = unexpectedParentKindErrorMessage;
      function objectInCompositeKeyWithoutSelectionsErrorMessage(fieldName, fieldTypeName) {
        return ` The "fields" argument defines "${fieldName}", which is type "${fieldTypeName}, as part of a key.
 However, "${fieldTypeName}" is an object type; consequently, it must have its own selections to be a valid key.`;
      }
      exports2.objectInCompositeKeyWithoutSelectionsErrorMessage = objectInCompositeKeyWithoutSelectionsErrorMessage;
      function subgraphValidationError(subgraphName, errors) {
        return new Error(`The subgraph "${subgraphName}" could not be federated for the following reason` + (errors.length > 1 ? "s:\n" : "s:\n") + errors.map((error) => error.message).join("\n"));
      }
      exports2.subgraphValidationError = subgraphValidationError;
      exports2.subgraphValidationFailureErrorMessage = new Error(` Fatal: Subgraph validation did not return a valid AST.`);
      function invalidSubgraphNameErrorMessage(index, newName) {
        return `The ${(0, utils_2.numberToOrdinal)(index + 1)} subgraph in the array did not define a name. Consequently, any further errors will temporarily identify this subgraph as "${newName}".`;
      }
      exports2.invalidSubgraphNameErrorMessage = invalidSubgraphNameErrorMessage;
      function invalidOperationTypeDefinitionError(existingOperationType, typeName, newOperationType) {
        return new Error(`The schema definition defines the "${existingOperationType}" operation as type "${typeName}". However, "${typeName}" was also used for the "${newOperationType}" operation.
 If explicitly defined, each operation type must be a unique and valid Object type.`);
      }
      exports2.invalidOperationTypeDefinitionError = invalidOperationTypeDefinitionError;
      function invalidRootTypeDefinitionError(operationType, typeName, defaultTypeName) {
        return new Error(`The schema definition defines the "${operationType}" operation as type "${typeName}". However, the schema also defines another type named "${defaultTypeName}", which is the default (root) type name for the "${operationType}" operation.
For federation, it is only possible to use the default root types names ("Mutation", "Query", "Subscription") as operation definitions. No other definitions with these default root type names are valid.`);
      }
      exports2.invalidRootTypeDefinitionError = invalidRootTypeDefinitionError;
      function subgraphInvalidSyntaxError(error) {
        return new Error(`The subgraph has syntax errors and could not be parsed:
 ${error}`);
      }
      exports2.subgraphInvalidSyntaxError = subgraphInvalidSyntaxError;
      function unimplementedInterfaceFieldsError(parentTypeName, parentTypeString, implementationErrorsMap) {
        const messages = [];
        for (const [interfaceName, implementationErrors] of implementationErrorsMap) {
          let message = ` The implementation of interface "${interfaceName}" by "${parentTypeName}" is invalid because:
`;
          const unimplementedFieldsLength = implementationErrors.unimplementedFields.length;
          if (unimplementedFieldsLength) {
            message += `  The following field${unimplementedFieldsLength > 1 ? "s are" : " is"} not implemented: "` + implementationErrors.unimplementedFields.join('", "') + '"\n';
          }
          for (const [fieldName, invalidFieldImplementation] of implementationErrors.invalidFieldImplementations) {
            const unimplementedArgumentsSize = invalidFieldImplementation.unimplementedArguments.size;
            const invalidArgumentsLength = invalidFieldImplementation.invalidImplementedArguments.length;
            const invalidAdditionalArgumentsSize = invalidFieldImplementation.invalidAdditionalArguments.size;
            message += `  The field "${fieldName}" is invalid because:
`;
            if (unimplementedArgumentsSize) {
              message += `   The following argument${unimplementedArgumentsSize > 1 ? "s are" : " is"} not implemented: "` + [...invalidFieldImplementation.unimplementedArguments].join('", "') + '"\n';
            }
            if (invalidArgumentsLength) {
              message += `   The following implemented argument${invalidArgumentsLength > 1 ? "s are" : " is"} invalid:
`;
              for (const invalidArgument of invalidFieldImplementation.invalidImplementedArguments) {
                message += `    The argument "${invalidArgument.argumentName}" must define type "` + invalidArgument.expectedType + `" and not "${invalidArgument.actualType}"
`;
              }
            }
            if (invalidAdditionalArgumentsSize) {
              message += `   If a field from an interface is implemented, any additional arguments that were not defined on the original interface field must be optional (nullable).
`;
              message += `    The following additional argument` + (invalidFieldImplementation.invalidAdditionalArguments.size > 1 ? `s are` : ` is`) + ` not defined as optional: "` + [...invalidFieldImplementation.invalidAdditionalArguments].join(`", "`) + `"
`;
            }
            if (invalidFieldImplementation.implementedResponseType) {
              message += `   The implemented response type "${invalidFieldImplementation.implementedResponseType}" is not a valid subset (equally or more restrictive) of the response type "` + invalidFieldImplementation.originalResponseType + `" for "${interfaceName}.${fieldName}".`;
            }
          }
          messages.push(message);
        }
        return new Error(`The ${parentTypeString} "${parentTypeName}" has the following interface implementation errors:
` + messages.join("\n"));
      }
      exports2.unimplementedInterfaceFieldsError = unimplementedInterfaceFieldsError;
      function invalidRequiredArgumentsError(typeString, path, errors) {
        let message = `The ${typeString} "${path}" could not be federated because:
`;
        for (const error of errors) {
          message += ` The argument "${error.argumentName}" is required in the following subgraph` + (error.requiredSubgraphs.length > 1 ? "s" : "") + ': "' + error.requiredSubgraphs.join(`", "`) + `"
 However, the argument "${error.argumentName}" is not defined in the following subgraph` + (error.missingSubgraphs.length > 1 ? "s" : "") + ': "' + error.missingSubgraphs.join(`", "`) + `"
 If an argument is required on a ${typeString} in any one subgraph, it must be at least defined as optional on all other definitions of that ${typeString} in all other subgraphs.
`;
        }
        return new Error(message);
      }
      exports2.invalidRequiredArgumentsError = invalidRequiredArgumentsError;
      function duplicateArgumentsError(fieldPath, duplicatedArguments) {
        return new Error(`The field "${fieldPath}" is invalid because:
 The following argument` + (duplicatedArguments.length > 1 ? "s are" : " is") + ` defined more than once: "` + duplicatedArguments.join(`", "`) + `"
`);
      }
      exports2.duplicateArgumentsError = duplicateArgumentsError;
      function invalidArgumentsError(fieldPath, invalidArguments) {
        let message = `The field "${fieldPath}" is invalid because:
 The named type (root type) of an input must be on of Enum, Input Object, or Scalar type. For example: "Float", "[[String!]]!", or "[SomeInputObjectName]"
`;
        for (const invalidArgument of invalidArguments) {
          message += `  The argument "${invalidArgument.argumentName}" defines type "${invalidArgument.typeName}" but the named type "${invalidArgument.namedType}" is type "` + invalidArgument.typeString + `", which is not a valid input type.
`;
        }
        return new Error(message);
      }
      exports2.invalidArgumentsError = invalidArgumentsError;
      exports2.noQueryRootTypeError = new Error(`A valid federated graph must have at least one populated query root type.
 For example:
  type Query {
    dummy: String
  }`);
      function unexpectedObjectResponseType(fieldPath, actualTypeString) {
        return new Error(`Expected the path "${fieldPath}" to have the response type Enum, Interface, Object, Scalar, or Union but received ${actualTypeString}.`);
      }
      exports2.unexpectedObjectResponseType = unexpectedObjectResponseType;
      function noConcreteTypesForAbstractTypeError(typeString, abstractTypeName) {
        return new Error(`Expected ${typeString} "${abstractTypeName}" to define at least one ` + (typeString === string_constants_1.UNION ? "member" : "object that implements the interface") + ` but received none`);
      }
      exports2.noConcreteTypesForAbstractTypeError = noConcreteTypesForAbstractTypeError;
      function expectedEntityError(typeName) {
        return new Error(`Expected object "${typeName}" to define a "key" directive, but it defines no directives.`);
      }
      exports2.expectedEntityError = expectedEntityError;
    }
  });

  // ../../composition/dist/federation/utils.js
  var require_utils2 = __commonJS({
    "../../composition/dist/federation/utils.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.newPersistedDirectivesContainer = exports2.MergeMethod = exports2.EXECUTABLE_DIRECTIVE_LOCATIONS = void 0;
      var string_constants_1 = require_string_constants();
      exports2.EXECUTABLE_DIRECTIVE_LOCATIONS = /* @__PURE__ */ new Set([
        string_constants_1.FIELD_UPPER,
        string_constants_1.FRAGMENT_DEFINITION_UPPER,
        string_constants_1.FRAGMENT_SPREAD_UPPER,
        string_constants_1.INLINE_FRAGMENT_UPPER,
        string_constants_1.MUTATION_UPPER,
        string_constants_1.QUERY_UPPER,
        string_constants_1.SUBSCRIPTION_UPPER
      ]);
      var MergeMethod;
      (function(MergeMethod2) {
        MergeMethod2[MergeMethod2["UNION"] = 0] = "UNION";
        MergeMethod2[MergeMethod2["INTERSECTION"] = 1] = "INTERSECTION";
        MergeMethod2[MergeMethod2["CONSISTENT"] = 2] = "CONSISTENT";
      })(MergeMethod || (exports2.MergeMethod = MergeMethod = {}));
      function newPersistedDirectivesContainer() {
        return {
          deprecated: {},
          directives: /* @__PURE__ */ new Map(),
          tags: /* @__PURE__ */ new Map()
        };
      }
      exports2.newPersistedDirectivesContainer = newPersistedDirectivesContainer;
    }
  });

  // ../../composition/dist/ast/utils.js
  var require_utils3 = __commonJS({
    "../../composition/dist/ast/utils.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.setLongestDescriptionForNode = exports2.formatDescription = exports2.addConcreteTypesForUnion = exports2.addConcreteTypesForImplementedInterfaces = exports2.pushPersistedDirectivesAndGetNode = exports2.mergeExecutableDirectiveLocations = exports2.extractExecutableDirectiveLocations = exports2.extractNameNodeStringsToSet = exports2.getInlineFragmentString = exports2.isKindAbstract = exports2.operationTypeNodeToDefaultType = exports2.nodeKindToDirectiveLocation = exports2.setToNamedTypeNodeArray = exports2.stringToNamedTypeNode = exports2.setToNameNodeArray = exports2.stringArrayToNameNodeArray = exports2.stringToNameNode = exports2.areBaseAndExtensionKindsCompatible = exports2.isNodeOverridden = exports2.isNodeExternal = exports2.isNodeShareable = exports2.extractInterfaces = exports2.getEntityKeyExtractionResults = exports2.getEntityKeyExtractionResult = exports2.extractEntityKeys = exports2.isNodeExtension = exports2.isObjectLikeNodeEntity = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var string_constants_1 = require_string_constants();
      var errors_1 = require_errors();
      var utils_1 = require_utils();
      var utils_2 = require_utils2();
      function isObjectLikeNodeEntity(node) {
        var _a;
        if (node.kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION || node.kind === graphql_1.Kind.INTERFACE_TYPE_EXTENSION || !((_a = node.directives) == null ? void 0 : _a.length)) {
          return false;
        }
        for (const directive of node.directives) {
          if (directive.name.value === string_constants_1.KEY) {
            return true;
          }
        }
        return false;
      }
      exports2.isObjectLikeNodeEntity = isObjectLikeNodeEntity;
      function isNodeExtension(node) {
        var _a;
        if (!((_a = node.directives) == null ? void 0 : _a.length)) {
          return false;
        }
        for (const directive of node.directives) {
          if (directive.name.value === string_constants_1.EXTENDS) {
            return true;
          }
        }
        return false;
      }
      exports2.isNodeExtension = isNodeExtension;
      function extractEntityKeys(node, keySet, errors) {
        var _a;
        if (!((_a = node.directives) == null ? void 0 : _a.length)) {
          return keySet;
        }
        const typeName = node.name.value;
        for (const directive of node.directives) {
          if (directive.name.value === string_constants_1.KEY) {
            if (!directive.arguments) {
              errors.push((0, errors_1.invalidKeyDirectiveError)(typeName, [
                (0, errors_1.undefinedRequiredArgumentsErrorMessage)(string_constants_1.KEY, typeName, [string_constants_1.NAME])
              ]));
              continue;
            }
            for (const arg of directive.arguments) {
              if (arg.name.value !== string_constants_1.FIELDS) {
                continue;
              }
              if (arg.value.kind !== graphql_1.Kind.STRING) {
                continue;
              }
              keySet.add(arg.value.value);
            }
          }
        }
        return keySet;
      }
      exports2.extractEntityKeys = extractEntityKeys;
      function getEntityKeyExtractionResult(rawEntityKey, parentTypeName) {
        const rootKey = { parent: "", siblings: [] };
        const entityKeyMap = /* @__PURE__ */ new Map([[parentTypeName, rootKey]]);
        const keyPath = [parentTypeName];
        let currentSegment = "";
        let segmentEnded = true;
        let currentKey;
        rawEntityKey = rawEntityKey.replaceAll(/[,\n]/g, " ");
        for (const char of rawEntityKey) {
          currentKey = (0, utils_1.getOrThrowError)(entityKeyMap, keyPath.join("."), "entityKeyMap");
          switch (char) {
            case " ":
              segmentEnded = true;
              break;
            case "{":
              if (!currentSegment) {
                return { error: (0, errors_1.invalidEntityKeyError)(parentTypeName, rawEntityKey, errors_1.invalidOpeningBraceErrorMessage) };
              }
              currentKey.siblings.push(currentSegment);
              const nestedKey = { parent: currentSegment, siblings: [] };
              if (currentKey.nestedKeys) {
                currentKey.nestedKeys.push(nestedKey);
              } else {
                currentKey.nestedKeys = [nestedKey];
              }
              keyPath.push(currentSegment);
              currentSegment = "";
              entityKeyMap.set(keyPath.join("."), nestedKey);
              segmentEnded = true;
              break;
            case "}":
              if (currentSegment) {
                currentKey.siblings.push(currentSegment);
              }
              if (currentKey.siblings.length < 1) {
                return { error: (0, errors_1.invalidEntityKeyError)(parentTypeName, rawEntityKey, errors_1.invalidClosingBraceErrorMessage) };
              }
              if (keyPath.join(".") === parentTypeName) {
                return { error: (0, errors_1.invalidEntityKeyError)(parentTypeName, rawEntityKey, errors_1.invalidNestingClosureErrorMessage) };
              }
              currentSegment = "";
              keyPath.pop();
              segmentEnded = true;
              break;
            default:
              if (currentSegment && segmentEnded) {
                if (!currentSegment.match(/[_A-Za-z][_A-Za-z0-9]*/)) {
                  return {
                    error: (0, errors_1.invalidEntityKeyError)(parentTypeName, rawEntityKey, (0, errors_1.invalidGraphQLNameErrorMessage)("field", currentSegment))
                  };
                }
                currentKey.siblings.push(currentSegment);
                currentSegment = char;
              } else {
                currentSegment += char;
              }
              segmentEnded = false;
          }
        }
        if (keyPath.join(".") !== parentTypeName) {
          return { error: (0, errors_1.invalidEntityKeyError)(parentTypeName, rawEntityKey, errors_1.invalidNestingErrorMessage) };
        }
        if (currentSegment) {
          rootKey.siblings.push(currentSegment);
        }
        return { entityKey: rootKey };
      }
      exports2.getEntityKeyExtractionResult = getEntityKeyExtractionResult;
      function getEntityKeyExtractionResults(node, entityKeyMap) {
        var _a;
        const parentTypeName = node.name.value;
        if (!((_a = node.directives) == null ? void 0 : _a.length)) {
          return { entityKeyMap, errors: [(0, errors_1.expectedEntityError)(parentTypeName)] };
        }
        const rawEntityKeys = /* @__PURE__ */ new Set();
        const errorMessages = [];
        for (const directive of node.directives) {
          if (directive.name.value !== string_constants_1.KEY) {
            continue;
          }
          if (!directive.arguments || directive.arguments.length < 1) {
            errorMessages.push((0, errors_1.undefinedRequiredArgumentsErrorMessage)(string_constants_1.KEY, parentTypeName, [string_constants_1.FIELDS]));
            continue;
          }
          for (const arg of directive.arguments) {
            const argumentName = arg.name.value;
            if (arg.name.value === string_constants_1.RESOLVABLE) {
              continue;
            }
            if (arg.name.value !== string_constants_1.FIELDS) {
              errorMessages.push((0, errors_1.unexpectedDirectiveArgumentErrorMessage)(string_constants_1.KEY, argumentName));
              break;
            }
            if (arg.value.kind !== graphql_1.Kind.STRING) {
              errorMessages.push((0, errors_1.invalidKeyDirectiveArgumentErrorMessage)(arg.value.kind));
              break;
            }
            rawEntityKeys.add(arg.value.value);
          }
        }
        const errors = [];
        if (errorMessages.length > 0) {
          errors.push((0, errors_1.invalidKeyDirectiveError)(parentTypeName, errorMessages));
        }
        for (const rawEntityKey of rawEntityKeys) {
          const existingEntityKey = entityKeyMap.get(rawEntityKey);
          if (existingEntityKey) {
            continue;
          }
          const { entityKey, error } = getEntityKeyExtractionResult(rawEntityKey, parentTypeName);
          if (error) {
            errors.push(error);
            continue;
          }
          if (!entityKey) {
            throw new Error();
          }
          entityKeyMap.set(rawEntityKey, entityKey);
        }
        return { entityKeyMap, errors };
      }
      exports2.getEntityKeyExtractionResults = getEntityKeyExtractionResults;
      function extractInterfaces(node, interfaces, errors) {
        if (!node.interfaces) {
          return interfaces;
        }
        const parentTypeName = node.name.value;
        for (const face of node.interfaces) {
          const name2 = face.name.value;
          if (errors && interfaces.has(name2)) {
            errors.push((0, errors_1.duplicateInterfaceError)(name2, parentTypeName));
            continue;
          }
          interfaces.add(name2);
        }
        return interfaces;
      }
      exports2.extractInterfaces = extractInterfaces;
      function isNodeShareable(node) {
        if (!node.directives) {
          return false;
        }
        for (const directive of node.directives) {
          if (directive.name.value === string_constants_1.SHAREABLE) {
            return true;
          }
        }
        return false;
      }
      exports2.isNodeShareable = isNodeShareable;
      function isNodeExternal(node) {
        if (!node.directives) {
          return false;
        }
        for (const directive of node.directives) {
          if (directive.name.value === string_constants_1.EXTERNAL) {
            return true;
          }
        }
        return false;
      }
      exports2.isNodeExternal = isNodeExternal;
      function isNodeOverridden(node) {
        if (!node.directives) {
          return false;
        }
        for (const directive of node.directives) {
          if (directive.name.value === string_constants_1.OVERRIDE) {
            return true;
          }
        }
        return false;
      }
      exports2.isNodeOverridden = isNodeOverridden;
      function areBaseAndExtensionKindsCompatible(baseKind, extensionKind, typeName) {
        switch (baseKind) {
          case graphql_1.Kind.ENUM_TYPE_DEFINITION:
            return extensionKind === graphql_1.Kind.ENUM_TYPE_EXTENSION;
          case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
            return extensionKind === graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION;
          case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
            return extensionKind === graphql_1.Kind.INTERFACE_TYPE_EXTENSION;
          case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
            return extensionKind === graphql_1.Kind.OBJECT_TYPE_EXTENSION;
          case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
            return extensionKind === graphql_1.Kind.SCALAR_TYPE_EXTENSION;
          case graphql_1.Kind.UNION_TYPE_DEFINITION:
            return extensionKind === graphql_1.Kind.UNION_TYPE_EXTENSION;
          default:
            throw (0, errors_1.unexpectedKindFatalError)(typeName);
        }
      }
      exports2.areBaseAndExtensionKindsCompatible = areBaseAndExtensionKindsCompatible;
      function stringToNameNode(value) {
        return {
          kind: graphql_1.Kind.NAME,
          value
        };
      }
      exports2.stringToNameNode = stringToNameNode;
      function stringArrayToNameNodeArray(values) {
        const nameNodes = [];
        for (const value of values) {
          nameNodes.push(stringToNameNode(value));
        }
        return nameNodes;
      }
      exports2.stringArrayToNameNodeArray = stringArrayToNameNodeArray;
      function setToNameNodeArray(set) {
        const nameNodes = [];
        for (const value of set) {
          nameNodes.push(stringToNameNode(value));
        }
        return nameNodes;
      }
      exports2.setToNameNodeArray = setToNameNodeArray;
      function stringToNamedTypeNode(value) {
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: stringToNameNode(value)
        };
      }
      exports2.stringToNamedTypeNode = stringToNamedTypeNode;
      function setToNamedTypeNodeArray(set) {
        const namedTypeNodes = [];
        for (const entry of set) {
          namedTypeNodes.push(stringToNamedTypeNode(entry));
        }
        return namedTypeNodes;
      }
      exports2.setToNamedTypeNodeArray = setToNamedTypeNodeArray;
      function nodeKindToDirectiveLocation(kind) {
        switch (kind) {
          case graphql_1.Kind.ENUM_TYPE_DEFINITION:
          case graphql_1.Kind.ENUM_TYPE_EXTENSION:
            return string_constants_1.ENUM_UPPER;
          case graphql_1.Kind.ENUM_VALUE_DEFINITION:
            return string_constants_1.ENUM_VALUE_UPPER;
          case graphql_1.Kind.FIELD_DEFINITION:
            return string_constants_1.FIELD_DEFINITION_UPPER;
          case graphql_1.Kind.FRAGMENT_DEFINITION:
            return string_constants_1.FRAGMENT_DEFINITION_UPPER;
          case graphql_1.Kind.FRAGMENT_SPREAD:
            return string_constants_1.FRAGMENT_SPREAD_UPPER;
          case graphql_1.Kind.INLINE_FRAGMENT:
            return string_constants_1.INLINE_FRAGMENT_UPPER;
          case graphql_1.Kind.INPUT_VALUE_DEFINITION:
            return string_constants_1.INPUT_FIELD_DEFINITION_UPPER;
          case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return string_constants_1.INPUT_OBJECT_UPPER;
          case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
          case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
            return string_constants_1.INTERFACE_UPPER;
          case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
          case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
            return string_constants_1.OBJECT_UPPER;
          case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
          case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
            return string_constants_1.SCALAR_UPPER;
          case graphql_1.Kind.SCHEMA_DEFINITION:
          case graphql_1.Kind.SCHEMA_EXTENSION:
            return string_constants_1.SCHEMA_UPPER;
          case graphql_1.Kind.UNION_TYPE_DEFINITION:
          case graphql_1.Kind.UNION_TYPE_EXTENSION:
            return string_constants_1.UNION_UPPER;
          default:
            return kind;
        }
      }
      exports2.nodeKindToDirectiveLocation = nodeKindToDirectiveLocation;
      exports2.operationTypeNodeToDefaultType = /* @__PURE__ */ new Map([
        [graphql_1.OperationTypeNode.MUTATION, string_constants_1.MUTATION],
        [graphql_1.OperationTypeNode.QUERY, string_constants_1.QUERY],
        [graphql_1.OperationTypeNode.SUBSCRIPTION, string_constants_1.SUBSCRIPTION]
      ]);
      function isKindAbstract(kind) {
        return kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION || kind === graphql_1.Kind.UNION_TYPE_DEFINITION;
      }
      exports2.isKindAbstract = isKindAbstract;
      function getInlineFragmentString(parentTypeName) {
        return ` ... on ${parentTypeName} `;
      }
      exports2.getInlineFragmentString = getInlineFragmentString;
      function extractNameNodeStringsToSet(nodes, set) {
        for (const node of nodes) {
          set.add(node.value);
        }
        return set;
      }
      exports2.extractNameNodeStringsToSet = extractNameNodeStringsToSet;
      function extractExecutableDirectiveLocations(nodes, set) {
        for (const node of nodes) {
          const name2 = node.value;
          if (utils_2.EXECUTABLE_DIRECTIVE_LOCATIONS.has(name2)) {
            set.add(name2);
          }
        }
        return set;
      }
      exports2.extractExecutableDirectiveLocations = extractExecutableDirectiveLocations;
      function mergeExecutableDirectiveLocations(nodes, directiveContainer) {
        const mergedSet = /* @__PURE__ */ new Set();
        for (const node of nodes) {
          const name2 = node.value;
          if (directiveContainer.executableLocations.has(name2)) {
            mergedSet.add(name2);
          }
        }
        directiveContainer.executableLocations = mergedSet;
        return mergedSet;
      }
      exports2.mergeExecutableDirectiveLocations = mergeExecutableDirectiveLocations;
      function pushPersistedDirectivesAndGetNode(container) {
        const persistedDirectives = [...container.directives.tags.values()];
        const deprecatedDirective = container.directives.deprecated.directive;
        if (deprecatedDirective) {
          persistedDirectives.push(deprecatedDirective);
        }
        for (const directives of container.directives.directives.values()) {
          persistedDirectives.push(...directives);
        }
        container.node.directives = persistedDirectives;
        return container.node;
      }
      exports2.pushPersistedDirectivesAndGetNode = pushPersistedDirectivesAndGetNode;
      function addConcreteTypesForImplementedInterfaces(node, abstractToConcreteTypeNames) {
        if (!node.interfaces || node.interfaces.length < 1) {
          return;
        }
        const concreteTypeName = node.name.value;
        for (const iFace of node.interfaces) {
          const interfaceName = iFace.name.value;
          const concreteTypes = abstractToConcreteTypeNames.get(interfaceName);
          if (concreteTypes) {
            concreteTypes.add(concreteTypeName);
          } else {
            abstractToConcreteTypeNames.set(interfaceName, /* @__PURE__ */ new Set([concreteTypeName]));
          }
        }
      }
      exports2.addConcreteTypesForImplementedInterfaces = addConcreteTypesForImplementedInterfaces;
      function addConcreteTypesForUnion(node, abstractToConcreteTypeNames) {
        if (!node.types || node.types.length < 1) {
          return;
        }
        const unionName = node.name.value;
        for (const member of node.types) {
          const memberName = member.name.value;
          const concreteTypes = abstractToConcreteTypeNames.get(unionName);
          if (concreteTypes) {
            concreteTypes.add(memberName);
          } else {
            abstractToConcreteTypeNames.set(unionName, /* @__PURE__ */ new Set([memberName]));
          }
        }
      }
      exports2.addConcreteTypesForUnion = addConcreteTypesForUnion;
      function formatDescription(description) {
        if (!description) {
          return description;
        }
        let value = description.value;
        if (description.block) {
          const lines = value.split("\n");
          if (lines.length > 1) {
            value = lines.map((line) => line.trimStart()).join("\n");
          }
        }
        return __spreadProps(__spreadValues({}, description), { value, block: true });
      }
      exports2.formatDescription = formatDescription;
      function setLongestDescriptionForNode(existingNode, newDescription) {
        if (!newDescription) {
          return;
        }
        if (!existingNode.description || newDescription.value.length > existingNode.description.value.length) {
          existingNode.description = __spreadProps(__spreadValues({}, newDescription), { block: true });
        }
      }
      exports2.setLongestDescriptionForNode = setLongestDescriptionForNode;
    }
  });

  // ../../composition/dist/ast/ast.js
  var require_ast = __commonJS({
    "../../composition/dist/ast/ast.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.unionTypeDefinitionNodeToMutable = exports2.maximumTypeNesting = exports2.scalarTypeDefinitionNodeToMutable = exports2.objectTypeExtensionNodeToMutableDefinitionNode = exports2.objectTypeExtensionNodeToMutable = exports2.objectTypeDefinitionNodeToMutable = exports2.interfaceTypeDefinitionNodeToMutable = exports2.inputValueDefinitionNodeToMutable = exports2.inputObjectTypeDefinitionNodeToMutable = exports2.fieldDefinitionNodeToMutable = exports2.enumValueDefinitionNodeToMutable = exports2.enumTypeDefinitionNodeToMutable = exports2.directiveDefinitionNodeToMutable = exports2.deepCopyTypeNode = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var errors_1 = require_errors();
      var utils_1 = require_utils3();
      function deepCopyFieldsAndInterfaces(node, fields, interfaces) {
        if (node.fields) {
          for (const field of node.fields) {
            fields.push(fieldDefinitionNodeToMutable(field, node.name.value));
          }
        }
        if (node.interfaces) {
          for (const face of node.interfaces) {
            interfaces.push(__spreadValues({}, face));
          }
        }
      }
      function deepCopyTypeNode(node, parentName, fieldName) {
        const deepCopy = { kind: node.kind };
        let lastTypeNode = deepCopy;
        for (let i2 = 0; i2 < exports2.maximumTypeNesting; i2++) {
          switch (node.kind) {
            case graphql_1.Kind.NAMED_TYPE:
              lastTypeNode.name = __spreadValues({}, node.name);
              return deepCopy;
            case graphql_1.Kind.LIST_TYPE:
              lastTypeNode.kind = node.kind;
              lastTypeNode.type = { kind: node.type.kind };
              lastTypeNode = lastTypeNode.type;
              node = node.type;
              continue;
            case graphql_1.Kind.NON_NULL_TYPE:
              lastTypeNode.kind = node.kind;
              lastTypeNode.type = { kind: node.type.kind };
              lastTypeNode = lastTypeNode.type;
              node = node.type;
              continue;
            default:
              throw (0, errors_1.federationUnexpectedNodeKindError)(parentName, fieldName);
          }
        }
        throw new Error(`Field ${parentName}.${fieldName} has more than 30 layers of nesting, or there is a cyclical error.`);
      }
      exports2.deepCopyTypeNode = deepCopyTypeNode;
      function directiveDefinitionNodeToMutable(node) {
        return {
          arguments: node.arguments ? [...node.arguments] : void 0,
          description: (0, utils_1.formatDescription)(node.description),
          kind: node.kind,
          locations: [...node.locations],
          name: __spreadValues({}, node.name),
          repeatable: node.repeatable
        };
      }
      exports2.directiveDefinitionNodeToMutable = directiveDefinitionNodeToMutable;
      function enumTypeDefinitionNodeToMutable(node) {
        const values = [];
        if (node.values) {
          for (const value of node.values) {
            values.push(enumValueDefinitionNodeToMutable(value));
          }
        }
        return {
          description: (0, utils_1.formatDescription)(node.description),
          kind: node.kind,
          name: __spreadValues({}, node.name),
          values
        };
      }
      exports2.enumTypeDefinitionNodeToMutable = enumTypeDefinitionNodeToMutable;
      function enumValueDefinitionNodeToMutable(node) {
        return {
          description: (0, utils_1.formatDescription)(node.description),
          kind: node.kind,
          name: __spreadValues({}, node.name)
        };
      }
      exports2.enumValueDefinitionNodeToMutable = enumValueDefinitionNodeToMutable;
      function fieldDefinitionNodeToMutable(node, parentName) {
        const args = [];
        if (node.arguments) {
          for (const argument of node.arguments) {
            args.push(inputValueDefinitionNodeToMutable(argument, node.name.value));
          }
        }
        return {
          arguments: args,
          description: (0, utils_1.formatDescription)(node.description),
          kind: node.kind,
          name: __spreadValues({}, node.name),
          type: deepCopyTypeNode(node.type, parentName, node.name.value)
        };
      }
      exports2.fieldDefinitionNodeToMutable = fieldDefinitionNodeToMutable;
      function inputObjectTypeDefinitionNodeToMutable(node) {
        const fields = [];
        if (node.fields) {
          for (const field of node.fields) {
            fields.push(inputValueDefinitionNodeToMutable(field, node.name.value));
          }
        }
        return {
          description: (0, utils_1.formatDescription)(node.description),
          fields,
          kind: node.kind,
          name: __spreadValues({}, node.name)
        };
      }
      exports2.inputObjectTypeDefinitionNodeToMutable = inputObjectTypeDefinitionNodeToMutable;
      function inputValueDefinitionNodeToMutable(node, parentName) {
        return {
          defaultValue: node.defaultValue ? __spreadValues({}, node.defaultValue) : void 0,
          description: (0, utils_1.formatDescription)(node.description),
          directives: node.directives ? [...node.directives] : void 0,
          kind: node.kind,
          name: __spreadValues({}, node.name),
          type: deepCopyTypeNode(node.type, parentName, node.name.value)
        };
      }
      exports2.inputValueDefinitionNodeToMutable = inputValueDefinitionNodeToMutable;
      function interfaceTypeDefinitionNodeToMutable(node) {
        const fields = [];
        const interfaces = [];
        deepCopyFieldsAndInterfaces(node, fields, interfaces);
        return {
          description: (0, utils_1.formatDescription)(node.description),
          fields,
          interfaces,
          kind: node.kind,
          name: __spreadValues({}, node.name)
        };
      }
      exports2.interfaceTypeDefinitionNodeToMutable = interfaceTypeDefinitionNodeToMutable;
      function objectTypeDefinitionNodeToMutable(node) {
        const fields = [];
        const interfaces = [];
        deepCopyFieldsAndInterfaces(node, fields, interfaces);
        return {
          description: (0, utils_1.formatDescription)(node.description),
          fields,
          interfaces,
          kind: node.kind,
          name: __spreadValues({}, node.name)
        };
      }
      exports2.objectTypeDefinitionNodeToMutable = objectTypeDefinitionNodeToMutable;
      function objectTypeExtensionNodeToMutable(node) {
        const fields = [];
        const interfaces = [];
        deepCopyFieldsAndInterfaces(node, fields, interfaces);
        return {
          fields,
          interfaces,
          kind: node.kind,
          name: __spreadValues({}, node.name)
        };
      }
      exports2.objectTypeExtensionNodeToMutable = objectTypeExtensionNodeToMutable;
      function objectTypeExtensionNodeToMutableDefinitionNode(node) {
        const fields = [];
        const interfaces = [];
        deepCopyFieldsAndInterfaces(node, fields, interfaces);
        return {
          fields,
          interfaces,
          kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
          name: __spreadValues({}, node.name)
        };
      }
      exports2.objectTypeExtensionNodeToMutableDefinitionNode = objectTypeExtensionNodeToMutableDefinitionNode;
      function scalarTypeDefinitionNodeToMutable(node) {
        return {
          description: (0, utils_1.formatDescription)(node.description),
          kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
          name: __spreadValues({}, node.name)
        };
      }
      exports2.scalarTypeDefinitionNodeToMutable = scalarTypeDefinitionNodeToMutable;
      exports2.maximumTypeNesting = 30;
      function unionTypeDefinitionNodeToMutable(node) {
        const types = [];
        if (node.types) {
          for (const member of node.types) {
            types.push(__spreadValues({}, member));
          }
        }
        return {
          description: (0, utils_1.formatDescription)(node.description),
          kind: node.kind,
          name: __spreadValues({}, node.name),
          types
        };
      }
      exports2.unionTypeDefinitionNodeToMutable = unionTypeDefinitionNodeToMutable;
    }
  });

  // ../../composition/dist/type-merging/type-merging.js
  var require_type_merging = __commonJS({
    "../../composition/dist/type-merging/type-merging.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getNamedTypeForChild = exports2.isTypeRequired = exports2.getMostRestrictiveMergedTypeNode = exports2.getLeastRestrictiveMergedTypeNode = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var errors_1 = require_errors();
      var ast_1 = require_ast();
      var DivergentType;
      (function(DivergentType2) {
        DivergentType2[DivergentType2["NONE"] = 0] = "NONE";
        DivergentType2[DivergentType2["CURRENT"] = 1] = "CURRENT";
        DivergentType2[DivergentType2["OTHER"] = 2] = "OTHER";
      })(DivergentType || (DivergentType = {}));
      function getMergedTypeNode(current, other, parentName, childName, mostRestrictive) {
        other = (0, ast_1.deepCopyTypeNode)(other, parentName, childName);
        const mergedTypeNode = { kind: current.kind };
        let divergentType = DivergentType.NONE;
        let lastTypeNode = mergedTypeNode;
        for (let i2 = 0; i2 < ast_1.maximumTypeNesting; i2++) {
          if (current.kind === other.kind) {
            switch (current.kind) {
              case graphql_1.Kind.NAMED_TYPE:
                const otherName = other.name.value;
                if (current.name.value !== otherName) {
                  return { typeErrors: [current.name.value, otherName] };
                }
                lastTypeNode.kind = current.kind;
                lastTypeNode.name = current.name;
                return { typeNode: mergedTypeNode };
              case graphql_1.Kind.LIST_TYPE:
                lastTypeNode.kind = current.kind;
                lastTypeNode.type = { kind: current.type.kind };
                lastTypeNode = lastTypeNode.type;
                current = current.type;
                other = other.type;
                continue;
              case graphql_1.Kind.NON_NULL_TYPE:
                lastTypeNode.kind = current.kind;
                lastTypeNode.type = { kind: current.type.kind };
                lastTypeNode = lastTypeNode.type;
                current = current.type;
                other = other.type;
                continue;
              default:
                throw (0, errors_1.federationUnexpectedNodeKindError)(parentName, childName);
            }
          }
          if (current.kind === graphql_1.Kind.NON_NULL_TYPE) {
            if (divergentType === DivergentType.OTHER) {
              return { typeErrors: [current.kind, other.kind] };
            } else {
              divergentType = DivergentType.CURRENT;
            }
            if (mostRestrictive) {
              lastTypeNode.kind = current.kind;
              lastTypeNode.type = { kind: current.type.kind };
              lastTypeNode = lastTypeNode.type;
            }
            current = current.type;
            continue;
          }
          if (other.kind === graphql_1.Kind.NON_NULL_TYPE) {
            if (divergentType === DivergentType.CURRENT) {
              return {
                typeErrors: [other.kind, current.kind]
              };
            } else {
              divergentType = DivergentType.OTHER;
            }
            if (mostRestrictive) {
              lastTypeNode.kind = other.kind;
              lastTypeNode.type = { kind: other.type.kind };
              lastTypeNode = lastTypeNode.type;
            }
            other = other.type;
            continue;
          }
          return { typeErrors: [current.kind, other.kind] };
        }
        throw new Error(`Field ${parentName}.${childName} has more than ${ast_1.maximumTypeNesting} layers of nesting, or there is a cyclical error.`);
      }
      function getLeastRestrictiveMergedTypeNode(current, other, parentName, childName) {
        return getMergedTypeNode(current, other, parentName, childName, false);
      }
      exports2.getLeastRestrictiveMergedTypeNode = getLeastRestrictiveMergedTypeNode;
      function getMostRestrictiveMergedTypeNode(current, other, parentName, fieldName) {
        return getMergedTypeNode(current, other, parentName, fieldName, true);
      }
      exports2.getMostRestrictiveMergedTypeNode = getMostRestrictiveMergedTypeNode;
      function isTypeRequired(node) {
        return node.kind === graphql_1.Kind.NON_NULL_TYPE;
      }
      exports2.isTypeRequired = isTypeRequired;
      function getNamedTypeForChild(childPath, typeNode) {
        switch (typeNode.kind) {
          case graphql_1.Kind.NAMED_TYPE:
            return typeNode.name.value;
          case graphql_1.Kind.LIST_TYPE:
          case graphql_1.Kind.NON_NULL_TYPE:
            return getNamedTypeForChild(childPath, typeNode.type);
          default:
            throw (0, errors_1.unexpectedTypeNodeKindError)(childPath);
        }
      }
      exports2.getNamedTypeForChild = getNamedTypeForChild;
    }
  });

  // ../../composition/dist/normalization/utils.js
  var require_utils4 = __commonJS({
    "../../composition/dist/normalization/utils.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getDefinedArgumentsForDirective = exports2.getDirectiveDefinitionArgumentSets = exports2.validateEntityKeys = exports2.areNodeKindAndDirectiveLocationCompatible = exports2.unionContainerToNode = exports2.schemaContainerToNode = exports2.scalarContainerToNode = exports2.objectLikeContainerToNode = exports2.inputObjectContainerToNode = exports2.enumContainerToNode = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var utils_1 = require_utils();
      var utils_2 = require_utils3();
      var string_constants_1 = require_string_constants();
      var type_merging_1 = require_type_merging();
      var errors_1 = require_errors();
      function childMapToValueArray(factory, map, parentTypeName) {
        const valueArray = [];
        for (const childContainer of map.values()) {
          const childPath = `${parentTypeName}.${childContainer.name}`;
          factory.validateChildDirectives(childContainer, childPath);
          valueArray.push(childContainer.node);
        }
        return valueArray;
      }
      function enumContainerToNode(factory, baseEnum, enumExtension) {
        factory.mergeDirectives(baseEnum.directives, enumExtension);
        return {
          description: baseEnum.description,
          directives: factory.getValidatedAndNormalizedParentDirectives(baseEnum),
          kind: baseEnum.kind,
          name: baseEnum.name,
          values: childMapToValueArray(factory, baseEnum.values, baseEnum.name.value)
        };
      }
      exports2.enumContainerToNode = enumContainerToNode;
      function inputObjectContainerToNode(factory, baseInputObject, inputObjectExtension) {
        factory.mergeDirectives(baseInputObject.directives, inputObjectExtension);
        return {
          description: baseInputObject.description,
          directives: factory.getValidatedAndNormalizedParentDirectives(baseInputObject),
          fields: childMapToValueArray(factory, baseInputObject.fields, baseInputObject.name.value),
          kind: baseInputObject.kind,
          name: baseInputObject.name
        };
      }
      exports2.inputObjectContainerToNode = inputObjectContainerToNode;
      function objectLikeContainerToNode(factory, baseObjectLike, objectLikeExtension) {
        factory.mergeDirectives(baseObjectLike.directives, objectLikeExtension);
        const description = baseObjectLike.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION ? void 0 : baseObjectLike.description;
        return {
          description,
          directives: factory.getValidatedAndNormalizedParentDirectives(baseObjectLike),
          fields: childMapToValueArray(factory, baseObjectLike.fields, baseObjectLike.name.value),
          interfaces: (0, utils_2.setToNamedTypeNodeArray)(baseObjectLike.interfaces),
          kind: baseObjectLike.kind,
          name: baseObjectLike.name
        };
      }
      exports2.objectLikeContainerToNode = objectLikeContainerToNode;
      function scalarContainerToNode(factory, baseScalar, scalarExtension) {
        factory.mergeDirectives(baseScalar.directives, scalarExtension);
        return {
          description: baseScalar.description,
          directives: factory.getValidatedAndNormalizedParentDirectives(baseScalar),
          kind: baseScalar.kind,
          name: baseScalar.name
        };
      }
      exports2.scalarContainerToNode = scalarContainerToNode;
      function schemaContainerToNode(factory, baseSchema) {
        return {
          description: baseSchema.description,
          directives: factory.getValidatedAndNormalizedParentDirectives(baseSchema),
          kind: baseSchema.kind,
          operationTypes: (0, utils_1.mapToArrayOfValues)(baseSchema.operationTypes)
        };
      }
      exports2.schemaContainerToNode = schemaContainerToNode;
      function unionContainerToNode(factory, baseUnion, unionExtension) {
        factory.mergeUniqueUnionMembers(baseUnion, unionExtension);
        factory.mergeDirectives(baseUnion.directives, unionExtension);
        return {
          description: baseUnion.description,
          directives: factory.getValidatedAndNormalizedParentDirectives(baseUnion),
          kind: baseUnion.kind,
          name: baseUnion.name,
          types: (0, utils_1.mapToArrayOfValues)(baseUnion.types)
        };
      }
      exports2.unionContainerToNode = unionContainerToNode;
      function areNodeKindAndDirectiveLocationCompatible(kind, directiveDefinitionNode) {
        for (const location of directiveDefinitionNode.locations) {
          const locationName = location.value.toUpperCase();
          switch (locationName) {
            case string_constants_1.ARGUMENT_DEFINITION_UPPER:
              if (kind === graphql_1.Kind.INPUT_VALUE_DEFINITION) {
                return true;
              }
              break;
            case string_constants_1.ENUM_UPPER:
              if (kind === graphql_1.Kind.ENUM_TYPE_DEFINITION || kind === graphql_1.Kind.ENUM_TYPE_EXTENSION) {
                return true;
              }
              break;
            case string_constants_1.ENUM_VALUE_UPPER:
              if (kind === graphql_1.Kind.ENUM_VALUE_DEFINITION) {
                return true;
              }
              break;
            case string_constants_1.FIELD_UPPER:
              if (kind === graphql_1.Kind.FIELD) {
                return true;
              }
              break;
            case string_constants_1.FIELD_DEFINITION_UPPER:
              if (kind === graphql_1.Kind.FIELD_DEFINITION) {
                return true;
              }
              break;
            case string_constants_1.INLINE_FRAGMENT_UPPER:
              if (kind === graphql_1.Kind.INLINE_FRAGMENT) {
                return true;
              }
              break;
            case string_constants_1.INPUT_FIELD_DEFINITION_UPPER:
              if (kind === graphql_1.Kind.INPUT_VALUE_DEFINITION) {
                return true;
              }
              break;
            case string_constants_1.INPUT_OBJECT_UPPER:
              if (kind === graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION || kind === graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION) {
                return true;
              }
              break;
            case string_constants_1.INTERFACE_UPPER:
              if (kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION || kind === graphql_1.Kind.INTERFACE_TYPE_EXTENSION) {
                return true;
              }
              break;
            case string_constants_1.OBJECT_UPPER:
              if (kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION) {
                return true;
              }
              break;
            case string_constants_1.FRAGMENT_DEFINITION_UPPER:
              if (kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
                return true;
              }
              break;
            case string_constants_1.FRAGMENT_SPREAD_UPPER:
              if (kind === graphql_1.Kind.FRAGMENT_SPREAD) {
                return true;
              }
              break;
            case string_constants_1.SCALAR_UPPER:
              if (kind === graphql_1.Kind.SCALAR_TYPE_DEFINITION || kind === graphql_1.Kind.SCALAR_TYPE_EXTENSION) {
                return true;
              }
              break;
            case string_constants_1.SCHEMA_UPPER:
              if (kind === graphql_1.Kind.SCHEMA_DEFINITION || kind === graphql_1.Kind.SCHEMA_EXTENSION) {
                return true;
              }
              break;
            case string_constants_1.UNION_UPPER:
              if (kind === graphql_1.Kind.UNION_TYPE_DEFINITION || kind === graphql_1.Kind.UNION_TYPE_EXTENSION) {
                return true;
              }
              break;
            case string_constants_1.VARIABLE_DEFINITION_UPPER:
              if (kind === graphql_1.Kind.VARIABLE_DEFINITION) {
                return true;
              }
              break;
            case string_constants_1.QUERY_UPPER:
            case string_constants_1.MUTATION_UPPER:
            case string_constants_1.SUBSCRIPTION_UPPER:
              if (kind === graphql_1.Kind.OPERATION_DEFINITION) {
                return true;
              }
              break;
            default:
              throw (0, errors_1.unexpectedDirectiveLocationError)(locationName);
          }
        }
        return false;
      }
      exports2.areNodeKindAndDirectiveLocationCompatible = areNodeKindAndDirectiveLocationCompatible;
      function validateEntityKeys(factory, objectTypeName, isExtension = false) {
        const entityKeyMap = factory.entityMap.get(objectTypeName);
        if (!entityKeyMap) {
          return;
        }
        for (const entityKey of entityKeyMap.values()) {
          const errorMessages = [];
          if (isExtension) {
            validateExtensionEntityKey(factory, objectTypeName, entityKey, errorMessages);
          } else {
            validateBaseObjectEntityKey(factory, objectTypeName, entityKey, errorMessages);
          }
          if (errorMessages.length > 0) {
            factory.errors.push((0, errors_1.invalidKeyDirectiveError)(objectTypeName, errorMessages));
          }
        }
      }
      exports2.validateEntityKeys = validateEntityKeys;
      function validateEntityKey(factory, entityKey, object, objectTypeName, errorMessages) {
        var _a;
        const keyFields = /* @__PURE__ */ new Set();
        for (const fieldName of entityKey.siblings) {
          const field = object.fields.get(fieldName);
          if (!field) {
            errorMessages.push((0, errors_1.undefinedEntityKeyErrorMessage)(fieldName, objectTypeName));
            continue;
          }
          keyFields.add(fieldName);
          if ((_a = entityKey.nestedKeys) == null ? void 0 : _a.some((nestedKey) => nestedKey.parent === fieldName)) {
            continue;
          }
          const fieldPath = `${objectTypeName}.${fieldName}`;
          const fieldTypeName = (0, type_merging_1.getNamedTypeForChild)(fieldPath, field.node.type);
          const parentContainer = factory.parents.get(fieldTypeName);
          if (parentContainer && parentContainer.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION) {
            errorMessages.push((0, errors_1.objectInCompositeKeyWithoutSelectionsErrorMessage)(fieldName, fieldTypeName));
          }
        }
        if (keyFields.size > 0) {
          const entityKeyParent = factory.keyFieldsByParentTypeName.get(objectTypeName);
          if (entityKeyParent) {
            (0, utils_1.addIterableValuesToSet)(keyFields, entityKeyParent);
          } else {
            factory.keyFieldsByParentTypeName.set(objectTypeName, keyFields);
          }
        }
        if (errorMessages.length > 0 || !entityKey.nestedKeys) {
          return;
        }
        for (const nestedKey of entityKey.nestedKeys) {
          const field = object.fields.get(nestedKey.parent);
          if (!field) {
            errorMessages.push((0, errors_1.undefinedEntityKeyErrorMessage)(nestedKey.parent, objectTypeName));
            continue;
          }
          const fieldPath = `${objectTypeName}.${field.name}`;
          validateBaseObjectEntityKey(factory, (0, type_merging_1.getNamedTypeForChild)(fieldPath, field.node.type), nestedKey, errorMessages);
        }
      }
      function validateBaseObjectEntityKey(factory, objectTypeName, entityKey, errorMessages) {
        const object = factory.parents.get(objectTypeName) || factory.extensions.get(objectTypeName);
        if (!object) {
          throw (0, errors_1.undefinedParentFatalError)(objectTypeName);
        }
        if (object.kind !== graphql_1.Kind.OBJECT_TYPE_DEFINITION && object.kind !== graphql_1.Kind.OBJECT_TYPE_EXTENSION) {
          errorMessages.push((0, errors_1.unexpectedParentKindErrorMessage)(objectTypeName, "object or object extension", (0, utils_1.kindToTypeString)(object.kind)));
          return;
        }
        validateEntityKey(factory, entityKey, object, objectTypeName, errorMessages);
      }
      function validateExtensionEntityKey(factory, objectTypeName, entityKey, errorMessages) {
        const objectExtension = factory.extensions.get(objectTypeName);
        if (!objectExtension) {
          throw (0, errors_1.undefinedParentFatalError)(objectTypeName);
        }
        if (objectExtension.kind !== graphql_1.Kind.OBJECT_TYPE_EXTENSION) {
          errorMessages.push((0, errors_1.unexpectedParentKindErrorMessage)(objectTypeName, objectExtension.kind, graphql_1.Kind.OBJECT_TYPE_EXTENSION));
          return;
        }
        validateEntityKey(factory, entityKey, objectExtension, objectTypeName, errorMessages);
      }
      function getDirectiveDefinitionArgumentSets(args, allArguments, requiredArguments) {
        for (const argument of args) {
          const argumentName = argument.name.value;
          allArguments.add(argumentName);
          if (argument.type.kind === graphql_1.Kind.NON_NULL_TYPE && !argument.defaultValue) {
            requiredArguments.add(argumentName);
          }
        }
      }
      exports2.getDirectiveDefinitionArgumentSets = getDirectiveDefinitionArgumentSets;
      function getDefinedArgumentsForDirective(args, allArguments, directiveName, hostPath, errorMessages) {
        const definedArguments = /* @__PURE__ */ new Set();
        for (const argument of args) {
          const argumentName = argument.name.value;
          if (!allArguments.has(argumentName)) {
            errorMessages.push((0, errors_1.unexpectedDirectiveArgumentErrorMessage)(directiveName, argumentName));
            continue;
          }
          if (definedArguments.has(argumentName)) {
            errorMessages.push((0, errors_1.duplicateDirectiveArgumentDefinitionErrorMessage)(directiveName, hostPath, argumentName));
            continue;
          }
          definedArguments.add(argumentName);
        }
        return definedArguments;
      }
      exports2.getDefinedArgumentsForDirective = getDefinedArgumentsForDirective;
    }
  });

  // ../../composition/dist/utils/constants.js
  var require_constants = __commonJS({
    "../../composition/dist/utils/constants.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.VERSION_TWO_DIRECTIVE_DEFINITIONS = exports2.BASE_DIRECTIVE_DEFINITIONS = exports2.VERSION_TWO_DIRECTIVES = exports2.VERSION_ONE_DIRECTIVES = exports2.BASE_SCALARS = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var utils_1 = require_utils3();
      var string_constants_1 = require_string_constants();
      exports2.BASE_SCALARS = /* @__PURE__ */ new Set(["_Any", "_Entities", "Boolean", "Float", "ID", "Int", "String"]);
      exports2.VERSION_ONE_DIRECTIVES = /* @__PURE__ */ new Set([
        string_constants_1.DEPRECATED,
        string_constants_1.EXTENDS,
        string_constants_1.EXTERNAL,
        string_constants_1.KEY,
        string_constants_1.PROVIDES,
        string_constants_1.REQUIRES,
        string_constants_1.TAG
      ]);
      exports2.VERSION_TWO_DIRECTIVES = /* @__PURE__ */ new Set([
        string_constants_1.COMPOSE_DIRECTIVE,
        string_constants_1.LINK,
        string_constants_1.OVERRIDE,
        string_constants_1.INACCESSIBLE,
        string_constants_1.SHAREABLE
      ]);
      exports2.BASE_DIRECTIVE_DEFINITIONS = [
        /* directive @deprecated(reason: String = "No longer supported") on ARGUMENT_DEFINITION | ENUM_VALUE |
           FIELD_DEFINITION | INPUT_FIELD_DEFINITION
        */
        {
          arguments: [
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)("reason"),
              type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.STRING_TYPE),
              defaultValue: {
                kind: graphql_1.Kind.STRING,
                value: "No longer supported"
              }
            }
          ],
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: (0, utils_1.stringArrayToNameNodeArray)([
            string_constants_1.ARGUMENT_DEFINITION_UPPER,
            string_constants_1.ENUM_VALUE_UPPER,
            string_constants_1.FIELD_DEFINITION_UPPER,
            string_constants_1.INPUT_FIELD_DEFINITION_UPPER
          ]),
          name: (0, utils_1.stringToNameNode)(string_constants_1.DEPRECATED),
          repeatable: false
        },
        // directive @extends on INTERFACE | OBJECT
        {
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: (0, utils_1.stringArrayToNameNodeArray)([string_constants_1.INTERFACE_UPPER, string_constants_1.OBJECT_UPPER]),
          name: (0, utils_1.stringToNameNode)(string_constants_1.EXTENDS),
          repeatable: false
        },
        // directive @external on FIELD_DEFINITION | OBJECT
        {
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: (0, utils_1.stringArrayToNameNodeArray)([string_constants_1.FIELD_DEFINITION_UPPER, string_constants_1.OBJECT_UPPER]),
          name: (0, utils_1.stringToNameNode)(string_constants_1.EXTERNAL),
          repeatable: false
        },
        // TODO handle FieldSet
        // directive @key(fields: String!) on OBJECT
        {
          arguments: [
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)(string_constants_1.FIELDS),
              type: {
                kind: graphql_1.Kind.NON_NULL_TYPE,
                type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.STRING_TYPE)
              }
            },
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)(string_constants_1.RESOLVABLE),
              type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.BOOLEAN_TYPE),
              defaultValue: {
                kind: graphql_1.Kind.BOOLEAN,
                value: true
              }
            }
          ],
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: [(0, utils_1.stringToNameNode)(string_constants_1.OBJECT_UPPER)],
          name: (0, utils_1.stringToNameNode)(string_constants_1.KEY),
          repeatable: true
        },
        // TODO handle FieldSet
        // directive @provides(fields: FieldSet!) on FIELD_DEFINITION
        {
          arguments: [
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)(string_constants_1.FIELDS),
              type: {
                kind: graphql_1.Kind.NON_NULL_TYPE,
                type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.STRING_TYPE)
              }
            }
          ],
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: [(0, utils_1.stringToNameNode)(string_constants_1.FIELD_DEFINITION_UPPER)],
          name: (0, utils_1.stringToNameNode)(string_constants_1.PROVIDES),
          repeatable: false
        },
        // TODO handle FieldSet
        // directive @requires(fields: FieldSet!) on FIELD_DEFINITION
        {
          arguments: [
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)(string_constants_1.FIELDS),
              type: {
                kind: graphql_1.Kind.NON_NULL_TYPE,
                type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.STRING_TYPE)
              }
            }
          ],
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: [(0, utils_1.stringToNameNode)(string_constants_1.FIELD_DEFINITION_UPPER)],
          name: (0, utils_1.stringToNameNode)(string_constants_1.REQUIRES),
          repeatable: false
        },
        /* directive @tag(name: String!) on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_OBJECT |
           INPUT_FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR | UNION
        */
        {
          arguments: [
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)(string_constants_1.NAME),
              type: {
                kind: graphql_1.Kind.NON_NULL_TYPE,
                type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.STRING_TYPE)
              }
            }
          ],
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: (0, utils_1.stringArrayToNameNodeArray)([
            string_constants_1.ARGUMENT_DEFINITION_UPPER,
            string_constants_1.ENUM_UPPER,
            string_constants_1.ENUM_VALUE_UPPER,
            string_constants_1.FIELD_DEFINITION_UPPER,
            string_constants_1.INPUT_FIELD_DEFINITION_UPPER,
            string_constants_1.INPUT_OBJECT_UPPER,
            string_constants_1.INTERFACE_UPPER,
            string_constants_1.OBJECT_UPPER,
            string_constants_1.SCALAR_UPPER,
            string_constants_1.UNION_UPPER
          ]),
          name: (0, utils_1.stringToNameNode)(string_constants_1.TAG),
          repeatable: true
        }
      ];
      exports2.VERSION_TWO_DIRECTIVE_DEFINITIONS = [
        // @composeDirective is currently unimplemented
        /* directive @composeDirective(name: String!) repeatable on SCHEMA */
        {
          arguments: [
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)(string_constants_1.NAME),
              type: {
                kind: graphql_1.Kind.NON_NULL_TYPE,
                type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.STRING_TYPE)
              }
            }
          ],
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: (0, utils_1.stringArrayToNameNodeArray)([string_constants_1.SCHEMA_UPPER]),
          name: (0, utils_1.stringToNameNode)(string_constants_1.COMPOSE_DIRECTIVE),
          repeatable: true
        },
        /* directive @inaccessible on ARGUMENT_DEFINITION | ENUM | ENUM_VALUE | FIELD_DEFINITION | INPUT_OBJECT |
           INPUT_FIELD_DEFINITION | INTERFACE | OBJECT | SCALAR | UNION
        */
        {
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: (0, utils_1.stringArrayToNameNodeArray)([
            string_constants_1.ARGUMENT_DEFINITION_UPPER,
            string_constants_1.ENUM_UPPER,
            string_constants_1.ENUM_VALUE_UPPER,
            string_constants_1.FIELD_DEFINITION_UPPER,
            string_constants_1.INPUT_FIELD_DEFINITION_UPPER,
            string_constants_1.INPUT_OBJECT_UPPER,
            string_constants_1.INTERFACE_UPPER,
            string_constants_1.OBJECT_UPPER,
            string_constants_1.SCALAR_UPPER,
            string_constants_1.UNION_UPPER
          ]),
          name: (0, utils_1.stringToNameNode)(string_constants_1.INACCESSIBLE),
          repeatable: false
        },
        // directive @link(url: String!, as: String!, for: String, import: [String]) repeatable on SCHEMA
        {
          arguments: [
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)("url"),
              type: {
                kind: graphql_1.Kind.NON_NULL_TYPE,
                type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.STRING_TYPE)
              }
            },
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)("as"),
              type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.STRING_TYPE)
            },
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)("for"),
              type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.STRING_TYPE)
            },
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)("import"),
              type: {
                kind: graphql_1.Kind.LIST_TYPE,
                type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.STRING_TYPE)
              }
            }
          ],
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: (0, utils_1.stringArrayToNameNodeArray)([string_constants_1.SCHEMA_UPPER]),
          name: (0, utils_1.stringToNameNode)(string_constants_1.LINK),
          repeatable: true
        },
        // directive @override(from: String!) on FIELD_DEFINITION
        {
          arguments: [
            {
              kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
              name: (0, utils_1.stringToNameNode)("from"),
              type: {
                kind: graphql_1.Kind.NON_NULL_TYPE,
                type: (0, utils_1.stringToNamedTypeNode)(string_constants_1.STRING_TYPE)
              }
            }
          ],
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: (0, utils_1.stringArrayToNameNodeArray)([string_constants_1.FIELD_DEFINITION_UPPER]),
          name: (0, utils_1.stringToNameNode)(string_constants_1.OVERRIDE),
          repeatable: false
        },
        // directive @shareable on FIELD_DEFINITION | OBJECT
        {
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          locations: (0, utils_1.stringArrayToNameNodeArray)([string_constants_1.FIELD_DEFINITION_UPPER, string_constants_1.OBJECT_UPPER]),
          name: (0, utils_1.stringToNameNode)(string_constants_1.SHAREABLE),
          repeatable: false
        }
      ];
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/devAssert.js
  var require_devAssert = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/devAssert.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.devAssert = devAssert2;
      function devAssert2(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(message);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isObjectLike.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.isObjectLike = isObjectLike2;
      function isObjectLike2(value) {
        return typeof value == "object" && value !== null;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/invariant.js
  var require_invariant = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/invariant.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.invariant = invariant2;
      function invariant2(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(
            message != null ? message : "Unexpected invariant triggered."
          );
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/location.js
  var require_location = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/location.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.getLocation = getLocation2;
      var _invariant = require_invariant();
      var LineRegExp2 = /\r\n|[\n\r]/g;
      function getLocation2(source, position) {
        let lastLineStart = 0;
        let line = 1;
        for (const match of source.body.matchAll(LineRegExp2)) {
          typeof match.index === "number" || (0, _invariant.invariant)(false);
          if (match.index >= position) {
            break;
          }
          lastLineStart = match.index + match[0].length;
          line += 1;
        }
        return {
          line,
          column: position + 1 - lastLineStart
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printLocation.js
  var require_printLocation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printLocation.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.printLocation = printLocation2;
      exports2.printSourceLocation = printSourceLocation2;
      var _location = require_location();
      function printLocation2(location) {
        return printSourceLocation2(
          location.source,
          (0, _location.getLocation)(location.source, location.start)
        );
      }
      function printSourceLocation2(source, sourceLocation) {
        const firstLineColumnOffset = source.locationOffset.column - 1;
        const body = "".padStart(firstLineColumnOffset) + source.body;
        const lineIndex = sourceLocation.line - 1;
        const lineOffset = source.locationOffset.line - 1;
        const lineNum = sourceLocation.line + lineOffset;
        const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
        const columnNum = sourceLocation.column + columnOffset;
        const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
        const lines = body.split(/\r\n|[\n\r]/g);
        const locationLine = lines[lineIndex];
        if (locationLine.length > 120) {
          const subLineIndex = Math.floor(columnNum / 80);
          const subLineColumnNum = columnNum % 80;
          const subLines = [];
          for (let i2 = 0; i2 < locationLine.length; i2 += 80) {
            subLines.push(locationLine.slice(i2, i2 + 80));
          }
          return locationStr + printPrefixedLines2([
            [`${lineNum} |`, subLines[0]],
            ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
            ["|", "^".padStart(subLineColumnNum)],
            ["|", subLines[subLineIndex + 1]]
          ]);
        }
        return locationStr + printPrefixedLines2([
          // Lines specified like this: ["prefix", "string"],
          [`${lineNum - 1} |`, lines[lineIndex - 1]],
          [`${lineNum} |`, locationLine],
          ["|", "^".padStart(columnNum)],
          [`${lineNum + 1} |`, lines[lineIndex + 1]]
        ]);
      }
      function printPrefixedLines2(lines) {
        const existingLines = lines.filter(([_, line]) => line !== void 0);
        const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
        return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/error/GraphQLError.js
  var require_GraphQLError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/error/GraphQLError.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.GraphQLError = void 0;
      exports2.formatError = formatError2;
      exports2.printError = printError2;
      var _isObjectLike = require_isObjectLike();
      var _location = require_location();
      var _printLocation = require_printLocation();
      function toNormalizedOptions2(args) {
        const firstArg = args[0];
        if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
          return {
            nodes: firstArg,
            source: args[1],
            positions: args[2],
            path: args[3],
            originalError: args[4],
            extensions: args[5]
          };
        }
        return firstArg;
      }
      var GraphQLError2 = class _GraphQLError extends Error {
        /**
         * An array of `{ line, column }` locations within the source GraphQL document
         * which correspond to this error.
         *
         * Errors during validation often contain multiple locations, for example to
         * point out two things with the same name. Errors during execution include a
         * single location, the field which produced the error.
         *
         * Enumerable, and appears in the result of JSON.stringify().
         */
        /**
         * An array describing the JSON-path into the execution response which
         * corresponds to this error. Only included for errors during execution.
         *
         * Enumerable, and appears in the result of JSON.stringify().
         */
        /**
         * An array of GraphQL AST Nodes corresponding to this error.
         */
        /**
         * The source GraphQL document for the first location of this error.
         *
         * Note that if this Error represents more than one node, the source may not
         * represent nodes after the first node.
         */
        /**
         * An array of character offsets within the source GraphQL document
         * which correspond to this error.
         */
        /**
         * The original error thrown from a field resolver during execution.
         */
        /**
         * Extension fields to add to the formatted error.
         */
        /**
         * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
         */
        constructor(message, ...rawArgs) {
          var _this$nodes, _nodeLocations$, _ref;
          const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions2(rawArgs);
          super(message);
          this.name = "GraphQLError";
          this.path = path !== null && path !== void 0 ? path : void 0;
          this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
          this.nodes = undefinedIfEmpty2(
            Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
          );
          const nodeLocations = undefinedIfEmpty2(
            (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
          );
          this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
          this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
          this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map(
            (loc) => (0, _location.getLocation)(loc.source, loc.start)
          );
          const originalExtensions = (0, _isObjectLike.isObjectLike)(
            originalError === null || originalError === void 0 ? void 0 : originalError.extensions
          ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
          this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
          Object.defineProperties(this, {
            message: {
              writable: true,
              enumerable: true
            },
            name: {
              enumerable: false
            },
            nodes: {
              enumerable: false
            },
            source: {
              enumerable: false
            },
            positions: {
              enumerable: false
            },
            originalError: {
              enumerable: false
            }
          });
          if (originalError !== null && originalError !== void 0 && originalError.stack) {
            Object.defineProperty(this, "stack", {
              value: originalError.stack,
              writable: true,
              configurable: true
            });
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, _GraphQLError);
          } else {
            Object.defineProperty(this, "stack", {
              value: Error().stack,
              writable: true,
              configurable: true
            });
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLError";
        }
        toString() {
          let output = this.message;
          if (this.nodes) {
            for (const node of this.nodes) {
              if (node.loc) {
                output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
              }
            }
          } else if (this.source && this.locations) {
            for (const location of this.locations) {
              output += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
            }
          }
          return output;
        }
        toJSON() {
          const formattedError = {
            message: this.message
          };
          if (this.locations != null) {
            formattedError.locations = this.locations;
          }
          if (this.path != null) {
            formattedError.path = this.path;
          }
          if (this.extensions != null && Object.keys(this.extensions).length > 0) {
            formattedError.extensions = this.extensions;
          }
          return formattedError;
        }
      };
      exports2.GraphQLError = GraphQLError2;
      function undefinedIfEmpty2(array) {
        return array === void 0 || array.length === 0 ? void 0 : array;
      }
      function printError2(error) {
        return error.toString();
      }
      function formatError2(error) {
        return error.toJSON();
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/inspect.js
  var require_inspect = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/inspect.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.inspect = inspect2;
      var MAX_ARRAY_LENGTH2 = 10;
      var MAX_RECURSIVE_DEPTH2 = 2;
      function inspect2(value) {
        return formatValue2(value, []);
      }
      function formatValue2(value, seenValues) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(value);
          case "function":
            return value.name ? `[function ${value.name}]` : "[function]";
          case "object":
            return formatObjectValue2(value, seenValues);
          default:
            return String(value);
        }
      }
      function formatObjectValue2(value, previouslySeenValues) {
        if (value === null) {
          return "null";
        }
        if (previouslySeenValues.includes(value)) {
          return "[Circular]";
        }
        const seenValues = [...previouslySeenValues, value];
        if (isJSONable2(value)) {
          const jsonValue = value.toJSON();
          if (jsonValue !== value) {
            return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
          }
        } else if (Array.isArray(value)) {
          return formatArray2(value, seenValues);
        }
        return formatObject2(value, seenValues);
      }
      function isJSONable2(value) {
        return typeof value.toJSON === "function";
      }
      function formatObject2(object, seenValues) {
        const entries = Object.entries(object);
        if (entries.length === 0) {
          return "{}";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
          return "[" + getObjectTag2(object) + "]";
        }
        const properties = entries.map(
          ([key, value]) => key + ": " + formatValue2(value, seenValues)
        );
        return "{ " + properties.join(", ") + " }";
      }
      function formatArray2(array, seenValues) {
        if (array.length === 0) {
          return "[]";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
          return "[Array]";
        }
        const len = Math.min(MAX_ARRAY_LENGTH2, array.length);
        const remaining = array.length - len;
        const items = [];
        for (let i2 = 0; i2 < len; ++i2) {
          items.push(formatValue2(array[i2], seenValues));
        }
        if (remaining === 1) {
          items.push("... 1 more item");
        } else if (remaining > 1) {
          items.push(`... ${remaining} more items`);
        }
        return "[" + items.join(", ") + "]";
      }
      function getObjectTag2(object) {
        const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
        if (tag === "Object" && typeof object.constructor === "function") {
          const name2 = object.constructor.name;
          if (typeof name2 === "string" && name2 !== "") {
            return name2;
          }
        }
        return tag;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/ast.js
  var require_ast2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/ast.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.Token = exports2.QueryDocumentKeys = exports2.OperationTypeNode = exports2.Location = void 0;
      exports2.isNode = isNode2;
      var Location2 = class {
        /**
         * The character offset at which this Node begins.
         */
        /**
         * The character offset at which this Node ends.
         */
        /**
         * The Token at which this Node begins.
         */
        /**
         * The Token at which this Node ends.
         */
        /**
         * The Source document the AST represents.
         */
        constructor(startToken, endToken, source) {
          this.start = startToken.start;
          this.end = endToken.end;
          this.startToken = startToken;
          this.endToken = endToken;
          this.source = source;
        }
        get [Symbol.toStringTag]() {
          return "Location";
        }
        toJSON() {
          return {
            start: this.start,
            end: this.end
          };
        }
      };
      exports2.Location = Location2;
      var Token2 = class {
        /**
         * The kind of Token.
         */
        /**
         * The character offset at which this Node begins.
         */
        /**
         * The character offset at which this Node ends.
         */
        /**
         * The 1-indexed line number on which this Token appears.
         */
        /**
         * The 1-indexed column number at which this Token begins.
         */
        /**
         * For non-punctuation tokens, represents the interpreted value of the token.
         *
         * Note: is undefined for punctuation tokens, but typed as string for
         * convenience in the parser.
         */
        /**
         * Tokens exist as nodes in a double-linked-list amongst all tokens
         * including ignored tokens. <SOF> is always the first node and <EOF>
         * the last.
         */
        constructor(kind, start, end, line, column, value) {
          this.kind = kind;
          this.start = start;
          this.end = end;
          this.line = line;
          this.column = column;
          this.value = value;
          this.prev = null;
          this.next = null;
        }
        get [Symbol.toStringTag]() {
          return "Token";
        }
        toJSON() {
          return {
            kind: this.kind,
            value: this.value,
            line: this.line,
            column: this.column
          };
        }
      };
      exports2.Token = Token2;
      var QueryDocumentKeys2 = {
        Name: [],
        Document: ["definitions"],
        OperationDefinition: [
          "name",
          "variableDefinitions",
          "directives",
          "selectionSet"
        ],
        VariableDefinition: ["variable", "type", "defaultValue", "directives"],
        Variable: ["name"],
        SelectionSet: ["selections"],
        Field: ["alias", "name", "arguments", "directives", "selectionSet"],
        Argument: ["name", "value"],
        FragmentSpread: ["name", "directives"],
        InlineFragment: ["typeCondition", "directives", "selectionSet"],
        FragmentDefinition: [
          "name",
          // Note: fragment variable definitions are deprecated and will removed in v17.0.0
          "variableDefinitions",
          "typeCondition",
          "directives",
          "selectionSet"
        ],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: ["values"],
        ObjectValue: ["fields"],
        ObjectField: ["name", "value"],
        Directive: ["name", "arguments"],
        NamedType: ["name"],
        ListType: ["type"],
        NonNullType: ["type"],
        SchemaDefinition: ["description", "directives", "operationTypes"],
        OperationTypeDefinition: ["type"],
        ScalarTypeDefinition: ["description", "name", "directives"],
        ObjectTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        FieldDefinition: ["description", "name", "arguments", "type", "directives"],
        InputValueDefinition: [
          "description",
          "name",
          "type",
          "defaultValue",
          "directives"
        ],
        InterfaceTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        UnionTypeDefinition: ["description", "name", "directives", "types"],
        EnumTypeDefinition: ["description", "name", "directives", "values"],
        EnumValueDefinition: ["description", "name", "directives"],
        InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
        DirectiveDefinition: ["description", "name", "arguments", "locations"],
        SchemaExtension: ["directives", "operationTypes"],
        ScalarTypeExtension: ["name", "directives"],
        ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
        InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
        UnionTypeExtension: ["name", "directives", "types"],
        EnumTypeExtension: ["name", "directives", "values"],
        InputObjectTypeExtension: ["name", "directives", "fields"]
      };
      exports2.QueryDocumentKeys = QueryDocumentKeys2;
      var kindValues2 = new Set(Object.keys(QueryDocumentKeys2));
      function isNode2(maybeNode) {
        const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
        return typeof maybeKind === "string" && kindValues2.has(maybeKind);
      }
      var OperationTypeNode2;
      exports2.OperationTypeNode = OperationTypeNode2;
      (function(OperationTypeNode3) {
        OperationTypeNode3["QUERY"] = "query";
        OperationTypeNode3["MUTATION"] = "mutation";
        OperationTypeNode3["SUBSCRIPTION"] = "subscription";
      })(OperationTypeNode2 || (exports2.OperationTypeNode = OperationTypeNode2 = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/kinds.js
  var require_kinds = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/kinds.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.Kind = void 0;
      var Kind2;
      exports2.Kind = Kind2;
      (function(Kind3) {
        Kind3["NAME"] = "Name";
        Kind3["DOCUMENT"] = "Document";
        Kind3["OPERATION_DEFINITION"] = "OperationDefinition";
        Kind3["VARIABLE_DEFINITION"] = "VariableDefinition";
        Kind3["SELECTION_SET"] = "SelectionSet";
        Kind3["FIELD"] = "Field";
        Kind3["ARGUMENT"] = "Argument";
        Kind3["FRAGMENT_SPREAD"] = "FragmentSpread";
        Kind3["INLINE_FRAGMENT"] = "InlineFragment";
        Kind3["FRAGMENT_DEFINITION"] = "FragmentDefinition";
        Kind3["VARIABLE"] = "Variable";
        Kind3["INT"] = "IntValue";
        Kind3["FLOAT"] = "FloatValue";
        Kind3["STRING"] = "StringValue";
        Kind3["BOOLEAN"] = "BooleanValue";
        Kind3["NULL"] = "NullValue";
        Kind3["ENUM"] = "EnumValue";
        Kind3["LIST"] = "ListValue";
        Kind3["OBJECT"] = "ObjectValue";
        Kind3["OBJECT_FIELD"] = "ObjectField";
        Kind3["DIRECTIVE"] = "Directive";
        Kind3["NAMED_TYPE"] = "NamedType";
        Kind3["LIST_TYPE"] = "ListType";
        Kind3["NON_NULL_TYPE"] = "NonNullType";
        Kind3["SCHEMA_DEFINITION"] = "SchemaDefinition";
        Kind3["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
        Kind3["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
        Kind3["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
        Kind3["FIELD_DEFINITION"] = "FieldDefinition";
        Kind3["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
        Kind3["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
        Kind3["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
        Kind3["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
        Kind3["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
        Kind3["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
        Kind3["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
        Kind3["SCHEMA_EXTENSION"] = "SchemaExtension";
        Kind3["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
        Kind3["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
        Kind3["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
        Kind3["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
        Kind3["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
        Kind3["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
      })(Kind2 || (exports2.Kind = Kind2 = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/visitor.js
  var require_visitor = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/visitor.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.BREAK = void 0;
      exports2.getEnterLeaveForKind = getEnterLeaveForKind2;
      exports2.getVisitFn = getVisitFn2;
      exports2.visit = visit2;
      exports2.visitInParallel = visitInParallel2;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _ast = require_ast2();
      var _kinds = require_kinds();
      var BREAK2 = Object.freeze({});
      exports2.BREAK = BREAK2;
      function visit2(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
        const enterLeaveMap = /* @__PURE__ */ new Map();
        for (const kind of Object.values(_kinds.Kind)) {
          enterLeaveMap.set(kind, getEnterLeaveForKind2(visitor, kind));
        }
        let stack = void 0;
        let inArray = Array.isArray(root);
        let keys = [root];
        let index = -1;
        let edits = [];
        let node = root;
        let key = void 0;
        let parent = void 0;
        const path = [];
        const ancestors = [];
        do {
          index++;
          const isLeaving = index === keys.length;
          const isEdited = isLeaving && edits.length !== 0;
          if (isLeaving) {
            key = ancestors.length === 0 ? void 0 : path[path.length - 1];
            node = parent;
            parent = ancestors.pop();
            if (isEdited) {
              if (inArray) {
                node = node.slice();
                let editOffset = 0;
                for (const [editKey, editValue] of edits) {
                  const arrayKey = editKey - editOffset;
                  if (editValue === null) {
                    node.splice(arrayKey, 1);
                    editOffset++;
                  } else {
                    node[arrayKey] = editValue;
                  }
                }
              } else {
                node = Object.defineProperties(
                  {},
                  Object.getOwnPropertyDescriptors(node)
                );
                for (const [editKey, editValue] of edits) {
                  node[editKey] = editValue;
                }
              }
            }
            index = stack.index;
            keys = stack.keys;
            edits = stack.edits;
            inArray = stack.inArray;
            stack = stack.prev;
          } else if (parent) {
            key = inArray ? index : keys[index];
            node = parent[key];
            if (node === null || node === void 0) {
              continue;
            }
            path.push(key);
          }
          let result;
          if (!Array.isArray(node)) {
            var _enterLeaveMap$get, _enterLeaveMap$get2;
            (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(
              false,
              `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`
            );
            const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
            result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
            if (result === BREAK2) {
              break;
            }
            if (result === false) {
              if (!isLeaving) {
                path.pop();
                continue;
              }
            } else if (result !== void 0) {
              edits.push([key, result]);
              if (!isLeaving) {
                if ((0, _ast.isNode)(result)) {
                  node = result;
                } else {
                  path.pop();
                  continue;
                }
              }
            }
          }
          if (result === void 0 && isEdited) {
            edits.push([key, node]);
          }
          if (isLeaving) {
            path.pop();
          } else {
            var _node$kind;
            stack = {
              inArray,
              index,
              keys,
              edits,
              prev: stack
            };
            inArray = Array.isArray(node);
            keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
            index = -1;
            edits = [];
            if (parent) {
              ancestors.push(parent);
            }
            parent = node;
          }
        } while (stack !== void 0);
        if (edits.length !== 0) {
          return edits[edits.length - 1][1];
        }
        return root;
      }
      function visitInParallel2(visitors) {
        const skipping = new Array(visitors.length).fill(null);
        const mergedVisitor = /* @__PURE__ */ Object.create(null);
        for (const kind of Object.values(_kinds.Kind)) {
          let hasVisitor = false;
          const enterList = new Array(visitors.length).fill(void 0);
          const leaveList = new Array(visitors.length).fill(void 0);
          for (let i2 = 0; i2 < visitors.length; ++i2) {
            const { enter, leave } = getEnterLeaveForKind2(visitors[i2], kind);
            hasVisitor || (hasVisitor = enter != null || leave != null);
            enterList[i2] = enter;
            leaveList[i2] = leave;
          }
          if (!hasVisitor) {
            continue;
          }
          const mergedEnterLeave = {
            enter(...args) {
              const node = args[0];
              for (let i2 = 0; i2 < visitors.length; i2++) {
                if (skipping[i2] === null) {
                  var _enterList$i;
                  const result = (_enterList$i = enterList[i2]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i2], args);
                  if (result === false) {
                    skipping[i2] = node;
                  } else if (result === BREAK2) {
                    skipping[i2] = BREAK2;
                  } else if (result !== void 0) {
                    return result;
                  }
                }
              }
            },
            leave(...args) {
              const node = args[0];
              for (let i2 = 0; i2 < visitors.length; i2++) {
                if (skipping[i2] === null) {
                  var _leaveList$i;
                  const result = (_leaveList$i = leaveList[i2]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i2], args);
                  if (result === BREAK2) {
                    skipping[i2] = BREAK2;
                  } else if (result !== void 0 && result !== false) {
                    return result;
                  }
                } else if (skipping[i2] === node) {
                  skipping[i2] = null;
                }
              }
            }
          };
          mergedVisitor[kind] = mergedEnterLeave;
        }
        return mergedVisitor;
      }
      function getEnterLeaveForKind2(visitor, kind) {
        const kindVisitor = visitor[kind];
        if (typeof kindVisitor === "object") {
          return kindVisitor;
        } else if (typeof kindVisitor === "function") {
          return {
            enter: kindVisitor,
            leave: void 0
          };
        }
        return {
          enter: visitor.enter,
          leave: visitor.leave
        };
      }
      function getVisitFn2(visitor, kind, isLeaving) {
        const { enter, leave } = getEnterLeaveForKind2(visitor, kind);
        return isLeaving ? leave : enter;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/didYouMean.js
  var require_didYouMean = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/didYouMean.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.didYouMean = didYouMean2;
      var MAX_SUGGESTIONS2 = 5;
      function didYouMean2(firstArg, secondArg) {
        const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
        let message = " Did you mean ";
        if (subMessage) {
          message += subMessage + " ";
        }
        const suggestions = suggestionsArg.map((x) => `"${x}"`);
        switch (suggestions.length) {
          case 0:
            return "";
          case 1:
            return message + suggestions[0] + "?";
          case 2:
            return message + suggestions[0] + " or " + suggestions[1] + "?";
        }
        const selected = suggestions.slice(0, MAX_SUGGESTIONS2);
        const lastItem = selected.pop();
        return message + selected.join(", ") + ", or " + lastItem + "?";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/identityFunc.js
  var require_identityFunc = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/identityFunc.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.identityFunc = identityFunc2;
      function identityFunc2(x) {
        return x;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/instanceOf.js
  var require_instanceOf = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/instanceOf.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.instanceOf = void 0;
      var _inspect = require_inspect();
      var instanceOf4 = (
        /* c8 ignore next 6 */
        // FIXME: https://github.com/graphql/graphql-js/issues/2317
        globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf5(value, constructor) {
          return value instanceof constructor;
        } : function instanceOf5(value, constructor) {
          if (value instanceof constructor) {
            return true;
          }
          if (typeof value === "object" && value !== null) {
            var _value$constructor;
            const className = constructor.prototype[Symbol.toStringTag];
            const valueClassName = (
              // We still need to support constructor's name to detect conflicts with older versions of this library.
              Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
            );
            if (className === valueClassName) {
              const stringifiedValue = (0, _inspect.inspect)(value);
              throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
            }
          }
          return false;
        }
      );
      exports2.instanceOf = instanceOf4;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/keyMap.js
  var require_keyMap = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/keyMap.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.keyMap = keyMap2;
      function keyMap2(list, keyFn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const item of list) {
          result[keyFn(item)] = item;
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/keyValMap.js
  var require_keyValMap = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/keyValMap.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.keyValMap = keyValMap2;
      function keyValMap2(list, keyFn, valFn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const item of list) {
          result[keyFn(item)] = valFn(item);
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/mapValue.js
  var require_mapValue = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/mapValue.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.mapValue = mapValue2;
      function mapValue2(map, fn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(map)) {
          result[key] = fn(map[key], key);
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/naturalCompare.js
  var require_naturalCompare = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/naturalCompare.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.naturalCompare = naturalCompare2;
      function naturalCompare2(aStr, bStr) {
        let aIndex = 0;
        let bIndex = 0;
        while (aIndex < aStr.length && bIndex < bStr.length) {
          let aChar = aStr.charCodeAt(aIndex);
          let bChar = bStr.charCodeAt(bIndex);
          if (isDigit3(aChar) && isDigit3(bChar)) {
            let aNum = 0;
            do {
              ++aIndex;
              aNum = aNum * 10 + aChar - DIGIT_02;
              aChar = aStr.charCodeAt(aIndex);
            } while (isDigit3(aChar) && aNum > 0);
            let bNum = 0;
            do {
              ++bIndex;
              bNum = bNum * 10 + bChar - DIGIT_02;
              bChar = bStr.charCodeAt(bIndex);
            } while (isDigit3(bChar) && bNum > 0);
            if (aNum < bNum) {
              return -1;
            }
            if (aNum > bNum) {
              return 1;
            }
          } else {
            if (aChar < bChar) {
              return -1;
            }
            if (aChar > bChar) {
              return 1;
            }
            ++aIndex;
            ++bIndex;
          }
        }
        return aStr.length - bStr.length;
      }
      var DIGIT_02 = 48;
      var DIGIT_92 = 57;
      function isDigit3(code) {
        return !isNaN(code) && DIGIT_02 <= code && code <= DIGIT_92;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/suggestionList.js
  var require_suggestionList = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/suggestionList.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.suggestionList = suggestionList2;
      var _naturalCompare = require_naturalCompare();
      function suggestionList2(input, options) {
        const optionsByDistance = /* @__PURE__ */ Object.create(null);
        const lexicalDistance = new LexicalDistance2(input);
        const threshold = Math.floor(input.length * 0.4) + 1;
        for (const option of options) {
          const distance = lexicalDistance.measure(option, threshold);
          if (distance !== void 0) {
            optionsByDistance[option] = distance;
          }
        }
        return Object.keys(optionsByDistance).sort((a2, b) => {
          const distanceDiff = optionsByDistance[a2] - optionsByDistance[b];
          return distanceDiff !== 0 ? distanceDiff : (0, _naturalCompare.naturalCompare)(a2, b);
        });
      }
      var LexicalDistance2 = class {
        constructor(input) {
          this._input = input;
          this._inputLowerCase = input.toLowerCase();
          this._inputArray = stringToArray2(this._inputLowerCase);
          this._rows = [
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0),
            new Array(input.length + 1).fill(0)
          ];
        }
        measure(option, threshold) {
          if (this._input === option) {
            return 0;
          }
          const optionLowerCase = option.toLowerCase();
          if (this._inputLowerCase === optionLowerCase) {
            return 1;
          }
          let a2 = stringToArray2(optionLowerCase);
          let b = this._inputArray;
          if (a2.length < b.length) {
            const tmp = a2;
            a2 = b;
            b = tmp;
          }
          const aLength = a2.length;
          const bLength = b.length;
          if (aLength - bLength > threshold) {
            return void 0;
          }
          const rows = this._rows;
          for (let j = 0; j <= bLength; j++) {
            rows[0][j] = j;
          }
          for (let i2 = 1; i2 <= aLength; i2++) {
            const upRow = rows[(i2 - 1) % 3];
            const currentRow = rows[i2 % 3];
            let smallestCell = currentRow[0] = i2;
            for (let j = 1; j <= bLength; j++) {
              const cost = a2[i2 - 1] === b[j - 1] ? 0 : 1;
              let currentCell = Math.min(
                upRow[j] + 1,
                // delete
                currentRow[j - 1] + 1,
                // insert
                upRow[j - 1] + cost
                // substitute
              );
              if (i2 > 1 && j > 1 && a2[i2 - 1] === b[j - 2] && a2[i2 - 2] === b[j - 1]) {
                const doubleDiagonalCell = rows[(i2 - 2) % 3][j - 2];
                currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
              }
              if (currentCell < smallestCell) {
                smallestCell = currentCell;
              }
              currentRow[j] = currentCell;
            }
            if (smallestCell > threshold) {
              return void 0;
            }
          }
          const distance = rows[aLength % 3][bLength];
          return distance <= threshold ? distance : void 0;
        }
      };
      function stringToArray2(str) {
        const strLength = str.length;
        const array = new Array(strLength);
        for (let i2 = 0; i2 < strLength; ++i2) {
          array[i2] = str.charCodeAt(i2);
        }
        return array;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/toObjMap.js
  var require_toObjMap = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/toObjMap.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.toObjMap = toObjMap2;
      function toObjMap2(obj) {
        if (obj == null) {
          return /* @__PURE__ */ Object.create(null);
        }
        if (Object.getPrototypeOf(obj) === null) {
          return obj;
        }
        const map = /* @__PURE__ */ Object.create(null);
        for (const [key, value] of Object.entries(obj)) {
          map[key] = value;
        }
        return map;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/characterClasses.js
  var require_characterClasses = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/characterClasses.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.isDigit = isDigit3;
      exports2.isLetter = isLetter2;
      exports2.isNameContinue = isNameContinue2;
      exports2.isNameStart = isNameStart2;
      exports2.isWhiteSpace = isWhiteSpace2;
      function isWhiteSpace2(code) {
        return code === 9 || code === 32;
      }
      function isDigit3(code) {
        return code >= 48 && code <= 57;
      }
      function isLetter2(code) {
        return code >= 97 && code <= 122 || // A-Z
        code >= 65 && code <= 90;
      }
      function isNameStart2(code) {
        return isLetter2(code) || code === 95;
      }
      function isNameContinue2(code) {
        return isLetter2(code) || isDigit3(code) || code === 95;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/blockString.js
  var require_blockString = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/blockString.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.dedentBlockStringLines = dedentBlockStringLines2;
      exports2.isPrintableAsBlockString = isPrintableAsBlockString2;
      exports2.printBlockString = printBlockString2;
      var _characterClasses = require_characterClasses();
      function dedentBlockStringLines2(lines) {
        var _firstNonEmptyLine2;
        let commonIndent = Number.MAX_SAFE_INTEGER;
        let firstNonEmptyLine = null;
        let lastNonEmptyLine = -1;
        for (let i2 = 0; i2 < lines.length; ++i2) {
          var _firstNonEmptyLine;
          const line = lines[i2];
          const indent2 = leadingWhitespace2(line);
          if (indent2 === line.length) {
            continue;
          }
          firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i2;
          lastNonEmptyLine = i2;
          if (i2 !== 0 && indent2 < commonIndent) {
            commonIndent = indent2;
          }
        }
        return lines.map((line, i2) => i2 === 0 ? line : line.slice(commonIndent)).slice(
          (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
          lastNonEmptyLine + 1
        );
      }
      function leadingWhitespace2(str) {
        let i2 = 0;
        while (i2 < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i2))) {
          ++i2;
        }
        return i2;
      }
      function isPrintableAsBlockString2(value) {
        if (value === "") {
          return true;
        }
        let isEmptyLine = true;
        let hasIndent = false;
        let hasCommonIndent = true;
        let seenNonEmptyLine = false;
        for (let i2 = 0; i2 < value.length; ++i2) {
          switch (value.codePointAt(i2)) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 11:
            case 12:
            case 14:
            case 15:
              return false;
            case 13:
              return false;
            case 10:
              if (isEmptyLine && !seenNonEmptyLine) {
                return false;
              }
              seenNonEmptyLine = true;
              isEmptyLine = true;
              hasIndent = false;
              break;
            case 9:
            case 32:
              hasIndent || (hasIndent = isEmptyLine);
              break;
            default:
              hasCommonIndent && (hasCommonIndent = hasIndent);
              isEmptyLine = false;
          }
        }
        if (isEmptyLine) {
          return false;
        }
        if (hasCommonIndent && seenNonEmptyLine) {
          return false;
        }
        return true;
      }
      function printBlockString2(value, options) {
        const escapedValue = value.replace(/"""/g, '\\"""');
        const lines = escapedValue.split(/\r\n|[\n\r]/g);
        const isSingleLine = lines.length === 1;
        const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(
          (line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))
        );
        const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
        const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
        const hasTrailingSlash = value.endsWith("\\");
        const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
        const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
        (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
        let result = "";
        const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
        if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
          result += "\n";
        }
        result += escapedValue;
        if (printAsMultipleLines || forceTrailingNewline) {
          result += "\n";
        }
        return '"""' + result + '"""';
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printString.js
  var require_printString = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printString.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.printString = printString2;
      function printString2(str) {
        return `"${str.replace(escapedRegExp2, escapedReplacer2)}"`;
      }
      var escapedRegExp2 = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
      function escapedReplacer2(str) {
        return escapeSequences2[str.charCodeAt(0)];
      }
      var escapeSequences2 = [
        "\\u0000",
        "\\u0001",
        "\\u0002",
        "\\u0003",
        "\\u0004",
        "\\u0005",
        "\\u0006",
        "\\u0007",
        "\\b",
        "\\t",
        "\\n",
        "\\u000B",
        "\\f",
        "\\r",
        "\\u000E",
        "\\u000F",
        "\\u0010",
        "\\u0011",
        "\\u0012",
        "\\u0013",
        "\\u0014",
        "\\u0015",
        "\\u0016",
        "\\u0017",
        "\\u0018",
        "\\u0019",
        "\\u001A",
        "\\u001B",
        "\\u001C",
        "\\u001D",
        "\\u001E",
        "\\u001F",
        "",
        "",
        '\\"',
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 2F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 3F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 4F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\\\",
        "",
        "",
        "",
        // 5F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 6F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\u007F",
        "\\u0080",
        "\\u0081",
        "\\u0082",
        "\\u0083",
        "\\u0084",
        "\\u0085",
        "\\u0086",
        "\\u0087",
        "\\u0088",
        "\\u0089",
        "\\u008A",
        "\\u008B",
        "\\u008C",
        "\\u008D",
        "\\u008E",
        "\\u008F",
        "\\u0090",
        "\\u0091",
        "\\u0092",
        "\\u0093",
        "\\u0094",
        "\\u0095",
        "\\u0096",
        "\\u0097",
        "\\u0098",
        "\\u0099",
        "\\u009A",
        "\\u009B",
        "\\u009C",
        "\\u009D",
        "\\u009E",
        "\\u009F"
      ];
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printer.js
  var require_printer = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/printer.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.print = print2;
      var _blockString = require_blockString();
      var _printString = require_printString();
      var _visitor = require_visitor();
      function print2(ast) {
        return (0, _visitor.visit)(ast, printDocASTReducer2);
      }
      var MAX_LINE_LENGTH2 = 80;
      var printDocASTReducer2 = {
        Name: {
          leave: (node) => node.value
        },
        Variable: {
          leave: (node) => "$" + node.name
        },
        // Document
        Document: {
          leave: (node) => join2(node.definitions, "\n\n")
        },
        OperationDefinition: {
          leave(node) {
            const varDefs = wrap2("(", join2(node.variableDefinitions, ", "), ")");
            const prefix = join2(
              [
                node.operation,
                join2([node.name, varDefs]),
                join2(node.directives, " ")
              ],
              " "
            );
            return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
          }
        },
        VariableDefinition: {
          leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join2(directives, " "))
        },
        SelectionSet: {
          leave: ({ selections }) => block2(selections)
        },
        Field: {
          leave({ alias, name: name2, arguments: args, directives, selectionSet }) {
            const prefix = wrap2("", alias, ": ") + name2;
            let argsLine = prefix + wrap2("(", join2(args, ", "), ")");
            if (argsLine.length > MAX_LINE_LENGTH2) {
              argsLine = prefix + wrap2("(\n", indent2(join2(args, "\n")), "\n)");
            }
            return join2([argsLine, join2(directives, " "), selectionSet], " ");
          }
        },
        Argument: {
          leave: ({ name: name2, value }) => name2 + ": " + value
        },
        // Fragments
        FragmentSpread: {
          leave: ({ name: name2, directives }) => "..." + name2 + wrap2(" ", join2(directives, " "))
        },
        InlineFragment: {
          leave: ({ typeCondition, directives, selectionSet }) => join2(
            [
              "...",
              wrap2("on ", typeCondition),
              join2(directives, " "),
              selectionSet
            ],
            " "
          )
        },
        FragmentDefinition: {
          leave: ({ name: name2, typeCondition, variableDefinitions, directives, selectionSet }) => (
            // or removed in the future.
            `fragment ${name2}${wrap2("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join2(directives, " "), " ")}` + selectionSet
          )
        },
        // Value
        IntValue: {
          leave: ({ value }) => value
        },
        FloatValue: {
          leave: ({ value }) => value
        },
        StringValue: {
          leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
        },
        BooleanValue: {
          leave: ({ value }) => value ? "true" : "false"
        },
        NullValue: {
          leave: () => "null"
        },
        EnumValue: {
          leave: ({ value }) => value
        },
        ListValue: {
          leave: ({ values }) => "[" + join2(values, ", ") + "]"
        },
        ObjectValue: {
          leave: ({ fields }) => "{" + join2(fields, ", ") + "}"
        },
        ObjectField: {
          leave: ({ name: name2, value }) => name2 + ": " + value
        },
        // Directive
        Directive: {
          leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap2("(", join2(args, ", "), ")")
        },
        // Type
        NamedType: {
          leave: ({ name: name2 }) => name2
        },
        ListType: {
          leave: ({ type }) => "[" + type + "]"
        },
        NonNullType: {
          leave: ({ type }) => type + "!"
        },
        // Type System Definitions
        SchemaDefinition: {
          leave: ({ description, directives, operationTypes }) => wrap2("", description, "\n") + join2(["schema", join2(directives, " "), block2(operationTypes)], " ")
        },
        OperationTypeDefinition: {
          leave: ({ operation, type }) => operation + ": " + type
        },
        ScalarTypeDefinition: {
          leave: ({ description, name: name2, directives }) => wrap2("", description, "\n") + join2(["scalar", name2, join2(directives, " ")], " ")
        },
        ObjectTypeDefinition: {
          leave: ({ description, name: name2, interfaces, directives, fields }) => wrap2("", description, "\n") + join2(
            [
              "type",
              name2,
              wrap2("implements ", join2(interfaces, " & ")),
              join2(directives, " "),
              block2(fields)
            ],
            " "
          )
        },
        FieldDefinition: {
          leave: ({ description, name: name2, arguments: args, type, directives }) => wrap2("", description, "\n") + name2 + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + ": " + type + wrap2(" ", join2(directives, " "))
        },
        InputValueDefinition: {
          leave: ({ description, name: name2, type, defaultValue, directives }) => wrap2("", description, "\n") + join2(
            [name2 + ": " + type, wrap2("= ", defaultValue), join2(directives, " ")],
            " "
          )
        },
        InterfaceTypeDefinition: {
          leave: ({ description, name: name2, interfaces, directives, fields }) => wrap2("", description, "\n") + join2(
            [
              "interface",
              name2,
              wrap2("implements ", join2(interfaces, " & ")),
              join2(directives, " "),
              block2(fields)
            ],
            " "
          )
        },
        UnionTypeDefinition: {
          leave: ({ description, name: name2, directives, types }) => wrap2("", description, "\n") + join2(
            ["union", name2, join2(directives, " "), wrap2("= ", join2(types, " | "))],
            " "
          )
        },
        EnumTypeDefinition: {
          leave: ({ description, name: name2, directives, values }) => wrap2("", description, "\n") + join2(["enum", name2, join2(directives, " "), block2(values)], " ")
        },
        EnumValueDefinition: {
          leave: ({ description, name: name2, directives }) => wrap2("", description, "\n") + join2([name2, join2(directives, " ")], " ")
        },
        InputObjectTypeDefinition: {
          leave: ({ description, name: name2, directives, fields }) => wrap2("", description, "\n") + join2(["input", name2, join2(directives, " "), block2(fields)], " ")
        },
        DirectiveDefinition: {
          leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap2("", description, "\n") + "directive @" + name2 + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
        },
        SchemaExtension: {
          leave: ({ directives, operationTypes }) => join2(
            ["extend schema", join2(directives, " "), block2(operationTypes)],
            " "
          )
        },
        ScalarTypeExtension: {
          leave: ({ name: name2, directives }) => join2(["extend scalar", name2, join2(directives, " ")], " ")
        },
        ObjectTypeExtension: {
          leave: ({ name: name2, interfaces, directives, fields }) => join2(
            [
              "extend type",
              name2,
              wrap2("implements ", join2(interfaces, " & ")),
              join2(directives, " "),
              block2(fields)
            ],
            " "
          )
        },
        InterfaceTypeExtension: {
          leave: ({ name: name2, interfaces, directives, fields }) => join2(
            [
              "extend interface",
              name2,
              wrap2("implements ", join2(interfaces, " & ")),
              join2(directives, " "),
              block2(fields)
            ],
            " "
          )
        },
        UnionTypeExtension: {
          leave: ({ name: name2, directives, types }) => join2(
            [
              "extend union",
              name2,
              join2(directives, " "),
              wrap2("= ", join2(types, " | "))
            ],
            " "
          )
        },
        EnumTypeExtension: {
          leave: ({ name: name2, directives, values }) => join2(["extend enum", name2, join2(directives, " "), block2(values)], " ")
        },
        InputObjectTypeExtension: {
          leave: ({ name: name2, directives, fields }) => join2(["extend input", name2, join2(directives, " "), block2(fields)], " ")
        }
      };
      function join2(maybeArray, separator = "") {
        var _maybeArray$filter$jo;
        return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
      }
      function block2(array) {
        return wrap2("{\n", indent2(join2(array, "\n")), "\n}");
      }
      function wrap2(start, maybeString, end = "") {
        return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
      }
      function indent2(str) {
        return wrap2("  ", str.replace(/\n/g, "\n  "));
      }
      function hasMultilineItems2(maybeArray) {
        var _maybeArray$some;
        return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/valueFromASTUntyped.js
  var require_valueFromASTUntyped = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/valueFromASTUntyped.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.valueFromASTUntyped = valueFromASTUntyped2;
      var _keyValMap = require_keyValMap();
      var _kinds = require_kinds();
      function valueFromASTUntyped2(valueNode, variables) {
        switch (valueNode.kind) {
          case _kinds.Kind.NULL:
            return null;
          case _kinds.Kind.INT:
            return parseInt(valueNode.value, 10);
          case _kinds.Kind.FLOAT:
            return parseFloat(valueNode.value);
          case _kinds.Kind.STRING:
          case _kinds.Kind.ENUM:
          case _kinds.Kind.BOOLEAN:
            return valueNode.value;
          case _kinds.Kind.LIST:
            return valueNode.values.map(
              (node) => valueFromASTUntyped2(node, variables)
            );
          case _kinds.Kind.OBJECT:
            return (0, _keyValMap.keyValMap)(
              valueNode.fields,
              (field) => field.name.value,
              (field) => valueFromASTUntyped2(field.value, variables)
            );
          case _kinds.Kind.VARIABLE:
            return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/assertName.js
  var require_assertName = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/assertName.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.assertEnumValueName = assertEnumValueName2;
      exports2.assertName = assertName2;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _characterClasses = require_characterClasses();
      function assertName2(name2) {
        name2 != null || (0, _devAssert.devAssert)(false, "Must provide name.");
        typeof name2 === "string" || (0, _devAssert.devAssert)(false, "Expected name to be a string.");
        if (name2.length === 0) {
          throw new _GraphQLError.GraphQLError(
            "Expected name to be a non-empty string."
          );
        }
        for (let i2 = 1; i2 < name2.length; ++i2) {
          if (!(0, _characterClasses.isNameContinue)(name2.charCodeAt(i2))) {
            throw new _GraphQLError.GraphQLError(
              `Names must only contain [_a-zA-Z0-9] but "${name2}" does not.`
            );
          }
        }
        if (!(0, _characterClasses.isNameStart)(name2.charCodeAt(0))) {
          throw new _GraphQLError.GraphQLError(
            `Names must start with [_a-zA-Z] but "${name2}" does not.`
          );
        }
        return name2;
      }
      function assertEnumValueName2(name2) {
        if (name2 === "true" || name2 === "false" || name2 === "null") {
          throw new _GraphQLError.GraphQLError(
            `Enum values cannot be named: ${name2}`
          );
        }
        return assertName2(name2);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/definition.js
  var require_definition = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/definition.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.GraphQLUnionType = exports2.GraphQLScalarType = exports2.GraphQLObjectType = exports2.GraphQLNonNull = exports2.GraphQLList = exports2.GraphQLInterfaceType = exports2.GraphQLInputObjectType = exports2.GraphQLEnumType = void 0;
      exports2.argsToArgsConfig = argsToArgsConfig2;
      exports2.assertAbstractType = assertAbstractType2;
      exports2.assertCompositeType = assertCompositeType2;
      exports2.assertEnumType = assertEnumType2;
      exports2.assertInputObjectType = assertInputObjectType2;
      exports2.assertInputType = assertInputType2;
      exports2.assertInterfaceType = assertInterfaceType2;
      exports2.assertLeafType = assertLeafType2;
      exports2.assertListType = assertListType2;
      exports2.assertNamedType = assertNamedType2;
      exports2.assertNonNullType = assertNonNullType2;
      exports2.assertNullableType = assertNullableType2;
      exports2.assertObjectType = assertObjectType2;
      exports2.assertOutputType = assertOutputType2;
      exports2.assertScalarType = assertScalarType2;
      exports2.assertType = assertType2;
      exports2.assertUnionType = assertUnionType2;
      exports2.assertWrappingType = assertWrappingType2;
      exports2.defineArguments = defineArguments2;
      exports2.getNamedType = getNamedType2;
      exports2.getNullableType = getNullableType2;
      exports2.isAbstractType = isAbstractType2;
      exports2.isCompositeType = isCompositeType2;
      exports2.isEnumType = isEnumType2;
      exports2.isInputObjectType = isInputObjectType2;
      exports2.isInputType = isInputType2;
      exports2.isInterfaceType = isInterfaceType2;
      exports2.isLeafType = isLeafType2;
      exports2.isListType = isListType2;
      exports2.isNamedType = isNamedType2;
      exports2.isNonNullType = isNonNullType2;
      exports2.isNullableType = isNullableType2;
      exports2.isObjectType = isObjectType2;
      exports2.isOutputType = isOutputType2;
      exports2.isRequiredArgument = isRequiredArgument2;
      exports2.isRequiredInputField = isRequiredInputField2;
      exports2.isScalarType = isScalarType2;
      exports2.isType = isType2;
      exports2.isUnionType = isUnionType2;
      exports2.isWrappingType = isWrappingType2;
      exports2.resolveObjMapThunk = resolveObjMapThunk2;
      exports2.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk2;
      var _devAssert = require_devAssert();
      var _didYouMean = require_didYouMean();
      var _identityFunc = require_identityFunc();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _keyMap = require_keyMap();
      var _keyValMap = require_keyValMap();
      var _mapValue = require_mapValue();
      var _suggestionList = require_suggestionList();
      var _toObjMap = require_toObjMap();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _valueFromASTUntyped = require_valueFromASTUntyped();
      var _assertName = require_assertName();
      function isType2(type) {
        return isScalarType2(type) || isObjectType2(type) || isInterfaceType2(type) || isUnionType2(type) || isEnumType2(type) || isInputObjectType2(type) || isListType2(type) || isNonNullType2(type);
      }
      function assertType2(type) {
        if (!isType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL type.`
          );
        }
        return type;
      }
      function isScalarType2(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLScalarType2);
      }
      function assertScalarType2(type) {
        if (!isScalarType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Scalar type.`
          );
        }
        return type;
      }
      function isObjectType2(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLObjectType2);
      }
      function assertObjectType2(type) {
        if (!isObjectType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Object type.`
          );
        }
        return type;
      }
      function isInterfaceType2(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLInterfaceType2);
      }
      function assertInterfaceType2(type) {
        if (!isInterfaceType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Interface type.`
          );
        }
        return type;
      }
      function isUnionType2(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLUnionType2);
      }
      function assertUnionType2(type) {
        if (!isUnionType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Union type.`
          );
        }
        return type;
      }
      function isEnumType2(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLEnumType2);
      }
      function assertEnumType2(type) {
        if (!isEnumType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Enum type.`
          );
        }
        return type;
      }
      function isInputObjectType2(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLInputObjectType2);
      }
      function assertInputObjectType2(type) {
        if (!isInputObjectType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(
              type
            )} to be a GraphQL Input Object type.`
          );
        }
        return type;
      }
      function isListType2(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLList2);
      }
      function assertListType2(type) {
        if (!isListType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL List type.`
          );
        }
        return type;
      }
      function isNonNullType2(type) {
        return (0, _instanceOf.instanceOf)(type, GraphQLNonNull2);
      }
      function assertNonNullType2(type) {
        if (!isNonNullType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL Non-Null type.`
          );
        }
        return type;
      }
      function isInputType2(type) {
        return isScalarType2(type) || isEnumType2(type) || isInputObjectType2(type) || isWrappingType2(type) && isInputType2(type.ofType);
      }
      function assertInputType2(type) {
        if (!isInputType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL input type.`
          );
        }
        return type;
      }
      function isOutputType2(type) {
        return isScalarType2(type) || isObjectType2(type) || isInterfaceType2(type) || isUnionType2(type) || isEnumType2(type) || isWrappingType2(type) && isOutputType2(type.ofType);
      }
      function assertOutputType2(type) {
        if (!isOutputType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL output type.`
          );
        }
        return type;
      }
      function isLeafType2(type) {
        return isScalarType2(type) || isEnumType2(type);
      }
      function assertLeafType2(type) {
        if (!isLeafType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL leaf type.`
          );
        }
        return type;
      }
      function isCompositeType2(type) {
        return isObjectType2(type) || isInterfaceType2(type) || isUnionType2(type);
      }
      function assertCompositeType2(type) {
        if (!isCompositeType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL composite type.`
          );
        }
        return type;
      }
      function isAbstractType2(type) {
        return isInterfaceType2(type) || isUnionType2(type);
      }
      function assertAbstractType2(type) {
        if (!isAbstractType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL abstract type.`
          );
        }
        return type;
      }
      var GraphQLList2 = class {
        constructor(ofType) {
          isType2(ofType) || (0, _devAssert.devAssert)(
            false,
            `Expected ${(0, _inspect.inspect)(ofType)} to be a GraphQL type.`
          );
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLList";
        }
        toString() {
          return "[" + String(this.ofType) + "]";
        }
        toJSON() {
          return this.toString();
        }
      };
      exports2.GraphQLList = GraphQLList2;
      var GraphQLNonNull2 = class {
        constructor(ofType) {
          isNullableType2(ofType) || (0, _devAssert.devAssert)(
            false,
            `Expected ${(0, _inspect.inspect)(
              ofType
            )} to be a GraphQL nullable type.`
          );
          this.ofType = ofType;
        }
        get [Symbol.toStringTag]() {
          return "GraphQLNonNull";
        }
        toString() {
          return String(this.ofType) + "!";
        }
        toJSON() {
          return this.toString();
        }
      };
      exports2.GraphQLNonNull = GraphQLNonNull2;
      function isWrappingType2(type) {
        return isListType2(type) || isNonNullType2(type);
      }
      function assertWrappingType2(type) {
        if (!isWrappingType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL wrapping type.`
          );
        }
        return type;
      }
      function isNullableType2(type) {
        return isType2(type) && !isNonNullType2(type);
      }
      function assertNullableType2(type) {
        if (!isNullableType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL nullable type.`
          );
        }
        return type;
      }
      function getNullableType2(type) {
        if (type) {
          return isNonNullType2(type) ? type.ofType : type;
        }
      }
      function isNamedType2(type) {
        return isScalarType2(type) || isObjectType2(type) || isInterfaceType2(type) || isUnionType2(type) || isEnumType2(type) || isInputObjectType2(type);
      }
      function assertNamedType2(type) {
        if (!isNamedType2(type)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(type)} to be a GraphQL named type.`
          );
        }
        return type;
      }
      function getNamedType2(type) {
        if (type) {
          let unwrappedType = type;
          while (isWrappingType2(unwrappedType)) {
            unwrappedType = unwrappedType.ofType;
          }
          return unwrappedType;
        }
      }
      function resolveReadonlyArrayThunk2(thunk) {
        return typeof thunk === "function" ? thunk() : thunk;
      }
      function resolveObjMapThunk2(thunk) {
        return typeof thunk === "function" ? thunk() : thunk;
      }
      var GraphQLScalarType2 = class {
        constructor(config2) {
          var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
          const parseValue2 = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : _identityFunc.identityFunc;
          this.name = (0, _assertName.assertName)(config2.name);
          this.description = config2.description;
          this.specifiedByURL = config2.specifiedByURL;
          this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : _identityFunc.identityFunc;
          this.parseValue = parseValue2;
          this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(
            (0, _valueFromASTUntyped.valueFromASTUntyped)(node, variables)
          );
          this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          config2.specifiedByURL == null || typeof config2.specifiedByURL === "string" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, _inspect.inspect)(config2.specifiedByURL)}.`
          );
          config2.serialize == null || typeof config2.serialize === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
          );
          if (config2.parseLiteral) {
            typeof config2.parseValue === "function" && typeof config2.parseLiteral === "function" || (0, _devAssert.devAssert)(
              false,
              `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
            );
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLScalarType";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            specifiedByURL: this.specifiedByURL,
            serialize: this.serialize,
            parseValue: this.parseValue,
            parseLiteral: this.parseLiteral,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports2.GraphQLScalarType = GraphQLScalarType2;
      var GraphQLObjectType2 = class {
        constructor(config2) {
          var _config$extensionASTN2;
          this.name = (0, _assertName.assertName)(config2.name);
          this.description = config2.description;
          this.isTypeOf = config2.isTypeOf;
          this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN2 = config2.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
          this._fields = () => defineFieldMap2(config2);
          this._interfaces = () => defineInterfaces2(config2);
          config2.isTypeOf == null || typeof config2.isTypeOf === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "isTypeOf" as a function, but got: ${(0, _inspect.inspect)(config2.isTypeOf)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig2(this.getFields()),
            isTypeOf: this.isTypeOf,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports2.GraphQLObjectType = GraphQLObjectType2;
      function defineInterfaces2(config2) {
        var _config$interfaces;
        const interfaces = resolveReadonlyArrayThunk2(
          (_config$interfaces = config2.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
        );
        Array.isArray(interfaces) || (0, _devAssert.devAssert)(
          false,
          `${config2.name} interfaces must be an Array or a function which returns an Array.`
        );
        return interfaces;
      }
      function defineFieldMap2(config2) {
        const fieldMap = resolveObjMapThunk2(config2.fields);
        isPlainObj2(fieldMap) || (0, _devAssert.devAssert)(
          false,
          `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
        );
        return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
          var _fieldConfig$args;
          isPlainObj2(fieldConfig) || (0, _devAssert.devAssert)(
            false,
            `${config2.name}.${fieldName} field config must be an object.`
          );
          fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || (0, _devAssert.devAssert)(
            false,
            `${config2.name}.${fieldName} field resolver must be a function if provided, but got: ${(0, _inspect.inspect)(fieldConfig.resolve)}.`
          );
          const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
          isPlainObj2(argsConfig) || (0, _devAssert.devAssert)(
            false,
            `${config2.name}.${fieldName} args must be an object with argument names as keys.`
          );
          return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            args: defineArguments2(argsConfig),
            resolve: fieldConfig.resolve,
            subscribe: fieldConfig.subscribe,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
          };
        });
      }
      function defineArguments2(config2) {
        return Object.entries(config2).map(([argName, argConfig]) => ({
          name: (0, _assertName.assertName)(argName),
          description: argConfig.description,
          type: argConfig.type,
          defaultValue: argConfig.defaultValue,
          deprecationReason: argConfig.deprecationReason,
          extensions: (0, _toObjMap.toObjMap)(argConfig.extensions),
          astNode: argConfig.astNode
        }));
      }
      function isPlainObj2(obj) {
        return (0, _isObjectLike.isObjectLike)(obj) && !Array.isArray(obj);
      }
      function fieldsToFieldsConfig2(fields) {
        return (0, _mapValue.mapValue)(fields, (field) => ({
          description: field.description,
          type: field.type,
          args: argsToArgsConfig2(field.args),
          resolve: field.resolve,
          subscribe: field.subscribe,
          deprecationReason: field.deprecationReason,
          extensions: field.extensions,
          astNode: field.astNode
        }));
      }
      function argsToArgsConfig2(args) {
        return (0, _keyValMap.keyValMap)(
          args,
          (arg) => arg.name,
          (arg) => ({
            description: arg.description,
            type: arg.type,
            defaultValue: arg.defaultValue,
            deprecationReason: arg.deprecationReason,
            extensions: arg.extensions,
            astNode: arg.astNode
          })
        );
      }
      function isRequiredArgument2(arg) {
        return isNonNullType2(arg.type) && arg.defaultValue === void 0;
      }
      var GraphQLInterfaceType2 = class {
        constructor(config2) {
          var _config$extensionASTN3;
          this.name = (0, _assertName.assertName)(config2.name);
          this.description = config2.description;
          this.resolveType = config2.resolveType;
          this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN3 = config2.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
          this._fields = defineFieldMap2.bind(void 0, config2);
          this._interfaces = defineInterfaces2.bind(void 0, config2);
          config2.resolveType == null || typeof config2.resolveType === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config2.resolveType)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInterfaceType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        getInterfaces() {
          if (typeof this._interfaces === "function") {
            this._interfaces = this._interfaces();
          }
          return this._interfaces;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            interfaces: this.getInterfaces(),
            fields: fieldsToFieldsConfig2(this.getFields()),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports2.GraphQLInterfaceType = GraphQLInterfaceType2;
      var GraphQLUnionType2 = class {
        constructor(config2) {
          var _config$extensionASTN4;
          this.name = (0, _assertName.assertName)(config2.name);
          this.description = config2.description;
          this.resolveType = config2.resolveType;
          this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN4 = config2.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
          this._types = defineTypes2.bind(void 0, config2);
          config2.resolveType == null || typeof config2.resolveType === "function" || (0, _devAssert.devAssert)(
            false,
            `${this.name} must provide "resolveType" as a function, but got: ${(0, _inspect.inspect)(config2.resolveType)}.`
          );
        }
        get [Symbol.toStringTag]() {
          return "GraphQLUnionType";
        }
        getTypes() {
          if (typeof this._types === "function") {
            this._types = this._types();
          }
          return this._types;
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            types: this.getTypes(),
            resolveType: this.resolveType,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports2.GraphQLUnionType = GraphQLUnionType2;
      function defineTypes2(config2) {
        const types = resolveReadonlyArrayThunk2(config2.types);
        Array.isArray(types) || (0, _devAssert.devAssert)(
          false,
          `Must provide Array of types or a function which returns such an array for Union ${config2.name}.`
        );
        return types;
      }
      var GraphQLEnumType2 = class {
        /* <T> */
        constructor(config2) {
          var _config$extensionASTN5;
          this.name = (0, _assertName.assertName)(config2.name);
          this.description = config2.description;
          this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN5 = config2.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
          this._values = defineEnumValues2(this.name, config2.values);
          this._valueLookup = new Map(
            this._values.map((enumValue) => [enumValue.value, enumValue])
          );
          this._nameLookup = (0, _keyMap.keyMap)(this._values, (value) => value.name);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLEnumType";
        }
        getValues() {
          return this._values;
        }
        getValue(name2) {
          return this._nameLookup[name2];
        }
        serialize(outputValue) {
          const enumValue = this._valueLookup.get(outputValue);
          if (enumValue === void 0) {
            throw new _GraphQLError.GraphQLError(
              `Enum "${this.name}" cannot represent value: ${(0, _inspect.inspect)(
                outputValue
              )}`
            );
          }
          return enumValue.name;
        }
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            const valueStr = (0, _inspect.inspect)(inputValue);
            throw new _GraphQLError.GraphQLError(
              `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue2(this, valueStr)
            );
          }
          const enumValue = this.getValue(inputValue);
          if (enumValue == null) {
            throw new _GraphQLError.GraphQLError(
              `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue2(this, inputValue)
            );
          }
          return enumValue.value;
        }
        parseLiteral(valueNode, _variables) {
          if (valueNode.kind !== _kinds.Kind.ENUM) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(
              `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue2(this, valueStr),
              {
                nodes: valueNode
              }
            );
          }
          const enumValue = this.getValue(valueNode.value);
          if (enumValue == null) {
            const valueStr = (0, _printer.print)(valueNode);
            throw new _GraphQLError.GraphQLError(
              `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue2(this, valueStr),
              {
                nodes: valueNode
              }
            );
          }
          return enumValue.value;
        }
        toConfig() {
          const values = (0, _keyValMap.keyValMap)(
            this.getValues(),
            (value) => value.name,
            (value) => ({
              description: value.description,
              value: value.value,
              deprecationReason: value.deprecationReason,
              extensions: value.extensions,
              astNode: value.astNode
            })
          );
          return {
            name: this.name,
            description: this.description,
            values,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports2.GraphQLEnumType = GraphQLEnumType2;
      function didYouMeanEnumValue2(enumType, unknownValueStr) {
        const allNames = enumType.getValues().map((value) => value.name);
        const suggestedValues = (0, _suggestionList.suggestionList)(
          unknownValueStr,
          allNames
        );
        return (0, _didYouMean.didYouMean)("the enum value", suggestedValues);
      }
      function defineEnumValues2(typeName, valueMap) {
        isPlainObj2(valueMap) || (0, _devAssert.devAssert)(
          false,
          `${typeName} values must be an object with value names as keys.`
        );
        return Object.entries(valueMap).map(([valueName, valueConfig]) => {
          isPlainObj2(valueConfig) || (0, _devAssert.devAssert)(
            false,
            `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${(0, _inspect.inspect)(
              valueConfig
            )}.`
          );
          return {
            name: (0, _assertName.assertEnumValueName)(valueName),
            description: valueConfig.description,
            value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
            deprecationReason: valueConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(valueConfig.extensions),
            astNode: valueConfig.astNode
          };
        });
      }
      var GraphQLInputObjectType2 = class {
        constructor(config2) {
          var _config$extensionASTN6;
          this.name = (0, _assertName.assertName)(config2.name);
          this.description = config2.description;
          this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN6 = config2.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
          this._fields = defineInputFieldMap2.bind(void 0, config2);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLInputObjectType";
        }
        getFields() {
          if (typeof this._fields === "function") {
            this._fields = this._fields();
          }
          return this._fields;
        }
        toConfig() {
          const fields = (0, _mapValue.mapValue)(this.getFields(), (field) => ({
            description: field.description,
            type: field.type,
            defaultValue: field.defaultValue,
            deprecationReason: field.deprecationReason,
            extensions: field.extensions,
            astNode: field.astNode
          }));
          return {
            name: this.name,
            description: this.description,
            fields,
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes
          };
        }
        toString() {
          return this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports2.GraphQLInputObjectType = GraphQLInputObjectType2;
      function defineInputFieldMap2(config2) {
        const fieldMap = resolveObjMapThunk2(config2.fields);
        isPlainObj2(fieldMap) || (0, _devAssert.devAssert)(
          false,
          `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`
        );
        return (0, _mapValue.mapValue)(fieldMap, (fieldConfig, fieldName) => {
          !("resolve" in fieldConfig) || (0, _devAssert.devAssert)(
            false,
            `${config2.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
          );
          return {
            name: (0, _assertName.assertName)(fieldName),
            description: fieldConfig.description,
            type: fieldConfig.type,
            defaultValue: fieldConfig.defaultValue,
            deprecationReason: fieldConfig.deprecationReason,
            extensions: (0, _toObjMap.toObjMap)(fieldConfig.extensions),
            astNode: fieldConfig.astNode
          };
        });
      }
      function isRequiredInputField2(field) {
        return isNonNullType2(field.type) && field.defaultValue === void 0;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/typeComparators.js
  var require_typeComparators = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/typeComparators.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.doTypesOverlap = doTypesOverlap2;
      exports2.isEqualType = isEqualType2;
      exports2.isTypeSubTypeOf = isTypeSubTypeOf2;
      var _definition = require_definition();
      function isEqualType2(typeA, typeB) {
        if (typeA === typeB) {
          return true;
        }
        if ((0, _definition.isNonNullType)(typeA) && (0, _definition.isNonNullType)(typeB)) {
          return isEqualType2(typeA.ofType, typeB.ofType);
        }
        if ((0, _definition.isListType)(typeA) && (0, _definition.isListType)(typeB)) {
          return isEqualType2(typeA.ofType, typeB.ofType);
        }
        return false;
      }
      function isTypeSubTypeOf2(schema, maybeSubType, superType) {
        if (maybeSubType === superType) {
          return true;
        }
        if ((0, _definition.isNonNullType)(superType)) {
          if ((0, _definition.isNonNullType)(maybeSubType)) {
            return isTypeSubTypeOf2(schema, maybeSubType.ofType, superType.ofType);
          }
          return false;
        }
        if ((0, _definition.isNonNullType)(maybeSubType)) {
          return isTypeSubTypeOf2(schema, maybeSubType.ofType, superType);
        }
        if ((0, _definition.isListType)(superType)) {
          if ((0, _definition.isListType)(maybeSubType)) {
            return isTypeSubTypeOf2(schema, maybeSubType.ofType, superType.ofType);
          }
          return false;
        }
        if ((0, _definition.isListType)(maybeSubType)) {
          return false;
        }
        return (0, _definition.isAbstractType)(superType) && ((0, _definition.isInterfaceType)(maybeSubType) || (0, _definition.isObjectType)(maybeSubType)) && schema.isSubType(superType, maybeSubType);
      }
      function doTypesOverlap2(schema, typeA, typeB) {
        if (typeA === typeB) {
          return true;
        }
        if ((0, _definition.isAbstractType)(typeA)) {
          if ((0, _definition.isAbstractType)(typeB)) {
            return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
          }
          return schema.isSubType(typeA, typeB);
        }
        if ((0, _definition.isAbstractType)(typeB)) {
          return schema.isSubType(typeB, typeA);
        }
        return false;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/directiveLocation.js
  var require_directiveLocation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/directiveLocation.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.DirectiveLocation = void 0;
      var DirectiveLocation2;
      exports2.DirectiveLocation = DirectiveLocation2;
      (function(DirectiveLocation3) {
        DirectiveLocation3["QUERY"] = "QUERY";
        DirectiveLocation3["MUTATION"] = "MUTATION";
        DirectiveLocation3["SUBSCRIPTION"] = "SUBSCRIPTION";
        DirectiveLocation3["FIELD"] = "FIELD";
        DirectiveLocation3["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
        DirectiveLocation3["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
        DirectiveLocation3["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
        DirectiveLocation3["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
        DirectiveLocation3["SCHEMA"] = "SCHEMA";
        DirectiveLocation3["SCALAR"] = "SCALAR";
        DirectiveLocation3["OBJECT"] = "OBJECT";
        DirectiveLocation3["FIELD_DEFINITION"] = "FIELD_DEFINITION";
        DirectiveLocation3["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
        DirectiveLocation3["INTERFACE"] = "INTERFACE";
        DirectiveLocation3["UNION"] = "UNION";
        DirectiveLocation3["ENUM"] = "ENUM";
        DirectiveLocation3["ENUM_VALUE"] = "ENUM_VALUE";
        DirectiveLocation3["INPUT_OBJECT"] = "INPUT_OBJECT";
        DirectiveLocation3["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
      })(DirectiveLocation2 || (exports2.DirectiveLocation = DirectiveLocation2 = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/scalars.js
  var require_scalars = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/scalars.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.GraphQLString = exports2.GraphQLInt = exports2.GraphQLID = exports2.GraphQLFloat = exports2.GraphQLBoolean = exports2.GRAPHQL_MIN_INT = exports2.GRAPHQL_MAX_INT = void 0;
      exports2.isSpecifiedScalarType = isSpecifiedScalarType2;
      exports2.specifiedScalarTypes = void 0;
      var _inspect = require_inspect();
      var _isObjectLike = require_isObjectLike();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var GRAPHQL_MAX_INT2 = 2147483647;
      exports2.GRAPHQL_MAX_INT = GRAPHQL_MAX_INT2;
      var GRAPHQL_MIN_INT2 = -2147483648;
      exports2.GRAPHQL_MIN_INT = GRAPHQL_MIN_INT2;
      var GraphQLInt2 = new _definition.GraphQLScalarType({
        name: "Int",
        description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
        serialize(outputValue) {
          const coercedValue = serializeObject2(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isInteger(num)) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
                coercedValue
              )}`
            );
          }
          if (num > GRAPHQL_MAX_INT2 || num < GRAPHQL_MIN_INT2) {
            throw new _GraphQLError.GraphQLError(
              "Int cannot represent non 32-bit signed integer value: " + (0, _inspect.inspect)(coercedValue)
            );
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non-integer value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          if (inputValue > GRAPHQL_MAX_INT2 || inputValue < GRAPHQL_MIN_INT2) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non 32-bit signed integer value: ${inputValue}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non-integer value: ${(0, _printer.print)(
                valueNode
              )}`,
              {
                nodes: valueNode
              }
            );
          }
          const num = parseInt(valueNode.value, 10);
          if (num > GRAPHQL_MAX_INT2 || num < GRAPHQL_MIN_INT2) {
            throw new _GraphQLError.GraphQLError(
              `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
              {
                nodes: valueNode
              }
            );
          }
          return num;
        }
      });
      exports2.GraphQLInt = GraphQLInt2;
      var GraphQLFloat2 = new _definition.GraphQLScalarType({
        name: "Float",
        description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
        serialize(outputValue) {
          const coercedValue = serializeObject2(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue ? 1 : 0;
          }
          let num = coercedValue;
          if (typeof coercedValue === "string" && coercedValue !== "") {
            num = Number(coercedValue);
          }
          if (typeof num !== "number" || !Number.isFinite(num)) {
            throw new _GraphQLError.GraphQLError(
              `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
                coercedValue
              )}`
            );
          }
          return num;
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
            throw new _GraphQLError.GraphQLError(
              `Float cannot represent non numeric value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.FLOAT && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(
              `Float cannot represent non numeric value: ${(0, _printer.print)(
                valueNode
              )}`,
              valueNode
            );
          }
          return parseFloat(valueNode.value);
        }
      });
      exports2.GraphQLFloat = GraphQLFloat2;
      var GraphQLString2 = new _definition.GraphQLScalarType({
        name: "String",
        description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
        serialize(outputValue) {
          const coercedValue = serializeObject2(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (typeof coercedValue === "boolean") {
            return coercedValue ? "true" : "false";
          }
          if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
            return coercedValue.toString();
          }
          throw new _GraphQLError.GraphQLError(
            `String cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "string") {
            throw new _GraphQLError.GraphQLError(
              `String cannot represent a non string value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.STRING) {
            throw new _GraphQLError.GraphQLError(
              `String cannot represent a non string value: ${(0, _printer.print)(
                valueNode
              )}`,
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      exports2.GraphQLString = GraphQLString2;
      var GraphQLBoolean2 = new _definition.GraphQLScalarType({
        name: "Boolean",
        description: "The `Boolean` scalar type represents `true` or `false`.",
        serialize(outputValue) {
          const coercedValue = serializeObject2(outputValue);
          if (typeof coercedValue === "boolean") {
            return coercedValue;
          }
          if (Number.isFinite(coercedValue)) {
            return coercedValue !== 0;
          }
          throw new _GraphQLError.GraphQLError(
            `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
              coercedValue
            )}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue !== "boolean") {
            throw new _GraphQLError.GraphQLError(
              `Boolean cannot represent a non boolean value: ${(0, _inspect.inspect)(
                inputValue
              )}`
            );
          }
          return inputValue;
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.BOOLEAN) {
            throw new _GraphQLError.GraphQLError(
              `Boolean cannot represent a non boolean value: ${(0, _printer.print)(
                valueNode
              )}`,
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      exports2.GraphQLBoolean = GraphQLBoolean2;
      var GraphQLID2 = new _definition.GraphQLScalarType({
        name: "ID",
        description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
        serialize(outputValue) {
          const coercedValue = serializeObject2(outputValue);
          if (typeof coercedValue === "string") {
            return coercedValue;
          }
          if (Number.isInteger(coercedValue)) {
            return String(coercedValue);
          }
          throw new _GraphQLError.GraphQLError(
            `ID cannot represent value: ${(0, _inspect.inspect)(outputValue)}`
          );
        },
        parseValue(inputValue) {
          if (typeof inputValue === "string") {
            return inputValue;
          }
          if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
            return inputValue.toString();
          }
          throw new _GraphQLError.GraphQLError(
            `ID cannot represent value: ${(0, _inspect.inspect)(inputValue)}`
          );
        },
        parseLiteral(valueNode) {
          if (valueNode.kind !== _kinds.Kind.STRING && valueNode.kind !== _kinds.Kind.INT) {
            throw new _GraphQLError.GraphQLError(
              "ID cannot represent a non-string and non-integer value: " + (0, _printer.print)(valueNode),
              {
                nodes: valueNode
              }
            );
          }
          return valueNode.value;
        }
      });
      exports2.GraphQLID = GraphQLID2;
      var specifiedScalarTypes2 = Object.freeze([
        GraphQLString2,
        GraphQLInt2,
        GraphQLFloat2,
        GraphQLBoolean2,
        GraphQLID2
      ]);
      exports2.specifiedScalarTypes = specifiedScalarTypes2;
      function isSpecifiedScalarType2(type) {
        return specifiedScalarTypes2.some(({ name: name2 }) => type.name === name2);
      }
      function serializeObject2(outputValue) {
        if ((0, _isObjectLike.isObjectLike)(outputValue)) {
          if (typeof outputValue.valueOf === "function") {
            const valueOfResult = outputValue.valueOf();
            if (!(0, _isObjectLike.isObjectLike)(valueOfResult)) {
              return valueOfResult;
            }
          }
          if (typeof outputValue.toJSON === "function") {
            return outputValue.toJSON();
          }
        }
        return outputValue;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/directives.js
  var require_directives = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/directives.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.GraphQLSpecifiedByDirective = exports2.GraphQLSkipDirective = exports2.GraphQLIncludeDirective = exports2.GraphQLDirective = exports2.GraphQLDeprecatedDirective = exports2.DEFAULT_DEPRECATION_REASON = void 0;
      exports2.assertDirective = assertDirective2;
      exports2.isDirective = isDirective2;
      exports2.isSpecifiedDirective = isSpecifiedDirective2;
      exports2.specifiedDirectives = void 0;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _toObjMap = require_toObjMap();
      var _directiveLocation = require_directiveLocation();
      var _assertName = require_assertName();
      var _definition = require_definition();
      var _scalars = require_scalars();
      function isDirective2(directive) {
        return (0, _instanceOf.instanceOf)(directive, GraphQLDirective2);
      }
      function assertDirective2(directive) {
        if (!isDirective2(directive)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(directive)} to be a GraphQL directive.`
          );
        }
        return directive;
      }
      var GraphQLDirective2 = class {
        constructor(config2) {
          var _config$isRepeatable, _config$args;
          this.name = (0, _assertName.assertName)(config2.name);
          this.description = config2.description;
          this.locations = config2.locations;
          this.isRepeatable = (_config$isRepeatable = config2.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
          this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
          this.astNode = config2.astNode;
          Array.isArray(config2.locations) || (0, _devAssert.devAssert)(
            false,
            `@${config2.name} locations must be an Array.`
          );
          const args = (_config$args = config2.args) !== null && _config$args !== void 0 ? _config$args : {};
          (0, _isObjectLike.isObjectLike)(args) && !Array.isArray(args) || (0, _devAssert.devAssert)(
            false,
            `@${config2.name} args must be an object with argument names as keys.`
          );
          this.args = (0, _definition.defineArguments)(args);
        }
        get [Symbol.toStringTag]() {
          return "GraphQLDirective";
        }
        toConfig() {
          return {
            name: this.name,
            description: this.description,
            locations: this.locations,
            args: (0, _definition.argsToArgsConfig)(this.args),
            isRepeatable: this.isRepeatable,
            extensions: this.extensions,
            astNode: this.astNode
          };
        }
        toString() {
          return "@" + this.name;
        }
        toJSON() {
          return this.toString();
        }
      };
      exports2.GraphQLDirective = GraphQLDirective2;
      var GraphQLIncludeDirective2 = new GraphQLDirective2({
        name: "include",
        description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD,
          _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Included when true."
          }
        }
      });
      exports2.GraphQLIncludeDirective = GraphQLIncludeDirective2;
      var GraphQLSkipDirective2 = new GraphQLDirective2({
        name: "skip",
        description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD,
          _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
          _directiveLocation.DirectiveLocation.INLINE_FRAGMENT
        ],
        args: {
          if: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            description: "Skipped when true."
          }
        }
      });
      exports2.GraphQLSkipDirective = GraphQLSkipDirective2;
      var DEFAULT_DEPRECATION_REASON2 = "No longer supported";
      exports2.DEFAULT_DEPRECATION_REASON = DEFAULT_DEPRECATION_REASON2;
      var GraphQLDeprecatedDirective2 = new GraphQLDirective2({
        name: "deprecated",
        description: "Marks an element of a GraphQL schema as no longer supported.",
        locations: [
          _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
          _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
          _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
          _directiveLocation.DirectiveLocation.ENUM_VALUE
        ],
        args: {
          reason: {
            type: _scalars.GraphQLString,
            description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
            defaultValue: DEFAULT_DEPRECATION_REASON2
          }
        }
      });
      exports2.GraphQLDeprecatedDirective = GraphQLDeprecatedDirective2;
      var GraphQLSpecifiedByDirective2 = new GraphQLDirective2({
        name: "specifiedBy",
        description: "Exposes a URL that specifies the behavior of this scalar.",
        locations: [_directiveLocation.DirectiveLocation.SCALAR],
        args: {
          url: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            description: "The URL that specifies the behavior of this scalar."
          }
        }
      });
      exports2.GraphQLSpecifiedByDirective = GraphQLSpecifiedByDirective2;
      var specifiedDirectives2 = Object.freeze([
        GraphQLIncludeDirective2,
        GraphQLSkipDirective2,
        GraphQLDeprecatedDirective2,
        GraphQLSpecifiedByDirective2
      ]);
      exports2.specifiedDirectives = specifiedDirectives2;
      function isSpecifiedDirective2(directive) {
        return specifiedDirectives2.some(({ name: name2 }) => name2 === directive.name);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isIterableObject.js
  var require_isIterableObject = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/isIterableObject.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.isIterableObject = isIterableObject2;
      function isIterableObject2(maybeIterable) {
        return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/astFromValue.js
  var require_astFromValue = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/astFromValue.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.astFromValue = astFromValue2;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _scalars = require_scalars();
      function astFromValue2(value, type) {
        if ((0, _definition.isNonNullType)(type)) {
          const astValue = astFromValue2(value, type.ofType);
          if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === _kinds.Kind.NULL) {
            return null;
          }
          return astValue;
        }
        if (value === null) {
          return {
            kind: _kinds.Kind.NULL
          };
        }
        if (value === void 0) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if ((0, _isIterableObject.isIterableObject)(value)) {
            const valuesNodes = [];
            for (const item of value) {
              const itemNode = astFromValue2(item, itemType);
              if (itemNode != null) {
                valuesNodes.push(itemNode);
              }
            }
            return {
              kind: _kinds.Kind.LIST,
              values: valuesNodes
            };
          }
          return astFromValue2(value, itemType);
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (!(0, _isObjectLike.isObjectLike)(value)) {
            return null;
          }
          const fieldNodes = [];
          for (const field of Object.values(type.getFields())) {
            const fieldValue = astFromValue2(value[field.name], field.type);
            if (fieldValue) {
              fieldNodes.push({
                kind: _kinds.Kind.OBJECT_FIELD,
                name: {
                  kind: _kinds.Kind.NAME,
                  value: field.name
                },
                value: fieldValue
              });
            }
          }
          return {
            kind: _kinds.Kind.OBJECT,
            fields: fieldNodes
          };
        }
        if ((0, _definition.isLeafType)(type)) {
          const serialized = type.serialize(value);
          if (serialized == null) {
            return null;
          }
          if (typeof serialized === "boolean") {
            return {
              kind: _kinds.Kind.BOOLEAN,
              value: serialized
            };
          }
          if (typeof serialized === "number" && Number.isFinite(serialized)) {
            const stringNum = String(serialized);
            return integerStringRegExp2.test(stringNum) ? {
              kind: _kinds.Kind.INT,
              value: stringNum
            } : {
              kind: _kinds.Kind.FLOAT,
              value: stringNum
            };
          }
          if (typeof serialized === "string") {
            if ((0, _definition.isEnumType)(type)) {
              return {
                kind: _kinds.Kind.ENUM,
                value: serialized
              };
            }
            if (type === _scalars.GraphQLID && integerStringRegExp2.test(serialized)) {
              return {
                kind: _kinds.Kind.INT,
                value: serialized
              };
            }
            return {
              kind: _kinds.Kind.STRING,
              value: serialized
            };
          }
          throw new TypeError(
            `Cannot convert value to AST: ${(0, _inspect.inspect)(serialized)}.`
          );
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected input type: " + (0, _inspect.inspect)(type)
        );
      }
      var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/introspection.js
  var require_introspection = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/introspection.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.introspectionTypes = exports2.__TypeKind = exports2.__Type = exports2.__Schema = exports2.__InputValue = exports2.__Field = exports2.__EnumValue = exports2.__DirectiveLocation = exports2.__Directive = exports2.TypeNameMetaFieldDef = exports2.TypeMetaFieldDef = exports2.TypeKind = exports2.SchemaMetaFieldDef = void 0;
      exports2.isIntrospectionType = isIntrospectionType2;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _directiveLocation = require_directiveLocation();
      var _printer = require_printer();
      var _astFromValue = require_astFromValue();
      var _definition = require_definition();
      var _scalars = require_scalars();
      var __Schema2 = new _definition.GraphQLObjectType({
        name: "__Schema",
        description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
        fields: () => ({
          description: {
            type: _scalars.GraphQLString,
            resolve: (schema) => schema.description
          },
          types: {
            description: "A list of all types supported by this server.",
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type2))
            ),
            resolve(schema) {
              return Object.values(schema.getTypeMap());
            }
          },
          queryType: {
            description: "The type that query operations will be rooted at.",
            type: new _definition.GraphQLNonNull(__Type2),
            resolve: (schema) => schema.getQueryType()
          },
          mutationType: {
            description: "If this server supports mutation, the type that mutation operations will be rooted at.",
            type: __Type2,
            resolve: (schema) => schema.getMutationType()
          },
          subscriptionType: {
            description: "If this server support subscription, the type that subscription operations will be rooted at.",
            type: __Type2,
            resolve: (schema) => schema.getSubscriptionType()
          },
          directives: {
            description: "A list of all directives supported by this server.",
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__Directive2)
              )
            ),
            resolve: (schema) => schema.getDirectives()
          }
        })
      });
      exports2.__Schema = __Schema2;
      var __Directive2 = new _definition.GraphQLObjectType({
        name: "__Directive",
        description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (directive) => directive.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (directive) => directive.description
          },
          isRepeatable: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (directive) => directive.isRepeatable
          },
          locations: {
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__DirectiveLocation2)
              )
            ),
            resolve: (directive) => directive.locations
          },
          args: {
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__InputValue2)
              )
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          }
        })
      });
      exports2.__Directive = __Directive2;
      var __DirectiveLocation2 = new _definition.GraphQLEnumType({
        name: "__DirectiveLocation",
        description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
        values: {
          QUERY: {
            value: _directiveLocation.DirectiveLocation.QUERY,
            description: "Location adjacent to a query operation."
          },
          MUTATION: {
            value: _directiveLocation.DirectiveLocation.MUTATION,
            description: "Location adjacent to a mutation operation."
          },
          SUBSCRIPTION: {
            value: _directiveLocation.DirectiveLocation.SUBSCRIPTION,
            description: "Location adjacent to a subscription operation."
          },
          FIELD: {
            value: _directiveLocation.DirectiveLocation.FIELD,
            description: "Location adjacent to a field."
          },
          FRAGMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION,
            description: "Location adjacent to a fragment definition."
          },
          FRAGMENT_SPREAD: {
            value: _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD,
            description: "Location adjacent to a fragment spread."
          },
          INLINE_FRAGMENT: {
            value: _directiveLocation.DirectiveLocation.INLINE_FRAGMENT,
            description: "Location adjacent to an inline fragment."
          },
          VARIABLE_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION,
            description: "Location adjacent to a variable definition."
          },
          SCHEMA: {
            value: _directiveLocation.DirectiveLocation.SCHEMA,
            description: "Location adjacent to a schema definition."
          },
          SCALAR: {
            value: _directiveLocation.DirectiveLocation.SCALAR,
            description: "Location adjacent to a scalar definition."
          },
          OBJECT: {
            value: _directiveLocation.DirectiveLocation.OBJECT,
            description: "Location adjacent to an object type definition."
          },
          FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.FIELD_DEFINITION,
            description: "Location adjacent to a field definition."
          },
          ARGUMENT_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION,
            description: "Location adjacent to an argument definition."
          },
          INTERFACE: {
            value: _directiveLocation.DirectiveLocation.INTERFACE,
            description: "Location adjacent to an interface definition."
          },
          UNION: {
            value: _directiveLocation.DirectiveLocation.UNION,
            description: "Location adjacent to a union definition."
          },
          ENUM: {
            value: _directiveLocation.DirectiveLocation.ENUM,
            description: "Location adjacent to an enum definition."
          },
          ENUM_VALUE: {
            value: _directiveLocation.DirectiveLocation.ENUM_VALUE,
            description: "Location adjacent to an enum value definition."
          },
          INPUT_OBJECT: {
            value: _directiveLocation.DirectiveLocation.INPUT_OBJECT,
            description: "Location adjacent to an input object type definition."
          },
          INPUT_FIELD_DEFINITION: {
            value: _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION,
            description: "Location adjacent to an input object field definition."
          }
        }
      });
      exports2.__DirectiveLocation = __DirectiveLocation2;
      var __Type2 = new _definition.GraphQLObjectType({
        name: "__Type",
        description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
        fields: () => ({
          kind: {
            type: new _definition.GraphQLNonNull(__TypeKind2),
            resolve(type) {
              if ((0, _definition.isScalarType)(type)) {
                return TypeKind2.SCALAR;
              }
              if ((0, _definition.isObjectType)(type)) {
                return TypeKind2.OBJECT;
              }
              if ((0, _definition.isInterfaceType)(type)) {
                return TypeKind2.INTERFACE;
              }
              if ((0, _definition.isUnionType)(type)) {
                return TypeKind2.UNION;
              }
              if ((0, _definition.isEnumType)(type)) {
                return TypeKind2.ENUM;
              }
              if ((0, _definition.isInputObjectType)(type)) {
                return TypeKind2.INPUT_OBJECT;
              }
              if ((0, _definition.isListType)(type)) {
                return TypeKind2.LIST;
              }
              if ((0, _definition.isNonNullType)(type)) {
                return TypeKind2.NON_NULL;
              }
              (0, _invariant.invariant)(
                false,
                `Unexpected type: "${(0, _inspect.inspect)(type)}".`
              );
            }
          },
          name: {
            type: _scalars.GraphQLString,
            resolve: (type) => "name" in type ? type.name : void 0
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (type) => (
              /* c8 ignore next */
              "description" in type ? type.description : void 0
            )
          },
          specifiedByURL: {
            type: _scalars.GraphQLString,
            resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
          },
          fields: {
            type: new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__Field2)
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                const fields = Object.values(type.getFields());
                return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
              }
            }
          },
          interfaces: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type2)),
            resolve(type) {
              if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
                return type.getInterfaces();
              }
            }
          },
          possibleTypes: {
            type: new _definition.GraphQLList(new _definition.GraphQLNonNull(__Type2)),
            resolve(type, _args, _context, { schema }) {
              if ((0, _definition.isAbstractType)(type)) {
                return schema.getPossibleTypes(type);
              }
            }
          },
          enumValues: {
            type: new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__EnumValue2)
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isEnumType)(type)) {
                const values = type.getValues();
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          inputFields: {
            type: new _definition.GraphQLList(
              new _definition.GraphQLNonNull(__InputValue2)
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(type, { includeDeprecated }) {
              if ((0, _definition.isInputObjectType)(type)) {
                const values = Object.values(type.getFields());
                return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
              }
            }
          },
          ofType: {
            type: __Type2,
            resolve: (type) => "ofType" in type ? type.ofType : void 0
          }
        })
      });
      exports2.__Type = __Type2;
      var __Field2 = new _definition.GraphQLObjectType({
        name: "__Field",
        description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (field) => field.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (field) => field.description
          },
          args: {
            type: new _definition.GraphQLNonNull(
              new _definition.GraphQLList(
                new _definition.GraphQLNonNull(__InputValue2)
              )
            ),
            args: {
              includeDeprecated: {
                type: _scalars.GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve(field, { includeDeprecated }) {
              return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
            }
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type2),
            resolve: (field) => field.type
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (field) => field.deprecationReason
          }
        })
      });
      exports2.__Field = __Field2;
      var __InputValue2 = new _definition.GraphQLObjectType({
        name: "__InputValue",
        description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (inputValue) => inputValue.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (inputValue) => inputValue.description
          },
          type: {
            type: new _definition.GraphQLNonNull(__Type2),
            resolve: (inputValue) => inputValue.type
          },
          defaultValue: {
            type: _scalars.GraphQLString,
            description: "A GraphQL-formatted string representing the default value for this input value.",
            resolve(inputValue) {
              const { type, defaultValue } = inputValue;
              const valueAST = (0, _astFromValue.astFromValue)(defaultValue, type);
              return valueAST ? (0, _printer.print)(valueAST) : null;
            }
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (field) => field.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (obj) => obj.deprecationReason
          }
        })
      });
      exports2.__InputValue = __InputValue2;
      var __EnumValue2 = new _definition.GraphQLObjectType({
        name: "__EnumValue",
        description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
        fields: () => ({
          name: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            resolve: (enumValue) => enumValue.name
          },
          description: {
            type: _scalars.GraphQLString,
            resolve: (enumValue) => enumValue.description
          },
          isDeprecated: {
            type: new _definition.GraphQLNonNull(_scalars.GraphQLBoolean),
            resolve: (enumValue) => enumValue.deprecationReason != null
          },
          deprecationReason: {
            type: _scalars.GraphQLString,
            resolve: (enumValue) => enumValue.deprecationReason
          }
        })
      });
      exports2.__EnumValue = __EnumValue2;
      var TypeKind2;
      exports2.TypeKind = TypeKind2;
      (function(TypeKind3) {
        TypeKind3["SCALAR"] = "SCALAR";
        TypeKind3["OBJECT"] = "OBJECT";
        TypeKind3["INTERFACE"] = "INTERFACE";
        TypeKind3["UNION"] = "UNION";
        TypeKind3["ENUM"] = "ENUM";
        TypeKind3["INPUT_OBJECT"] = "INPUT_OBJECT";
        TypeKind3["LIST"] = "LIST";
        TypeKind3["NON_NULL"] = "NON_NULL";
      })(TypeKind2 || (exports2.TypeKind = TypeKind2 = {}));
      var __TypeKind2 = new _definition.GraphQLEnumType({
        name: "__TypeKind",
        description: "An enum describing what kind of type a given `__Type` is.",
        values: {
          SCALAR: {
            value: TypeKind2.SCALAR,
            description: "Indicates this type is a scalar."
          },
          OBJECT: {
            value: TypeKind2.OBJECT,
            description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
          },
          INTERFACE: {
            value: TypeKind2.INTERFACE,
            description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
          },
          UNION: {
            value: TypeKind2.UNION,
            description: "Indicates this type is a union. `possibleTypes` is a valid field."
          },
          ENUM: {
            value: TypeKind2.ENUM,
            description: "Indicates this type is an enum. `enumValues` is a valid field."
          },
          INPUT_OBJECT: {
            value: TypeKind2.INPUT_OBJECT,
            description: "Indicates this type is an input object. `inputFields` is a valid field."
          },
          LIST: {
            value: TypeKind2.LIST,
            description: "Indicates this type is a list. `ofType` is a valid field."
          },
          NON_NULL: {
            value: TypeKind2.NON_NULL,
            description: "Indicates this type is a non-null. `ofType` is a valid field."
          }
        }
      });
      exports2.__TypeKind = __TypeKind2;
      var SchemaMetaFieldDef2 = {
        name: "__schema",
        type: new _definition.GraphQLNonNull(__Schema2),
        description: "Access the current type schema of this server.",
        args: [],
        resolve: (_source, _args, _context, { schema }) => schema,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports2.SchemaMetaFieldDef = SchemaMetaFieldDef2;
      var TypeMetaFieldDef2 = {
        name: "__type",
        type: __Type2,
        description: "Request the type information of a single type.",
        args: [
          {
            name: "name",
            description: void 0,
            type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
            defaultValue: void 0,
            deprecationReason: void 0,
            extensions: /* @__PURE__ */ Object.create(null),
            astNode: void 0
          }
        ],
        resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports2.TypeMetaFieldDef = TypeMetaFieldDef2;
      var TypeNameMetaFieldDef2 = {
        name: "__typename",
        type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
        description: "The name of the current Object type at runtime.",
        args: [],
        resolve: (_source, _args, _context, { parentType }) => parentType.name,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      };
      exports2.TypeNameMetaFieldDef = TypeNameMetaFieldDef2;
      var introspectionTypes2 = Object.freeze([
        __Schema2,
        __Directive2,
        __DirectiveLocation2,
        __Type2,
        __Field2,
        __InputValue2,
        __EnumValue2,
        __TypeKind2
      ]);
      exports2.introspectionTypes = introspectionTypes2;
      function isIntrospectionType2(type) {
        return introspectionTypes2.some(({ name: name2 }) => type.name === name2);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/schema.js
  var require_schema = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/schema.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.GraphQLSchema = void 0;
      exports2.assertSchema = assertSchema2;
      exports2.isSchema = isSchema2;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var _isObjectLike = require_isObjectLike();
      var _toObjMap = require_toObjMap();
      var _ast = require_ast2();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      function isSchema2(schema) {
        return (0, _instanceOf.instanceOf)(schema, GraphQLSchema2);
      }
      function assertSchema2(schema) {
        if (!isSchema2(schema)) {
          throw new Error(
            `Expected ${(0, _inspect.inspect)(schema)} to be a GraphQL schema.`
          );
        }
        return schema;
      }
      var GraphQLSchema2 = class {
        // Used as a cache for validateSchema().
        constructor(config2) {
          var _config$extensionASTN, _config$directives;
          this.__validationErrors = config2.assumeValid === true ? [] : void 0;
          (0, _isObjectLike.isObjectLike)(config2) || (0, _devAssert.devAssert)(false, "Must provide configuration object.");
          !config2.types || Array.isArray(config2.types) || (0, _devAssert.devAssert)(
            false,
            `"types" must be Array if provided but got: ${(0, _inspect.inspect)(
              config2.types
            )}.`
          );
          !config2.directives || Array.isArray(config2.directives) || (0, _devAssert.devAssert)(
            false,
            `"directives" must be Array if provided but got: ${(0, _inspect.inspect)(config2.directives)}.`
          );
          this.description = config2.description;
          this.extensions = (0, _toObjMap.toObjMap)(config2.extensions);
          this.astNode = config2.astNode;
          this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
          this._queryType = config2.query;
          this._mutationType = config2.mutation;
          this._subscriptionType = config2.subscription;
          this._directives = (_config$directives = config2.directives) !== null && _config$directives !== void 0 ? _config$directives : _directives.specifiedDirectives;
          const allReferencedTypes = new Set(config2.types);
          if (config2.types != null) {
            for (const type of config2.types) {
              allReferencedTypes.delete(type);
              collectReferencedTypes2(type, allReferencedTypes);
            }
          }
          if (this._queryType != null) {
            collectReferencedTypes2(this._queryType, allReferencedTypes);
          }
          if (this._mutationType != null) {
            collectReferencedTypes2(this._mutationType, allReferencedTypes);
          }
          if (this._subscriptionType != null) {
            collectReferencedTypes2(this._subscriptionType, allReferencedTypes);
          }
          for (const directive of this._directives) {
            if ((0, _directives.isDirective)(directive)) {
              for (const arg of directive.args) {
                collectReferencedTypes2(arg.type, allReferencedTypes);
              }
            }
          }
          collectReferencedTypes2(_introspection.__Schema, allReferencedTypes);
          this._typeMap = /* @__PURE__ */ Object.create(null);
          this._subTypeMap = /* @__PURE__ */ Object.create(null);
          this._implementationsMap = /* @__PURE__ */ Object.create(null);
          for (const namedType of allReferencedTypes) {
            if (namedType == null) {
              continue;
            }
            const typeName = namedType.name;
            typeName || (0, _devAssert.devAssert)(
              false,
              "One of the provided types for building the Schema is missing a name."
            );
            if (this._typeMap[typeName] !== void 0) {
              throw new Error(
                `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
              );
            }
            this._typeMap[typeName] = namedType;
            if ((0, _definition.isInterfaceType)(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if ((0, _definition.isInterfaceType)(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.interfaces.push(namedType);
                }
              }
            } else if ((0, _definition.isObjectType)(namedType)) {
              for (const iface of namedType.getInterfaces()) {
                if ((0, _definition.isInterfaceType)(iface)) {
                  let implementations = this._implementationsMap[iface.name];
                  if (implementations === void 0) {
                    implementations = this._implementationsMap[iface.name] = {
                      objects: [],
                      interfaces: []
                    };
                  }
                  implementations.objects.push(namedType);
                }
              }
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLSchema";
        }
        getQueryType() {
          return this._queryType;
        }
        getMutationType() {
          return this._mutationType;
        }
        getSubscriptionType() {
          return this._subscriptionType;
        }
        getRootType(operation) {
          switch (operation) {
            case _ast.OperationTypeNode.QUERY:
              return this.getQueryType();
            case _ast.OperationTypeNode.MUTATION:
              return this.getMutationType();
            case _ast.OperationTypeNode.SUBSCRIPTION:
              return this.getSubscriptionType();
          }
        }
        getTypeMap() {
          return this._typeMap;
        }
        getType(name2) {
          return this.getTypeMap()[name2];
        }
        getPossibleTypes(abstractType) {
          return (0, _definition.isUnionType)(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
        }
        getImplementations(interfaceType) {
          const implementations = this._implementationsMap[interfaceType.name];
          return implementations !== null && implementations !== void 0 ? implementations : {
            objects: [],
            interfaces: []
          };
        }
        isSubType(abstractType, maybeSubType) {
          let map = this._subTypeMap[abstractType.name];
          if (map === void 0) {
            map = /* @__PURE__ */ Object.create(null);
            if ((0, _definition.isUnionType)(abstractType)) {
              for (const type of abstractType.getTypes()) {
                map[type.name] = true;
              }
            } else {
              const implementations = this.getImplementations(abstractType);
              for (const type of implementations.objects) {
                map[type.name] = true;
              }
              for (const type of implementations.interfaces) {
                map[type.name] = true;
              }
            }
            this._subTypeMap[abstractType.name] = map;
          }
          return map[maybeSubType.name] !== void 0;
        }
        getDirectives() {
          return this._directives;
        }
        getDirective(name2) {
          return this.getDirectives().find((directive) => directive.name === name2);
        }
        toConfig() {
          return {
            description: this.description,
            query: this.getQueryType(),
            mutation: this.getMutationType(),
            subscription: this.getSubscriptionType(),
            types: Object.values(this.getTypeMap()),
            directives: this.getDirectives(),
            extensions: this.extensions,
            astNode: this.astNode,
            extensionASTNodes: this.extensionASTNodes,
            assumeValid: this.__validationErrors !== void 0
          };
        }
      };
      exports2.GraphQLSchema = GraphQLSchema2;
      function collectReferencedTypes2(type, typeSet) {
        const namedType = (0, _definition.getNamedType)(type);
        if (!typeSet.has(namedType)) {
          typeSet.add(namedType);
          if ((0, _definition.isUnionType)(namedType)) {
            for (const memberType of namedType.getTypes()) {
              collectReferencedTypes2(memberType, typeSet);
            }
          } else if ((0, _definition.isObjectType)(namedType) || (0, _definition.isInterfaceType)(namedType)) {
            for (const interfaceType of namedType.getInterfaces()) {
              collectReferencedTypes2(interfaceType, typeSet);
            }
            for (const field of Object.values(namedType.getFields())) {
              collectReferencedTypes2(field.type, typeSet);
              for (const arg of field.args) {
                collectReferencedTypes2(arg.type, typeSet);
              }
            }
          } else if ((0, _definition.isInputObjectType)(namedType)) {
            for (const field of Object.values(namedType.getFields())) {
              collectReferencedTypes2(field.type, typeSet);
            }
          }
        }
        return typeSet;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/validate.js
  var require_validate = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/type/validate.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.assertValidSchema = assertValidSchema2;
      exports2.validateSchema = validateSchema2;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _ast = require_ast2();
      var _typeComparators = require_typeComparators();
      var _definition = require_definition();
      var _directives = require_directives();
      var _introspection = require_introspection();
      var _schema = require_schema();
      function validateSchema2(schema) {
        (0, _schema.assertSchema)(schema);
        if (schema.__validationErrors) {
          return schema.__validationErrors;
        }
        const context = new SchemaValidationContext2(schema);
        validateRootTypes2(context);
        validateDirectives2(context);
        validateTypes2(context);
        const errors = context.getErrors();
        schema.__validationErrors = errors;
        return errors;
      }
      function assertValidSchema2(schema) {
        const errors = validateSchema2(schema);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
      var SchemaValidationContext2 = class {
        constructor(schema) {
          this._errors = [];
          this.schema = schema;
        }
        reportError(message, nodes) {
          const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
          this._errors.push(
            new _GraphQLError.GraphQLError(message, {
              nodes: _nodes
            })
          );
        }
        getErrors() {
          return this._errors;
        }
      };
      function validateRootTypes2(context) {
        const schema = context.schema;
        const queryType = schema.getQueryType();
        if (!queryType) {
          context.reportError("Query root type must be provided.", schema.astNode);
        } else if (!(0, _definition.isObjectType)(queryType)) {
          var _getOperationTypeNode;
          context.reportError(
            `Query root type must be Object type, it cannot be ${(0, _inspect.inspect)(queryType)}.`,
            (_getOperationTypeNode = getOperationTypeNode2(
              schema,
              _ast.OperationTypeNode.QUERY
            )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
          );
        }
        const mutationType = schema.getMutationType();
        if (mutationType && !(0, _definition.isObjectType)(mutationType)) {
          var _getOperationTypeNode2;
          context.reportError(
            `Mutation root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(mutationType)}.`,
            (_getOperationTypeNode2 = getOperationTypeNode2(
              schema,
              _ast.OperationTypeNode.MUTATION
            )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
          );
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType && !(0, _definition.isObjectType)(subscriptionType)) {
          var _getOperationTypeNode3;
          context.reportError(
            `Subscription root type must be Object type if provided, it cannot be ${(0, _inspect.inspect)(subscriptionType)}.`,
            (_getOperationTypeNode3 = getOperationTypeNode2(
              schema,
              _ast.OperationTypeNode.SUBSCRIPTION
            )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
          );
        }
      }
      function getOperationTypeNode2(schema, operation) {
        var _flatMap$find;
        return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          (schemaNode) => {
            var _schemaNode$operation;
            return (
              /* c8 ignore next */
              (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
            );
          }
        ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
      }
      function validateDirectives2(context) {
        for (const directive of context.schema.getDirectives()) {
          if (!(0, _directives.isDirective)(directive)) {
            context.reportError(
              `Expected directive but got: ${(0, _inspect.inspect)(directive)}.`,
              directive === null || directive === void 0 ? void 0 : directive.astNode
            );
            continue;
          }
          validateName2(context, directive);
          for (const arg of directive.args) {
            validateName2(context, arg);
            if (!(0, _definition.isInputType)(arg.type)) {
              context.reportError(
                `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
                arg.astNode
              );
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
              var _arg$astNode;
              context.reportError(
                `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
                [
                  getDeprecatedDirectiveNode2(arg.astNode),
                  (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
                ]
              );
            }
          }
        }
      }
      function validateName2(context, node) {
        if (node.name.startsWith("__")) {
          context.reportError(
            `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
            node.astNode
          );
        }
      }
      function validateTypes2(context) {
        const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator2(context);
        const typeMap = context.schema.getTypeMap();
        for (const type of Object.values(typeMap)) {
          if (!(0, _definition.isNamedType)(type)) {
            context.reportError(
              `Expected GraphQL named type but got: ${(0, _inspect.inspect)(type)}.`,
              type.astNode
            );
            continue;
          }
          if (!(0, _introspection.isIntrospectionType)(type)) {
            validateName2(context, type);
          }
          if ((0, _definition.isObjectType)(type)) {
            validateFields2(context, type);
            validateInterfaces2(context, type);
          } else if ((0, _definition.isInterfaceType)(type)) {
            validateFields2(context, type);
            validateInterfaces2(context, type);
          } else if ((0, _definition.isUnionType)(type)) {
            validateUnionMembers2(context, type);
          } else if ((0, _definition.isEnumType)(type)) {
            validateEnumValues2(context, type);
          } else if ((0, _definition.isInputObjectType)(type)) {
            validateInputFields2(context, type);
            validateInputObjectCircularRefs(type);
          }
        }
      }
      function validateFields2(context, type) {
        const fields = Object.values(type.getFields());
        if (fields.length === 0) {
          context.reportError(`Type ${type.name} must define one or more fields.`, [
            type.astNode,
            ...type.extensionASTNodes
          ]);
        }
        for (const field of fields) {
          validateName2(context, field);
          if (!(0, _definition.isOutputType)(field.type)) {
            var _field$astNode;
            context.reportError(
              `The type of ${type.name}.${field.name} must be Output Type but got: ${(0, _inspect.inspect)(field.type)}.`,
              (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
            );
          }
          for (const arg of field.args) {
            const argName = arg.name;
            validateName2(context, arg);
            if (!(0, _definition.isInputType)(arg.type)) {
              var _arg$astNode2;
              context.reportError(
                `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${(0, _inspect.inspect)(arg.type)}.`,
                (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
              );
            }
            if ((0, _definition.isRequiredArgument)(arg) && arg.deprecationReason != null) {
              var _arg$astNode3;
              context.reportError(
                `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
                [
                  getDeprecatedDirectiveNode2(arg.astNode),
                  (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
                ]
              );
            }
          }
        }
      }
      function validateInterfaces2(context, type) {
        const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
        for (const iface of type.getInterfaces()) {
          if (!(0, _definition.isInterfaceType)(iface)) {
            context.reportError(
              `Type ${(0, _inspect.inspect)(
                type
              )} must only implement Interface types, it cannot implement ${(0, _inspect.inspect)(iface)}.`,
              getAllImplementsInterfaceNodes2(type, iface)
            );
            continue;
          }
          if (type === iface) {
            context.reportError(
              `Type ${type.name} cannot implement itself because it would create a circular reference.`,
              getAllImplementsInterfaceNodes2(type, iface)
            );
            continue;
          }
          if (ifaceTypeNames[iface.name]) {
            context.reportError(
              `Type ${type.name} can only implement ${iface.name} once.`,
              getAllImplementsInterfaceNodes2(type, iface)
            );
            continue;
          }
          ifaceTypeNames[iface.name] = true;
          validateTypeImplementsAncestors2(context, type, iface);
          validateTypeImplementsInterface2(context, type, iface);
        }
      }
      function validateTypeImplementsInterface2(context, type, iface) {
        const typeFieldMap = type.getFields();
        for (const ifaceField of Object.values(iface.getFields())) {
          const fieldName = ifaceField.name;
          const typeField = typeFieldMap[fieldName];
          if (!typeField) {
            context.reportError(
              `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
              [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
            );
            continue;
          }
          if (!(0, _typeComparators.isTypeSubTypeOf)(
            context.schema,
            typeField.type,
            ifaceField.type
          )) {
            var _ifaceField$astNode, _typeField$astNode;
            context.reportError(
              `Interface field ${iface.name}.${fieldName} expects type ${(0, _inspect.inspect)(ifaceField.type)} but ${type.name}.${fieldName} is type ${(0, _inspect.inspect)(typeField.type)}.`,
              [
                (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
                (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
              ]
            );
          }
          for (const ifaceArg of ifaceField.args) {
            const argName = ifaceArg.name;
            const typeArg = typeField.args.find((arg) => arg.name === argName);
            if (!typeArg) {
              context.reportError(
                `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
                [ifaceArg.astNode, typeField.astNode]
              );
              continue;
            }
            if (!(0, _typeComparators.isEqualType)(ifaceArg.type, typeArg.type)) {
              var _ifaceArg$astNode, _typeArg$astNode;
              context.reportError(
                `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${(0, _inspect.inspect)(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${(0, _inspect.inspect)(typeArg.type)}.`,
                [
                  (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
                  (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
                ]
              );
            }
          }
          for (const typeArg of typeField.args) {
            const argName = typeArg.name;
            const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
            if (!ifaceArg && (0, _definition.isRequiredArgument)(typeArg)) {
              context.reportError(
                `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
                [typeArg.astNode, ifaceField.astNode]
              );
            }
          }
        }
      }
      function validateTypeImplementsAncestors2(context, type, iface) {
        const ifaceInterfaces = type.getInterfaces();
        for (const transitive of iface.getInterfaces()) {
          if (!ifaceInterfaces.includes(transitive)) {
            context.reportError(
              transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
              [
                ...getAllImplementsInterfaceNodes2(iface, transitive),
                ...getAllImplementsInterfaceNodes2(type, iface)
              ]
            );
          }
        }
      }
      function validateUnionMembers2(context, union) {
        const memberTypes = union.getTypes();
        if (memberTypes.length === 0) {
          context.reportError(
            `Union type ${union.name} must define one or more member types.`,
            [union.astNode, ...union.extensionASTNodes]
          );
        }
        const includedTypeNames = /* @__PURE__ */ Object.create(null);
        for (const memberType of memberTypes) {
          if (includedTypeNames[memberType.name]) {
            context.reportError(
              `Union type ${union.name} can only include type ${memberType.name} once.`,
              getUnionMemberTypeNodes2(union, memberType.name)
            );
            continue;
          }
          includedTypeNames[memberType.name] = true;
          if (!(0, _definition.isObjectType)(memberType)) {
            context.reportError(
              `Union type ${union.name} can only include Object types, it cannot include ${(0, _inspect.inspect)(memberType)}.`,
              getUnionMemberTypeNodes2(union, String(memberType))
            );
          }
        }
      }
      function validateEnumValues2(context, enumType) {
        const enumValues = enumType.getValues();
        if (enumValues.length === 0) {
          context.reportError(
            `Enum type ${enumType.name} must define one or more values.`,
            [enumType.astNode, ...enumType.extensionASTNodes]
          );
        }
        for (const enumValue of enumValues) {
          validateName2(context, enumValue);
        }
      }
      function validateInputFields2(context, inputObj) {
        const fields = Object.values(inputObj.getFields());
        if (fields.length === 0) {
          context.reportError(
            `Input Object type ${inputObj.name} must define one or more fields.`,
            [inputObj.astNode, ...inputObj.extensionASTNodes]
          );
        }
        for (const field of fields) {
          validateName2(context, field);
          if (!(0, _definition.isInputType)(field.type)) {
            var _field$astNode2;
            context.reportError(
              `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${(0, _inspect.inspect)(field.type)}.`,
              (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
            );
          }
          if ((0, _definition.isRequiredInputField)(field) && field.deprecationReason != null) {
            var _field$astNode3;
            context.reportError(
              `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
              [
                getDeprecatedDirectiveNode2(field.astNode),
                (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
              ]
            );
          }
        }
      }
      function createInputObjectCircularRefsValidator2(context) {
        const visitedTypes = /* @__PURE__ */ Object.create(null);
        const fieldPath = [];
        const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
        return detectCycleRecursive;
        function detectCycleRecursive(inputObj) {
          if (visitedTypes[inputObj.name]) {
            return;
          }
          visitedTypes[inputObj.name] = true;
          fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
          const fields = Object.values(inputObj.getFields());
          for (const field of fields) {
            if ((0, _definition.isNonNullType)(field.type) && (0, _definition.isInputObjectType)(field.type.ofType)) {
              const fieldType = field.type.ofType;
              const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
              fieldPath.push(field);
              if (cycleIndex === void 0) {
                detectCycleRecursive(fieldType);
              } else {
                const cyclePath = fieldPath.slice(cycleIndex);
                const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
                context.reportError(
                  `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
                  cyclePath.map((fieldObj) => fieldObj.astNode)
                );
              }
              fieldPath.pop();
            }
          }
          fieldPathIndexByTypeName[inputObj.name] = void 0;
        }
      }
      function getAllImplementsInterfaceNodes2(type, iface) {
        const { astNode, extensionASTNodes } = type;
        const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
        return nodes.flatMap((typeNode) => {
          var _typeNode$interfaces;
          return (
            /* c8 ignore next */
            (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
          );
        }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
      }
      function getUnionMemberTypeNodes2(union, typeName) {
        const { astNode, extensionASTNodes } = union;
        const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
        return nodes.flatMap((unionNode) => {
          var _unionNode$types;
          return (
            /* c8 ignore next */
            (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
          );
        }).filter((typeNode) => typeNode.name.value === typeName);
      }
      function getDeprecatedDirectiveNode2(definitionNode) {
        var _definitionNode$direc;
        return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
          (node) => node.name.value === _directives.GraphQLDeprecatedDirective.name
        );
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/typeFromAST.js
  var require_typeFromAST = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/typeFromAST.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.typeFromAST = typeFromAST2;
      var _kinds = require_kinds();
      var _definition = require_definition();
      function typeFromAST2(schema, typeNode) {
        switch (typeNode.kind) {
          case _kinds.Kind.LIST_TYPE: {
            const innerType = typeFromAST2(schema, typeNode.type);
            return innerType && new _definition.GraphQLList(innerType);
          }
          case _kinds.Kind.NON_NULL_TYPE: {
            const innerType = typeFromAST2(schema, typeNode.type);
            return innerType && new _definition.GraphQLNonNull(innerType);
          }
          case _kinds.Kind.NAMED_TYPE:
            return schema.getType(typeNode.name.value);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/TypeInfo.js
  var require_TypeInfo = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/TypeInfo.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.TypeInfo = void 0;
      exports2.visitWithTypeInfo = visitWithTypeInfo2;
      var _ast = require_ast2();
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      var _definition = require_definition();
      var _introspection = require_introspection();
      var _typeFromAST = require_typeFromAST();
      var TypeInfo2 = class {
        constructor(schema, initialType, getFieldDefFn) {
          this._schema = schema;
          this._typeStack = [];
          this._parentTypeStack = [];
          this._inputTypeStack = [];
          this._fieldDefStack = [];
          this._defaultValueStack = [];
          this._directive = null;
          this._argument = null;
          this._enumValue = null;
          this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef3;
          if (initialType) {
            if ((0, _definition.isInputType)(initialType)) {
              this._inputTypeStack.push(initialType);
            }
            if ((0, _definition.isCompositeType)(initialType)) {
              this._parentTypeStack.push(initialType);
            }
            if ((0, _definition.isOutputType)(initialType)) {
              this._typeStack.push(initialType);
            }
          }
        }
        get [Symbol.toStringTag]() {
          return "TypeInfo";
        }
        getType() {
          if (this._typeStack.length > 0) {
            return this._typeStack[this._typeStack.length - 1];
          }
        }
        getParentType() {
          if (this._parentTypeStack.length > 0) {
            return this._parentTypeStack[this._parentTypeStack.length - 1];
          }
        }
        getInputType() {
          if (this._inputTypeStack.length > 0) {
            return this._inputTypeStack[this._inputTypeStack.length - 1];
          }
        }
        getParentInputType() {
          if (this._inputTypeStack.length > 1) {
            return this._inputTypeStack[this._inputTypeStack.length - 2];
          }
        }
        getFieldDef() {
          if (this._fieldDefStack.length > 0) {
            return this._fieldDefStack[this._fieldDefStack.length - 1];
          }
        }
        getDefaultValue() {
          if (this._defaultValueStack.length > 0) {
            return this._defaultValueStack[this._defaultValueStack.length - 1];
          }
        }
        getDirective() {
          return this._directive;
        }
        getArgument() {
          return this._argument;
        }
        getEnumValue() {
          return this._enumValue;
        }
        enter(node) {
          const schema = this._schema;
          switch (node.kind) {
            case _kinds.Kind.SELECTION_SET: {
              const namedType = (0, _definition.getNamedType)(this.getType());
              this._parentTypeStack.push(
                (0, _definition.isCompositeType)(namedType) ? namedType : void 0
              );
              break;
            }
            case _kinds.Kind.FIELD: {
              const parentType = this.getParentType();
              let fieldDef;
              let fieldType;
              if (parentType) {
                fieldDef = this._getFieldDef(schema, parentType, node);
                if (fieldDef) {
                  fieldType = fieldDef.type;
                }
              }
              this._fieldDefStack.push(fieldDef);
              this._typeStack.push(
                (0, _definition.isOutputType)(fieldType) ? fieldType : void 0
              );
              break;
            }
            case _kinds.Kind.DIRECTIVE:
              this._directive = schema.getDirective(node.name.value);
              break;
            case _kinds.Kind.OPERATION_DEFINITION: {
              const rootType = schema.getRootType(node.operation);
              this._typeStack.push(
                (0, _definition.isObjectType)(rootType) ? rootType : void 0
              );
              break;
            }
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION: {
              const typeConditionAST = node.typeCondition;
              const outputType = typeConditionAST ? (0, _typeFromAST.typeFromAST)(schema, typeConditionAST) : (0, _definition.getNamedType)(this.getType());
              this._typeStack.push(
                (0, _definition.isOutputType)(outputType) ? outputType : void 0
              );
              break;
            }
            case _kinds.Kind.VARIABLE_DEFINITION: {
              const inputType = (0, _typeFromAST.typeFromAST)(schema, node.type);
              this._inputTypeStack.push(
                (0, _definition.isInputType)(inputType) ? inputType : void 0
              );
              break;
            }
            case _kinds.Kind.ARGUMENT: {
              var _this$getDirective;
              let argDef;
              let argType;
              const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
              if (fieldOrDirective) {
                argDef = fieldOrDirective.args.find(
                  (arg) => arg.name === node.name.value
                );
                if (argDef) {
                  argType = argDef.type;
                }
              }
              this._argument = argDef;
              this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
              this._inputTypeStack.push(
                (0, _definition.isInputType)(argType) ? argType : void 0
              );
              break;
            }
            case _kinds.Kind.LIST: {
              const listType = (0, _definition.getNullableType)(this.getInputType());
              const itemType = (0, _definition.isListType)(listType) ? listType.ofType : listType;
              this._defaultValueStack.push(void 0);
              this._inputTypeStack.push(
                (0, _definition.isInputType)(itemType) ? itemType : void 0
              );
              break;
            }
            case _kinds.Kind.OBJECT_FIELD: {
              const objectType = (0, _definition.getNamedType)(this.getInputType());
              let inputFieldType;
              let inputField;
              if ((0, _definition.isInputObjectType)(objectType)) {
                inputField = objectType.getFields()[node.name.value];
                if (inputField) {
                  inputFieldType = inputField.type;
                }
              }
              this._defaultValueStack.push(
                inputField ? inputField.defaultValue : void 0
              );
              this._inputTypeStack.push(
                (0, _definition.isInputType)(inputFieldType) ? inputFieldType : void 0
              );
              break;
            }
            case _kinds.Kind.ENUM: {
              const enumType = (0, _definition.getNamedType)(this.getInputType());
              let enumValue;
              if ((0, _definition.isEnumType)(enumType)) {
                enumValue = enumType.getValue(node.value);
              }
              this._enumValue = enumValue;
              break;
            }
            default:
          }
        }
        leave(node) {
          switch (node.kind) {
            case _kinds.Kind.SELECTION_SET:
              this._parentTypeStack.pop();
              break;
            case _kinds.Kind.FIELD:
              this._fieldDefStack.pop();
              this._typeStack.pop();
              break;
            case _kinds.Kind.DIRECTIVE:
              this._directive = null;
              break;
            case _kinds.Kind.OPERATION_DEFINITION:
            case _kinds.Kind.INLINE_FRAGMENT:
            case _kinds.Kind.FRAGMENT_DEFINITION:
              this._typeStack.pop();
              break;
            case _kinds.Kind.VARIABLE_DEFINITION:
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.ARGUMENT:
              this._argument = null;
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.LIST:
            case _kinds.Kind.OBJECT_FIELD:
              this._defaultValueStack.pop();
              this._inputTypeStack.pop();
              break;
            case _kinds.Kind.ENUM:
              this._enumValue = null;
              break;
            default:
          }
        }
      };
      exports2.TypeInfo = TypeInfo2;
      function getFieldDef3(schema, parentType, fieldNode) {
        const name2 = fieldNode.name.value;
        if (name2 === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.SchemaMetaFieldDef;
        }
        if (name2 === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
          return _introspection.TypeMetaFieldDef;
        }
        if (name2 === _introspection.TypeNameMetaFieldDef.name && (0, _definition.isCompositeType)(parentType)) {
          return _introspection.TypeNameMetaFieldDef;
        }
        if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
          return parentType.getFields()[name2];
        }
      }
      function visitWithTypeInfo2(typeInfo, visitor) {
        return {
          enter(...args) {
            const node = args[0];
            typeInfo.enter(node);
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).enter;
            if (fn) {
              const result = fn.apply(visitor, args);
              if (result !== void 0) {
                typeInfo.leave(node);
                if ((0, _ast.isNode)(result)) {
                  typeInfo.enter(result);
                }
              }
              return result;
            }
          },
          leave(...args) {
            const node = args[0];
            const fn = (0, _visitor.getEnterLeaveForKind)(visitor, node.kind).leave;
            let result;
            if (fn) {
              result = fn.apply(visitor, args);
            }
            typeInfo.leave(node);
            return result;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/predicates.js
  var require_predicates = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/language/predicates.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.isConstValueNode = isConstValueNode2;
      exports2.isDefinitionNode = isDefinitionNode2;
      exports2.isExecutableDefinitionNode = isExecutableDefinitionNode2;
      exports2.isSelectionNode = isSelectionNode2;
      exports2.isTypeDefinitionNode = isTypeDefinitionNode2;
      exports2.isTypeExtensionNode = isTypeExtensionNode2;
      exports2.isTypeNode = isTypeNode2;
      exports2.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode2;
      exports2.isTypeSystemExtensionNode = isTypeSystemExtensionNode2;
      exports2.isValueNode = isValueNode2;
      var _kinds = require_kinds();
      function isDefinitionNode2(node) {
        return isExecutableDefinitionNode2(node) || isTypeSystemDefinitionNode2(node) || isTypeSystemExtensionNode2(node);
      }
      function isExecutableDefinitionNode2(node) {
        return node.kind === _kinds.Kind.OPERATION_DEFINITION || node.kind === _kinds.Kind.FRAGMENT_DEFINITION;
      }
      function isSelectionNode2(node) {
        return node.kind === _kinds.Kind.FIELD || node.kind === _kinds.Kind.FRAGMENT_SPREAD || node.kind === _kinds.Kind.INLINE_FRAGMENT;
      }
      function isValueNode2(node) {
        return node.kind === _kinds.Kind.VARIABLE || node.kind === _kinds.Kind.INT || node.kind === _kinds.Kind.FLOAT || node.kind === _kinds.Kind.STRING || node.kind === _kinds.Kind.BOOLEAN || node.kind === _kinds.Kind.NULL || node.kind === _kinds.Kind.ENUM || node.kind === _kinds.Kind.LIST || node.kind === _kinds.Kind.OBJECT;
      }
      function isConstValueNode2(node) {
        return isValueNode2(node) && (node.kind === _kinds.Kind.LIST ? node.values.some(isConstValueNode2) : node.kind === _kinds.Kind.OBJECT ? node.fields.some((field) => isConstValueNode2(field.value)) : node.kind !== _kinds.Kind.VARIABLE);
      }
      function isTypeNode2(node) {
        return node.kind === _kinds.Kind.NAMED_TYPE || node.kind === _kinds.Kind.LIST_TYPE || node.kind === _kinds.Kind.NON_NULL_TYPE;
      }
      function isTypeSystemDefinitionNode2(node) {
        return node.kind === _kinds.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode2(node) || node.kind === _kinds.Kind.DIRECTIVE_DEFINITION;
      }
      function isTypeDefinitionNode2(node) {
        return node.kind === _kinds.Kind.SCALAR_TYPE_DEFINITION || node.kind === _kinds.Kind.OBJECT_TYPE_DEFINITION || node.kind === _kinds.Kind.INTERFACE_TYPE_DEFINITION || node.kind === _kinds.Kind.UNION_TYPE_DEFINITION || node.kind === _kinds.Kind.ENUM_TYPE_DEFINITION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION;
      }
      function isTypeSystemExtensionNode2(node) {
        return node.kind === _kinds.Kind.SCHEMA_EXTENSION || isTypeExtensionNode2(node);
      }
      function isTypeExtensionNode2(node) {
        return node.kind === _kinds.Kind.SCALAR_TYPE_EXTENSION || node.kind === _kinds.Kind.OBJECT_TYPE_EXTENSION || node.kind === _kinds.Kind.INTERFACE_TYPE_EXTENSION || node.kind === _kinds.Kind.UNION_TYPE_EXTENSION || node.kind === _kinds.Kind.ENUM_TYPE_EXTENSION || node.kind === _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js
  var require_ExecutableDefinitionsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.ExecutableDefinitionsRule = ExecutableDefinitionsRule2;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      function ExecutableDefinitionsRule2(context) {
        return {
          Document(node) {
            for (const definition of node.definitions) {
              if (!(0, _predicates.isExecutableDefinitionNode)(definition)) {
                const defName = definition.kind === _kinds.Kind.SCHEMA_DEFINITION || definition.kind === _kinds.Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `The ${defName} definition is not executable.`,
                    {
                      nodes: definition
                    }
                  )
                );
              }
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js
  var require_FieldsOnCorrectTypeRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule2;
      var _didYouMean = require_didYouMean();
      var _naturalCompare = require_naturalCompare();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function FieldsOnCorrectTypeRule2(context) {
        return {
          Field(node) {
            const type = context.getParentType();
            if (type) {
              const fieldDef = context.getFieldDef();
              if (!fieldDef) {
                const schema = context.getSchema();
                const fieldName = node.name.value;
                let suggestion = (0, _didYouMean.didYouMean)(
                  "to use an inline fragment on",
                  getSuggestedTypeNames2(schema, type, fieldName)
                );
                if (suggestion === "") {
                  suggestion = (0, _didYouMean.didYouMean)(
                    getSuggestedFieldNames2(type, fieldName)
                  );
                }
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          }
        };
      }
      function getSuggestedTypeNames2(schema, type, fieldName) {
        if (!(0, _definition.isAbstractType)(type)) {
          return [];
        }
        const suggestedTypes = /* @__PURE__ */ new Set();
        const usageCount = /* @__PURE__ */ Object.create(null);
        for (const possibleType of schema.getPossibleTypes(type)) {
          if (!possibleType.getFields()[fieldName]) {
            continue;
          }
          suggestedTypes.add(possibleType);
          usageCount[possibleType.name] = 1;
          for (const possibleInterface of possibleType.getInterfaces()) {
            var _usageCount$possibleI;
            if (!possibleInterface.getFields()[fieldName]) {
              continue;
            }
            suggestedTypes.add(possibleInterface);
            usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
          }
        }
        return [...suggestedTypes].sort((typeA, typeB) => {
          const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
          if (usageCountDiff !== 0) {
            return usageCountDiff;
          }
          if ((0, _definition.isInterfaceType)(typeA) && schema.isSubType(typeA, typeB)) {
            return -1;
          }
          if ((0, _definition.isInterfaceType)(typeB) && schema.isSubType(typeB, typeA)) {
            return 1;
          }
          return (0, _naturalCompare.naturalCompare)(typeA.name, typeB.name);
        }).map((x) => x.name);
      }
      function getSuggestedFieldNames2(type, fieldName) {
        if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type)) {
          const possibleFieldNames = Object.keys(type.getFields());
          return (0, _suggestionList.suggestionList)(fieldName, possibleFieldNames);
        }
        return [];
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js
  var require_FragmentsOnCompositeTypesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule2;
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      var _typeFromAST = require_typeFromAST();
      function FragmentsOnCompositeTypesRule2(context) {
        return {
          InlineFragment(node) {
            const typeCondition = node.typeCondition;
            if (typeCondition) {
              const type = (0, _typeFromAST.typeFromAST)(
                context.getSchema(),
                typeCondition
              );
              if (type && !(0, _definition.isCompositeType)(type)) {
                const typeStr = (0, _printer.print)(typeCondition);
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Fragment cannot condition on non composite type "${typeStr}".`,
                    {
                      nodes: typeCondition
                    }
                  )
                );
              }
            }
          },
          FragmentDefinition(node) {
            const type = (0, _typeFromAST.typeFromAST)(
              context.getSchema(),
              node.typeCondition
            );
            if (type && !(0, _definition.isCompositeType)(type)) {
              const typeStr = (0, _printer.print)(node.typeCondition);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
                  {
                    nodes: node.typeCondition
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js
  var require_KnownArgumentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownArgumentNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule2;
      exports2.KnownArgumentNamesRule = KnownArgumentNamesRule2;
      var _didYouMean = require_didYouMean();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _directives = require_directives();
      function KnownArgumentNamesRule2(context) {
        return __spreadProps(__spreadValues({}, KnownArgumentNamesOnDirectivesRule2(context)), {
          Argument(argNode) {
            const argDef = context.getArgument();
            const fieldDef = context.getFieldDef();
            const parentType = context.getParentType();
            if (!argDef && fieldDef && parentType) {
              const argName = argNode.name.value;
              const knownArgsNames = fieldDef.args.map((arg) => arg.name);
              const suggestions = (0, _suggestionList.suggestionList)(
                argName,
                knownArgsNames
              );
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                  {
                    nodes: argNode
                  }
                )
              );
            }
          }
        });
      }
      function KnownArgumentNamesOnDirectivesRule2(context) {
        const directiveArgs = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
          }
        }
        return {
          Directive(directiveNode) {
            const directiveName = directiveNode.name.value;
            const knownArgs = directiveArgs[directiveName];
            if (directiveNode.arguments && knownArgs) {
              for (const argNode of directiveNode.arguments) {
                const argName = argNode.name.value;
                if (!knownArgs.includes(argName)) {
                  const suggestions = (0, _suggestionList.suggestionList)(
                    argName,
                    knownArgs
                  );
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Unknown argument "${argName}" on directive "@${directiveName}".` + (0, _didYouMean.didYouMean)(suggestions),
                      {
                        nodes: argNode
                      }
                    )
                  );
                }
              }
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownDirectivesRule.js
  var require_KnownDirectivesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownDirectivesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.KnownDirectivesRule = KnownDirectivesRule2;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _GraphQLError = require_GraphQLError();
      var _ast = require_ast2();
      var _directiveLocation = require_directiveLocation();
      var _kinds = require_kinds();
      var _directives = require_directives();
      function KnownDirectivesRule2(context) {
        const locationsMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          locationsMap[directive.name] = directive.locations;
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            locationsMap[def.name.value] = def.locations.map((name2) => name2.value);
          }
        }
        return {
          Directive(node, _key, _parent, _path, ancestors) {
            const name2 = node.name.value;
            const locations = locationsMap[name2];
            if (!locations) {
              context.reportError(
                new _GraphQLError.GraphQLError(`Unknown directive "@${name2}".`, {
                  nodes: node
                })
              );
              return;
            }
            const candidateLocation = getDirectiveLocationForASTPath2(ancestors);
            if (candidateLocation && !locations.includes(candidateLocation)) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Directive "@${name2}" may not be used on ${candidateLocation}.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
      function getDirectiveLocationForASTPath2(ancestors) {
        const appliedTo = ancestors[ancestors.length - 1];
        "kind" in appliedTo || (0, _invariant.invariant)(false);
        switch (appliedTo.kind) {
          case _kinds.Kind.OPERATION_DEFINITION:
            return getDirectiveLocationForOperation2(appliedTo.operation);
          case _kinds.Kind.FIELD:
            return _directiveLocation.DirectiveLocation.FIELD;
          case _kinds.Kind.FRAGMENT_SPREAD:
            return _directiveLocation.DirectiveLocation.FRAGMENT_SPREAD;
          case _kinds.Kind.INLINE_FRAGMENT:
            return _directiveLocation.DirectiveLocation.INLINE_FRAGMENT;
          case _kinds.Kind.FRAGMENT_DEFINITION:
            return _directiveLocation.DirectiveLocation.FRAGMENT_DEFINITION;
          case _kinds.Kind.VARIABLE_DEFINITION:
            return _directiveLocation.DirectiveLocation.VARIABLE_DEFINITION;
          case _kinds.Kind.SCHEMA_DEFINITION:
          case _kinds.Kind.SCHEMA_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCHEMA;
          case _kinds.Kind.SCALAR_TYPE_DEFINITION:
          case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.SCALAR;
          case _kinds.Kind.OBJECT_TYPE_DEFINITION:
          case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.OBJECT;
          case _kinds.Kind.FIELD_DEFINITION:
            return _directiveLocation.DirectiveLocation.FIELD_DEFINITION;
          case _kinds.Kind.INTERFACE_TYPE_DEFINITION:
          case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INTERFACE;
          case _kinds.Kind.UNION_TYPE_DEFINITION:
          case _kinds.Kind.UNION_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.UNION;
          case _kinds.Kind.ENUM_TYPE_DEFINITION:
          case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.ENUM;
          case _kinds.Kind.ENUM_VALUE_DEFINITION:
            return _directiveLocation.DirectiveLocation.ENUM_VALUE;
          case _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return _directiveLocation.DirectiveLocation.INPUT_OBJECT;
          case _kinds.Kind.INPUT_VALUE_DEFINITION: {
            const parentNode = ancestors[ancestors.length - 3];
            "kind" in parentNode || (0, _invariant.invariant)(false);
            return parentNode.kind === _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION ? _directiveLocation.DirectiveLocation.INPUT_FIELD_DEFINITION : _directiveLocation.DirectiveLocation.ARGUMENT_DEFINITION;
          }
          default:
            (0, _invariant.invariant)(
              false,
              "Unexpected kind: " + (0, _inspect.inspect)(appliedTo.kind)
            );
        }
      }
      function getDirectiveLocationForOperation2(operation) {
        switch (operation) {
          case _ast.OperationTypeNode.QUERY:
            return _directiveLocation.DirectiveLocation.QUERY;
          case _ast.OperationTypeNode.MUTATION:
            return _directiveLocation.DirectiveLocation.MUTATION;
          case _ast.OperationTypeNode.SUBSCRIPTION:
            return _directiveLocation.DirectiveLocation.SUBSCRIPTION;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js
  var require_KnownFragmentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownFragmentNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.KnownFragmentNamesRule = KnownFragmentNamesRule2;
      var _GraphQLError = require_GraphQLError();
      function KnownFragmentNamesRule2(context) {
        return {
          FragmentSpread(node) {
            const fragmentName = node.name.value;
            const fragment = context.getFragment(fragmentName);
            if (!fragment) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Unknown fragment "${fragmentName}".`,
                  {
                    nodes: node.name
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownTypeNamesRule.js
  var require_KnownTypeNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/KnownTypeNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.KnownTypeNamesRule = KnownTypeNamesRule2;
      var _didYouMean = require_didYouMean();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _predicates = require_predicates();
      var _introspection = require_introspection();
      var _scalars = require_scalars();
      function KnownTypeNamesRule2(context) {
        const schema = context.getSchema();
        const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const definedTypes = /* @__PURE__ */ Object.create(null);
        for (const def of context.getDocument().definitions) {
          if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = true;
          }
        }
        const typeNames = [
          ...Object.keys(existingTypesMap),
          ...Object.keys(definedTypes)
        ];
        return {
          NamedType(node, _1, parent, _2, ancestors) {
            const typeName = node.name.value;
            if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
              var _ancestors$;
              const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
              const isSDL = definitionNode != null && isSDLNode2(definitionNode);
              if (isSDL && standardTypeNames2.includes(typeName)) {
                return;
              }
              const suggestedTypes = (0, _suggestionList.suggestionList)(
                typeName,
                isSDL ? standardTypeNames2.concat(typeNames) : typeNames
              );
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Unknown type "${typeName}".` + (0, _didYouMean.didYouMean)(suggestedTypes),
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
      var standardTypeNames2 = [
        ..._scalars.specifiedScalarTypes,
        ..._introspection.introspectionTypes
      ].map((type) => type.name);
      function isSDLNode2(value) {
        return "kind" in value && ((0, _predicates.isTypeSystemDefinitionNode)(value) || (0, _predicates.isTypeSystemExtensionNode)(value));
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js
  var require_LoneAnonymousOperationRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.LoneAnonymousOperationRule = LoneAnonymousOperationRule2;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      function LoneAnonymousOperationRule2(context) {
        let operationCount = 0;
        return {
          Document(node) {
            operationCount = node.definitions.filter(
              (definition) => definition.kind === _kinds.Kind.OPERATION_DEFINITION
            ).length;
          },
          OperationDefinition(node) {
            if (!node.name && operationCount > 1) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  "This anonymous operation must be the only defined operation.",
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js
  var require_LoneSchemaDefinitionRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule2;
      var _GraphQLError = require_GraphQLError();
      function LoneSchemaDefinitionRule2(context) {
        var _ref, _ref2, _oldSchema$astNode;
        const oldSchema = context.getSchema();
        const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
        let schemaDefinitionsCount = 0;
        return {
          SchemaDefinition(node) {
            if (alreadyDefined) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  "Cannot define a new schema within a schema extension.",
                  {
                    nodes: node
                  }
                )
              );
              return;
            }
            if (schemaDefinitionsCount > 0) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  "Must provide only one schema definition.",
                  {
                    nodes: node
                  }
                )
              );
            }
            ++schemaDefinitionsCount;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js
  var require_NoFragmentCyclesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoFragmentCyclesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.NoFragmentCyclesRule = NoFragmentCyclesRule2;
      var _GraphQLError = require_GraphQLError();
      function NoFragmentCyclesRule2(context) {
        const visitedFrags = /* @__PURE__ */ Object.create(null);
        const spreadPath = [];
        const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: () => false,
          FragmentDefinition(node) {
            detectCycleRecursive(node);
            return false;
          }
        };
        function detectCycleRecursive(fragment) {
          if (visitedFrags[fragment.name.value]) {
            return;
          }
          const fragmentName = fragment.name.value;
          visitedFrags[fragmentName] = true;
          const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
          if (spreadNodes.length === 0) {
            return;
          }
          spreadPathIndexByName[fragmentName] = spreadPath.length;
          for (const spreadNode of spreadNodes) {
            const spreadName = spreadNode.name.value;
            const cycleIndex = spreadPathIndexByName[spreadName];
            spreadPath.push(spreadNode);
            if (cycleIndex === void 0) {
              const spreadFragment = context.getFragment(spreadName);
              if (spreadFragment) {
                detectCycleRecursive(spreadFragment);
              }
            } else {
              const cyclePath = spreadPath.slice(cycleIndex);
              const viaPath = cyclePath.slice(0, -1).map((s2) => '"' + s2.name.value + '"').join(", ");
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
                  {
                    nodes: cyclePath
                  }
                )
              );
            }
            spreadPath.pop();
          }
          spreadPathIndexByName[fragmentName] = void 0;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js
  var require_NoUndefinedVariablesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.NoUndefinedVariablesRule = NoUndefinedVariablesRule2;
      var _GraphQLError = require_GraphQLError();
      function NoUndefinedVariablesRule2(context) {
        let variableNameDefined = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: {
            enter() {
              variableNameDefined = /* @__PURE__ */ Object.create(null);
            },
            leave(operation) {
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node } of usages) {
                const varName = node.name.value;
                if (variableNameDefined[varName] !== true) {
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                      {
                        nodes: [node, operation]
                      }
                    )
                  );
                }
              }
            }
          },
          VariableDefinition(node) {
            variableNameDefined[node.variable.name.value] = true;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js
  var require_NoUnusedFragmentsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.NoUnusedFragmentsRule = NoUnusedFragmentsRule2;
      var _GraphQLError = require_GraphQLError();
      function NoUnusedFragmentsRule2(context) {
        const operationDefs = [];
        const fragmentDefs = [];
        return {
          OperationDefinition(node) {
            operationDefs.push(node);
            return false;
          },
          FragmentDefinition(node) {
            fragmentDefs.push(node);
            return false;
          },
          Document: {
            leave() {
              const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
              for (const operation of operationDefs) {
                for (const fragment of context.getRecursivelyReferencedFragments(
                  operation
                )) {
                  fragmentNameUsed[fragment.name.value] = true;
                }
              }
              for (const fragmentDef of fragmentDefs) {
                const fragName = fragmentDef.name.value;
                if (fragmentNameUsed[fragName] !== true) {
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Fragment "${fragName}" is never used.`,
                      {
                        nodes: fragmentDef
                      }
                    )
                  );
                }
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js
  var require_NoUnusedVariablesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/NoUnusedVariablesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.NoUnusedVariablesRule = NoUnusedVariablesRule2;
      var _GraphQLError = require_GraphQLError();
      function NoUnusedVariablesRule2(context) {
        let variableDefs = [];
        return {
          OperationDefinition: {
            enter() {
              variableDefs = [];
            },
            leave(operation) {
              const variableNameUsed = /* @__PURE__ */ Object.create(null);
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node } of usages) {
                variableNameUsed[node.name.value] = true;
              }
              for (const variableDef of variableDefs) {
                const variableName = variableDef.variable.name.value;
                if (variableNameUsed[variableName] !== true) {
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                      {
                        nodes: variableDef
                      }
                    )
                  );
                }
              }
            }
          },
          VariableDefinition(def) {
            variableDefs.push(def);
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/sortValueNode.js
  var require_sortValueNode = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/sortValueNode.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.sortValueNode = sortValueNode2;
      var _naturalCompare = require_naturalCompare();
      var _kinds = require_kinds();
      function sortValueNode2(valueNode) {
        switch (valueNode.kind) {
          case _kinds.Kind.OBJECT:
            return __spreadProps(__spreadValues({}, valueNode), { fields: sortFields2(valueNode.fields) });
          case _kinds.Kind.LIST:
            return __spreadProps(__spreadValues({}, valueNode), { values: valueNode.values.map(sortValueNode2) });
          case _kinds.Kind.INT:
          case _kinds.Kind.FLOAT:
          case _kinds.Kind.STRING:
          case _kinds.Kind.BOOLEAN:
          case _kinds.Kind.NULL:
          case _kinds.Kind.ENUM:
          case _kinds.Kind.VARIABLE:
            return valueNode;
        }
      }
      function sortFields2(fields) {
        return fields.map((fieldNode) => __spreadProps(__spreadValues({}, fieldNode), {
          value: sortValueNode2(fieldNode.value)
        })).sort(
          (fieldA, fieldB) => (0, _naturalCompare.naturalCompare)(fieldA.name.value, fieldB.name.value)
        );
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js
  var require_OverlappingFieldsCanBeMergedRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule2;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _sortValueNode = require_sortValueNode();
      var _typeFromAST = require_typeFromAST();
      function reasonMessage2(reason) {
        if (Array.isArray(reason)) {
          return reason.map(
            ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage2(subReason)
          ).join(" and ");
        }
        return reason;
      }
      function OverlappingFieldsCanBeMergedRule2(context) {
        const comparedFragmentPairs = new PairSet2();
        const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
        return {
          SelectionSet(selectionSet) {
            const conflicts = findConflictsWithinSelectionSet2(
              context,
              cachedFieldsAndFragmentNames,
              comparedFragmentPairs,
              context.getParentType(),
              selectionSet
            );
            for (const [[responseName, reason], fields1, fields2] of conflicts) {
              const reasonMsg = reasonMessage2(reason);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
                  {
                    nodes: fields1.concat(fields2)
                  }
                )
              );
            }
          }
        };
      }
      function findConflictsWithinSelectionSet2(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
        const conflicts = [];
        const [fieldMap, fragmentNames] = getFieldsAndFragmentNames2(
          context,
          cachedFieldsAndFragmentNames,
          parentType,
          selectionSet
        );
        collectConflictsWithin2(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          fieldMap
        );
        if (fragmentNames.length !== 0) {
          for (let i2 = 0; i2 < fragmentNames.length; i2++) {
            collectConflictsBetweenFieldsAndFragment2(
              context,
              conflicts,
              cachedFieldsAndFragmentNames,
              comparedFragmentPairs,
              false,
              fieldMap,
              fragmentNames[i2]
            );
            for (let j = i2 + 1; j < fragmentNames.length; j++) {
              collectConflictsBetweenFragments2(
                context,
                conflicts,
                cachedFieldsAndFragmentNames,
                comparedFragmentPairs,
                false,
                fragmentNames[i2],
                fragmentNames[j]
              );
            }
          }
        }
        return conflicts;
      }
      function collectConflictsBetweenFieldsAndFragment2(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
        const fragment = context.getFragment(fragmentName);
        if (!fragment) {
          return;
        }
        const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames2(
          context,
          cachedFieldsAndFragmentNames,
          fragment
        );
        if (fieldMap === fieldMap2) {
          return;
        }
        collectConflictsBetween2(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap,
          fieldMap2
        );
        for (const referencedFragmentName of referencedFragmentNames) {
          if (comparedFragmentPairs.has(
            referencedFragmentName,
            fragmentName,
            areMutuallyExclusive
          )) {
            continue;
          }
          comparedFragmentPairs.add(
            referencedFragmentName,
            fragmentName,
            areMutuallyExclusive
          );
          collectConflictsBetweenFieldsAndFragment2(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fieldMap,
            referencedFragmentName
          );
        }
      }
      function collectConflictsBetweenFragments2(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
        if (fragmentName1 === fragmentName2) {
          return;
        }
        if (comparedFragmentPairs.has(
          fragmentName1,
          fragmentName2,
          areMutuallyExclusive
        )) {
          return;
        }
        comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
        const fragment1 = context.getFragment(fragmentName1);
        const fragment2 = context.getFragment(fragmentName2);
        if (!fragment1 || !fragment2) {
          return;
        }
        const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames2(
          context,
          cachedFieldsAndFragmentNames,
          fragment1
        );
        const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames2(
          context,
          cachedFieldsAndFragmentNames,
          fragment2
        );
        collectConflictsBetween2(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap1,
          fieldMap2
        );
        for (const referencedFragmentName2 of referencedFragmentNames2) {
          collectConflictsBetweenFragments2(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fragmentName1,
            referencedFragmentName2
          );
        }
        for (const referencedFragmentName1 of referencedFragmentNames1) {
          collectConflictsBetweenFragments2(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            referencedFragmentName1,
            fragmentName2
          );
        }
      }
      function findConflictsBetweenSubSelectionSets2(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
        const conflicts = [];
        const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames2(
          context,
          cachedFieldsAndFragmentNames,
          parentType1,
          selectionSet1
        );
        const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames2(
          context,
          cachedFieldsAndFragmentNames,
          parentType2,
          selectionSet2
        );
        collectConflictsBetween2(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          areMutuallyExclusive,
          fieldMap1,
          fieldMap2
        );
        for (const fragmentName2 of fragmentNames2) {
          collectConflictsBetweenFieldsAndFragment2(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fieldMap1,
            fragmentName2
          );
        }
        for (const fragmentName1 of fragmentNames1) {
          collectConflictsBetweenFieldsAndFragment2(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            fieldMap2,
            fragmentName1
          );
        }
        for (const fragmentName1 of fragmentNames1) {
          for (const fragmentName2 of fragmentNames2) {
            collectConflictsBetweenFragments2(
              context,
              conflicts,
              cachedFieldsAndFragmentNames,
              comparedFragmentPairs,
              areMutuallyExclusive,
              fragmentName1,
              fragmentName2
            );
          }
        }
        return conflicts;
      }
      function collectConflictsWithin2(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
        for (const [responseName, fields] of Object.entries(fieldMap)) {
          if (fields.length > 1) {
            for (let i2 = 0; i2 < fields.length; i2++) {
              for (let j = i2 + 1; j < fields.length; j++) {
                const conflict = findConflict2(
                  context,
                  cachedFieldsAndFragmentNames,
                  comparedFragmentPairs,
                  false,
                  // within one collection is never mutually exclusive
                  responseName,
                  fields[i2],
                  fields[j]
                );
                if (conflict) {
                  conflicts.push(conflict);
                }
              }
            }
          }
        }
      }
      function collectConflictsBetween2(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
        for (const [responseName, fields1] of Object.entries(fieldMap1)) {
          const fields2 = fieldMap2[responseName];
          if (fields2) {
            for (const field1 of fields1) {
              for (const field2 of fields2) {
                const conflict = findConflict2(
                  context,
                  cachedFieldsAndFragmentNames,
                  comparedFragmentPairs,
                  parentFieldsAreMutuallyExclusive,
                  responseName,
                  field1,
                  field2
                );
                if (conflict) {
                  conflicts.push(conflict);
                }
              }
            }
          }
        }
      }
      function findConflict2(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
        const [parentType1, node1, def1] = field1;
        const [parentType2, node2, def2] = field2;
        const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && (0, _definition.isObjectType)(parentType1) && (0, _definition.isObjectType)(parentType2);
        if (!areMutuallyExclusive) {
          const name1 = node1.name.value;
          const name2 = node2.name.value;
          if (name1 !== name2) {
            return [
              [responseName, `"${name1}" and "${name2}" are different fields`],
              [node1],
              [node2]
            ];
          }
          if (stringifyArguments2(node1) !== stringifyArguments2(node2)) {
            return [
              [responseName, "they have differing arguments"],
              [node1],
              [node2]
            ];
          }
        }
        const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
        const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
        if (type1 && type2 && doTypesConflict2(type1, type2)) {
          return [
            [
              responseName,
              `they return conflicting types "${(0, _inspect.inspect)(
                type1
              )}" and "${(0, _inspect.inspect)(type2)}"`
            ],
            [node1],
            [node2]
          ];
        }
        const selectionSet1 = node1.selectionSet;
        const selectionSet2 = node2.selectionSet;
        if (selectionSet1 && selectionSet2) {
          const conflicts = findConflictsBetweenSubSelectionSets2(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            areMutuallyExclusive,
            (0, _definition.getNamedType)(type1),
            selectionSet1,
            (0, _definition.getNamedType)(type2),
            selectionSet2
          );
          return subfieldConflicts2(conflicts, responseName, node1, node2);
        }
      }
      function stringifyArguments2(fieldNode) {
        var _fieldNode$arguments;
        const args = (
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : []
        );
        const inputObjectWithArgs = {
          kind: _kinds.Kind.OBJECT,
          fields: args.map((argNode) => ({
            kind: _kinds.Kind.OBJECT_FIELD,
            name: argNode.name,
            value: argNode.value
          }))
        };
        return (0, _printer.print)(
          (0, _sortValueNode.sortValueNode)(inputObjectWithArgs)
        );
      }
      function doTypesConflict2(type1, type2) {
        if ((0, _definition.isListType)(type1)) {
          return (0, _definition.isListType)(type2) ? doTypesConflict2(type1.ofType, type2.ofType) : true;
        }
        if ((0, _definition.isListType)(type2)) {
          return true;
        }
        if ((0, _definition.isNonNullType)(type1)) {
          return (0, _definition.isNonNullType)(type2) ? doTypesConflict2(type1.ofType, type2.ofType) : true;
        }
        if ((0, _definition.isNonNullType)(type2)) {
          return true;
        }
        if ((0, _definition.isLeafType)(type1) || (0, _definition.isLeafType)(type2)) {
          return type1 !== type2;
        }
        return false;
      }
      function getFieldsAndFragmentNames2(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
        const cached = cachedFieldsAndFragmentNames.get(selectionSet);
        if (cached) {
          return cached;
        }
        const nodeAndDefs = /* @__PURE__ */ Object.create(null);
        const fragmentNames = /* @__PURE__ */ Object.create(null);
        _collectFieldsAndFragmentNames2(
          context,
          parentType,
          selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        const result = [nodeAndDefs, Object.keys(fragmentNames)];
        cachedFieldsAndFragmentNames.set(selectionSet, result);
        return result;
      }
      function getReferencedFieldsAndFragmentNames2(context, cachedFieldsAndFragmentNames, fragment) {
        const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
        if (cached) {
          return cached;
        }
        const fragmentType = (0, _typeFromAST.typeFromAST)(
          context.getSchema(),
          fragment.typeCondition
        );
        return getFieldsAndFragmentNames2(
          context,
          cachedFieldsAndFragmentNames,
          fragmentType,
          fragment.selectionSet
        );
      }
      function _collectFieldsAndFragmentNames2(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
        for (const selection of selectionSet.selections) {
          switch (selection.kind) {
            case _kinds.Kind.FIELD: {
              const fieldName = selection.name.value;
              let fieldDef;
              if ((0, _definition.isObjectType)(parentType) || (0, _definition.isInterfaceType)(parentType)) {
                fieldDef = parentType.getFields()[fieldName];
              }
              const responseName = selection.alias ? selection.alias.value : fieldName;
              if (!nodeAndDefs[responseName]) {
                nodeAndDefs[responseName] = [];
              }
              nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
              break;
            }
            case _kinds.Kind.FRAGMENT_SPREAD:
              fragmentNames[selection.name.value] = true;
              break;
            case _kinds.Kind.INLINE_FRAGMENT: {
              const typeCondition = selection.typeCondition;
              const inlineFragmentType = typeCondition ? (0, _typeFromAST.typeFromAST)(context.getSchema(), typeCondition) : parentType;
              _collectFieldsAndFragmentNames2(
                context,
                inlineFragmentType,
                selection.selectionSet,
                nodeAndDefs,
                fragmentNames
              );
              break;
            }
          }
        }
      }
      function subfieldConflicts2(conflicts, responseName, node1, node2) {
        if (conflicts.length > 0) {
          return [
            [responseName, conflicts.map(([reason]) => reason)],
            [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
            [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
          ];
        }
      }
      var PairSet2 = class {
        constructor() {
          this._data = /* @__PURE__ */ new Map();
        }
        has(a2, b, areMutuallyExclusive) {
          var _this$_data$get;
          const [key1, key2] = a2 < b ? [a2, b] : [b, a2];
          const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
          if (result === void 0) {
            return false;
          }
          return areMutuallyExclusive ? true : areMutuallyExclusive === result;
        }
        add(a2, b, areMutuallyExclusive) {
          const [key1, key2] = a2 < b ? [a2, b] : [b, a2];
          const map = this._data.get(key1);
          if (map === void 0) {
            this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
          } else {
            map.set(key2, areMutuallyExclusive);
          }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js
  var require_PossibleFragmentSpreadsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule2;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      var _typeComparators = require_typeComparators();
      var _typeFromAST = require_typeFromAST();
      function PossibleFragmentSpreadsRule2(context) {
        return {
          InlineFragment(node) {
            const fragType = context.getType();
            const parentType = context.getParentType();
            if ((0, _definition.isCompositeType)(fragType) && (0, _definition.isCompositeType)(parentType) && !(0, _typeComparators.doTypesOverlap)(
              context.getSchema(),
              fragType,
              parentType
            )) {
              const parentTypeStr = (0, _inspect.inspect)(parentType);
              const fragTypeStr = (0, _inspect.inspect)(fragType);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                  {
                    nodes: node
                  }
                )
              );
            }
          },
          FragmentSpread(node) {
            const fragName = node.name.value;
            const fragType = getFragmentType2(context, fragName);
            const parentType = context.getParentType();
            if (fragType && parentType && !(0, _typeComparators.doTypesOverlap)(
              context.getSchema(),
              fragType,
              parentType
            )) {
              const parentTypeStr = (0, _inspect.inspect)(parentType);
              const fragTypeStr = (0, _inspect.inspect)(fragType);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
                  {
                    nodes: node
                  }
                )
              );
            }
          }
        };
      }
      function getFragmentType2(context, name2) {
        const frag = context.getFragment(name2);
        if (frag) {
          const type = (0, _typeFromAST.typeFromAST)(
            context.getSchema(),
            frag.typeCondition
          );
          if ((0, _definition.isCompositeType)(type)) {
            return type;
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js
  var require_PossibleTypeExtensionsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule2;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _definition = require_definition();
      function PossibleTypeExtensionsRule2(context) {
        const schema = context.getSchema();
        const definedTypes = /* @__PURE__ */ Object.create(null);
        for (const def of context.getDocument().definitions) {
          if ((0, _predicates.isTypeDefinitionNode)(def)) {
            definedTypes[def.name.value] = def;
          }
        }
        return {
          ScalarTypeExtension: checkExtension,
          ObjectTypeExtension: checkExtension,
          InterfaceTypeExtension: checkExtension,
          UnionTypeExtension: checkExtension,
          EnumTypeExtension: checkExtension,
          InputObjectTypeExtension: checkExtension
        };
        function checkExtension(node) {
          const typeName = node.name.value;
          const defNode = definedTypes[typeName];
          const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
          let expectedKind;
          if (defNode) {
            expectedKind = defKindToExtKind2[defNode.kind];
          } else if (existingType) {
            expectedKind = typeToExtKind2(existingType);
          }
          if (expectedKind) {
            if (expectedKind !== node.kind) {
              const kindStr = extensionKindToTypeName2(node.kind);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Cannot extend non-${kindStr} type "${typeName}".`,
                  {
                    nodes: defNode ? [defNode, node] : node
                  }
                )
              );
            }
          } else {
            const allTypeNames = Object.keys(__spreadValues(__spreadValues({}, definedTypes), schema === null || schema === void 0 ? void 0 : schema.getTypeMap()));
            const suggestedTypes = (0, _suggestionList.suggestionList)(
              typeName,
              allTypeNames
            );
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Cannot extend type "${typeName}" because it is not defined.` + (0, _didYouMean.didYouMean)(suggestedTypes),
                {
                  nodes: node.name
                }
              )
            );
          }
        }
      }
      var defKindToExtKind2 = {
        [_kinds.Kind.SCALAR_TYPE_DEFINITION]: _kinds.Kind.SCALAR_TYPE_EXTENSION,
        [_kinds.Kind.OBJECT_TYPE_DEFINITION]: _kinds.Kind.OBJECT_TYPE_EXTENSION,
        [_kinds.Kind.INTERFACE_TYPE_DEFINITION]: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
        [_kinds.Kind.UNION_TYPE_DEFINITION]: _kinds.Kind.UNION_TYPE_EXTENSION,
        [_kinds.Kind.ENUM_TYPE_DEFINITION]: _kinds.Kind.ENUM_TYPE_EXTENSION,
        [_kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION]: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION
      };
      function typeToExtKind2(type) {
        if ((0, _definition.isScalarType)(type)) {
          return _kinds.Kind.SCALAR_TYPE_EXTENSION;
        }
        if ((0, _definition.isObjectType)(type)) {
          return _kinds.Kind.OBJECT_TYPE_EXTENSION;
        }
        if ((0, _definition.isInterfaceType)(type)) {
          return _kinds.Kind.INTERFACE_TYPE_EXTENSION;
        }
        if ((0, _definition.isUnionType)(type)) {
          return _kinds.Kind.UNION_TYPE_EXTENSION;
        }
        if ((0, _definition.isEnumType)(type)) {
          return _kinds.Kind.ENUM_TYPE_EXTENSION;
        }
        if ((0, _definition.isInputObjectType)(type)) {
          return _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION;
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected type: " + (0, _inspect.inspect)(type)
        );
      }
      function extensionKindToTypeName2(kind) {
        switch (kind) {
          case _kinds.Kind.SCALAR_TYPE_EXTENSION:
            return "scalar";
          case _kinds.Kind.OBJECT_TYPE_EXTENSION:
            return "object";
          case _kinds.Kind.INTERFACE_TYPE_EXTENSION:
            return "interface";
          case _kinds.Kind.UNION_TYPE_EXTENSION:
            return "union";
          case _kinds.Kind.ENUM_TYPE_EXTENSION:
            return "enum";
          case _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            return "input object";
          default:
            (0, _invariant.invariant)(
              false,
              "Unexpected kind: " + (0, _inspect.inspect)(kind)
            );
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js
  var require_ProvidedRequiredArgumentsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule2;
      exports2.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule2;
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _directives = require_directives();
      function ProvidedRequiredArgumentsRule2(context) {
        return __spreadProps(__spreadValues({}, ProvidedRequiredArgumentsOnDirectivesRule2(context)), {
          Field: {
            // Validate on leave to allow for deeper errors to appear first.
            leave(fieldNode) {
              var _fieldNode$arguments;
              const fieldDef = context.getFieldDef();
              if (!fieldDef) {
                return false;
              }
              const providedArgs = new Set(
                // FIXME: https://github.com/graphql/graphql-js/issues/2203
                /* c8 ignore next */
                (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
              );
              for (const argDef of fieldDef.args) {
                if (!providedArgs.has(argDef.name) && (0, _definition.isRequiredArgument)(argDef)) {
                  const argTypeStr = (0, _inspect.inspect)(argDef.type);
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                      {
                        nodes: fieldNode
                      }
                    )
                  );
                }
              }
            }
          }
        });
      }
      function ProvidedRequiredArgumentsOnDirectivesRule2(context) {
        var _schema$getDirectives;
        const requiredArgsMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          requiredArgsMap[directive.name] = (0, _keyMap.keyMap)(
            directive.args.filter(_definition.isRequiredArgument),
            (arg) => arg.name
          );
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            var _def$arguments;
            const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
            requiredArgsMap[def.name.value] = (0, _keyMap.keyMap)(
              argNodes.filter(isRequiredArgumentNode2),
              (arg) => arg.name.value
            );
          }
        }
        return {
          Directive: {
            // Validate on leave to allow for deeper errors to appear first.
            leave(directiveNode) {
              const directiveName = directiveNode.name.value;
              const requiredArgs = requiredArgsMap[directiveName];
              if (requiredArgs) {
                var _directiveNode$argume;
                const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
                const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
                for (const [argName, argDef] of Object.entries(requiredArgs)) {
                  if (!argNodeMap.has(argName)) {
                    const argType = (0, _definition.isType)(argDef.type) ? (0, _inspect.inspect)(argDef.type) : (0, _printer.print)(argDef.type);
                    context.reportError(
                      new _GraphQLError.GraphQLError(
                        `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                        {
                          nodes: directiveNode
                        }
                      )
                    );
                  }
                }
              }
            }
          }
        };
      }
      function isRequiredArgumentNode2(arg) {
        return arg.type.kind === _kinds.Kind.NON_NULL_TYPE && arg.defaultValue == null;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ScalarLeafsRule.js
  var require_ScalarLeafsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ScalarLeafsRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.ScalarLeafsRule = ScalarLeafsRule2;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function ScalarLeafsRule2(context) {
        return {
          Field(node) {
            const type = context.getType();
            const selectionSet = node.selectionSet;
            if (type) {
              if ((0, _definition.isLeafType)((0, _definition.getNamedType)(type))) {
                if (selectionSet) {
                  const fieldName = node.name.value;
                  const typeStr = (0, _inspect.inspect)(type);
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                      {
                        nodes: selectionSet
                      }
                    )
                  );
                }
              } else if (!selectionSet) {
                const fieldName = node.name.value;
                const typeStr = (0, _inspect.inspect)(type);
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/printPathArray.js
  var require_printPathArray = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/printPathArray.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.printPathArray = printPathArray2;
      function printPathArray2(path) {
        return path.map(
          (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
        ).join("");
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/Path.js
  var require_Path = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/Path.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.addPath = addPath2;
      exports2.pathToArray = pathToArray2;
      function addPath2(prev, key, typename) {
        return {
          prev,
          key,
          typename
        };
      }
      function pathToArray2(path) {
        const flattened = [];
        let curr = path;
        while (curr) {
          flattened.push(curr.key);
          curr = curr.prev;
        }
        return flattened.reverse();
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/coerceInputValue.js
  var require_coerceInputValue = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/coerceInputValue.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.coerceInputValue = coerceInputValue2;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _isIterableObject = require_isIterableObject();
      var _isObjectLike = require_isObjectLike();
      var _Path = require_Path();
      var _printPathArray = require_printPathArray();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function coerceInputValue2(inputValue, type, onError = defaultOnError2) {
        return coerceInputValueImpl2(inputValue, type, onError, void 0);
      }
      function defaultOnError2(path, invalidValue, error) {
        let errorPrefix = "Invalid value " + (0, _inspect.inspect)(invalidValue);
        if (path.length > 0) {
          errorPrefix += ` at "value${(0, _printPathArray.printPathArray)(path)}"`;
        }
        error.message = errorPrefix + ": " + error.message;
        throw error;
      }
      function coerceInputValueImpl2(inputValue, type, onError, path) {
        if ((0, _definition.isNonNullType)(type)) {
          if (inputValue != null) {
            return coerceInputValueImpl2(inputValue, type.ofType, onError, path);
          }
          onError(
            (0, _Path.pathToArray)(path),
            inputValue,
            new _GraphQLError.GraphQLError(
              `Expected non-nullable type "${(0, _inspect.inspect)(
                type
              )}" not to be null.`
            )
          );
          return;
        }
        if (inputValue == null) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if ((0, _isIterableObject.isIterableObject)(inputValue)) {
            return Array.from(inputValue, (itemValue, index) => {
              const itemPath = (0, _Path.addPath)(path, index, void 0);
              return coerceInputValueImpl2(itemValue, itemType, onError, itemPath);
            });
          }
          return [coerceInputValueImpl2(inputValue, itemType, onError, path)];
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (!(0, _isObjectLike.isObjectLike)(inputValue)) {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(
                `Expected type "${type.name}" to be an object.`
              )
            );
            return;
          }
          const coercedValue = {};
          const fieldDefs = type.getFields();
          for (const field of Object.values(fieldDefs)) {
            const fieldValue = inputValue[field.name];
            if (fieldValue === void 0) {
              if (field.defaultValue !== void 0) {
                coercedValue[field.name] = field.defaultValue;
              } else if ((0, _definition.isNonNullType)(field.type)) {
                const typeStr = (0, _inspect.inspect)(field.type);
                onError(
                  (0, _Path.pathToArray)(path),
                  inputValue,
                  new _GraphQLError.GraphQLError(
                    `Field "${field.name}" of required type "${typeStr}" was not provided.`
                  )
                );
              }
              continue;
            }
            coercedValue[field.name] = coerceInputValueImpl2(
              fieldValue,
              field.type,
              onError,
              (0, _Path.addPath)(path, field.name, type.name)
            );
          }
          for (const fieldName of Object.keys(inputValue)) {
            if (!fieldDefs[fieldName]) {
              const suggestions = (0, _suggestionList.suggestionList)(
                fieldName,
                Object.keys(type.getFields())
              );
              onError(
                (0, _Path.pathToArray)(path),
                inputValue,
                new _GraphQLError.GraphQLError(
                  `Field "${fieldName}" is not defined by type "${type.name}".` + (0, _didYouMean.didYouMean)(suggestions)
                )
              );
            }
          }
          return coercedValue;
        }
        if ((0, _definition.isLeafType)(type)) {
          let parseResult;
          try {
            parseResult = type.parseValue(inputValue);
          } catch (error) {
            if (error instanceof _GraphQLError.GraphQLError) {
              onError((0, _Path.pathToArray)(path), inputValue, error);
            } else {
              onError(
                (0, _Path.pathToArray)(path),
                inputValue,
                new _GraphQLError.GraphQLError(
                  `Expected type "${type.name}". ` + error.message,
                  {
                    originalError: error
                  }
                )
              );
            }
            return;
          }
          if (parseResult === void 0) {
            onError(
              (0, _Path.pathToArray)(path),
              inputValue,
              new _GraphQLError.GraphQLError(`Expected type "${type.name}".`)
            );
          }
          return parseResult;
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected input type: " + (0, _inspect.inspect)(type)
        );
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/valueFromAST.js
  var require_valueFromAST = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/utilities/valueFromAST.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.valueFromAST = valueFromAST2;
      var _inspect = require_inspect();
      var _invariant = require_invariant();
      var _keyMap = require_keyMap();
      var _kinds = require_kinds();
      var _definition = require_definition();
      function valueFromAST2(valueNode, type, variables) {
        if (!valueNode) {
          return;
        }
        if (valueNode.kind === _kinds.Kind.VARIABLE) {
          const variableName = valueNode.name.value;
          if (variables == null || variables[variableName] === void 0) {
            return;
          }
          const variableValue = variables[variableName];
          if (variableValue === null && (0, _definition.isNonNullType)(type)) {
            return;
          }
          return variableValue;
        }
        if ((0, _definition.isNonNullType)(type)) {
          if (valueNode.kind === _kinds.Kind.NULL) {
            return;
          }
          return valueFromAST2(valueNode, type.ofType, variables);
        }
        if (valueNode.kind === _kinds.Kind.NULL) {
          return null;
        }
        if ((0, _definition.isListType)(type)) {
          const itemType = type.ofType;
          if (valueNode.kind === _kinds.Kind.LIST) {
            const coercedValues = [];
            for (const itemNode of valueNode.values) {
              if (isMissingVariable2(itemNode, variables)) {
                if ((0, _definition.isNonNullType)(itemType)) {
                  return;
                }
                coercedValues.push(null);
              } else {
                const itemValue = valueFromAST2(itemNode, itemType, variables);
                if (itemValue === void 0) {
                  return;
                }
                coercedValues.push(itemValue);
              }
            }
            return coercedValues;
          }
          const coercedValue = valueFromAST2(valueNode, itemType, variables);
          if (coercedValue === void 0) {
            return;
          }
          return [coercedValue];
        }
        if ((0, _definition.isInputObjectType)(type)) {
          if (valueNode.kind !== _kinds.Kind.OBJECT) {
            return;
          }
          const coercedObj = /* @__PURE__ */ Object.create(null);
          const fieldNodes = (0, _keyMap.keyMap)(
            valueNode.fields,
            (field) => field.name.value
          );
          for (const field of Object.values(type.getFields())) {
            const fieldNode = fieldNodes[field.name];
            if (!fieldNode || isMissingVariable2(fieldNode.value, variables)) {
              if (field.defaultValue !== void 0) {
                coercedObj[field.name] = field.defaultValue;
              } else if ((0, _definition.isNonNullType)(field.type)) {
                return;
              }
              continue;
            }
            const fieldValue = valueFromAST2(fieldNode.value, field.type, variables);
            if (fieldValue === void 0) {
              return;
            }
            coercedObj[field.name] = fieldValue;
          }
          return coercedObj;
        }
        if ((0, _definition.isLeafType)(type)) {
          let result;
          try {
            result = type.parseLiteral(valueNode, variables);
          } catch (_error) {
            return;
          }
          if (result === void 0) {
            return;
          }
          return result;
        }
        (0, _invariant.invariant)(
          false,
          "Unexpected input type: " + (0, _inspect.inspect)(type)
        );
      }
      function isMissingVariable2(valueNode, variables) {
        return valueNode.kind === _kinds.Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/values.js
  var require_values = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/values.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.getArgumentValues = getArgumentValues2;
      exports2.getDirectiveValues = getDirectiveValues2;
      exports2.getVariableValues = getVariableValues2;
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _printPathArray = require_printPathArray();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _printer = require_printer();
      var _definition = require_definition();
      var _coerceInputValue = require_coerceInputValue();
      var _typeFromAST = require_typeFromAST();
      var _valueFromAST = require_valueFromAST();
      function getVariableValues2(schema, varDefNodes, inputs, options) {
        const errors = [];
        const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
        try {
          const coerced = coerceVariableValues2(
            schema,
            varDefNodes,
            inputs,
            (error) => {
              if (maxErrors != null && errors.length >= maxErrors) {
                throw new _GraphQLError.GraphQLError(
                  "Too many errors processing variables, error limit reached. Execution aborted."
                );
              }
              errors.push(error);
            }
          );
          if (errors.length === 0) {
            return {
              coerced
            };
          }
        } catch (error) {
          errors.push(error);
        }
        return {
          errors
        };
      }
      function coerceVariableValues2(schema, varDefNodes, inputs, onError) {
        const coercedValues = {};
        for (const varDefNode of varDefNodes) {
          const varName = varDefNode.variable.name.value;
          const varType = (0, _typeFromAST.typeFromAST)(schema, varDefNode.type);
          if (!(0, _definition.isInputType)(varType)) {
            const varTypeStr = (0, _printer.print)(varDefNode.type);
            onError(
              new _GraphQLError.GraphQLError(
                `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
                {
                  nodes: varDefNode.type
                }
              )
            );
            continue;
          }
          if (!hasOwnProperty2(inputs, varName)) {
            if (varDefNode.defaultValue) {
              coercedValues[varName] = (0, _valueFromAST.valueFromAST)(
                varDefNode.defaultValue,
                varType
              );
            } else if ((0, _definition.isNonNullType)(varType)) {
              const varTypeStr = (0, _inspect.inspect)(varType);
              onError(
                new _GraphQLError.GraphQLError(
                  `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
                  {
                    nodes: varDefNode
                  }
                )
              );
            }
            continue;
          }
          const value = inputs[varName];
          if (value === null && (0, _definition.isNonNullType)(varType)) {
            const varTypeStr = (0, _inspect.inspect)(varType);
            onError(
              new _GraphQLError.GraphQLError(
                `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
                {
                  nodes: varDefNode
                }
              )
            );
            continue;
          }
          coercedValues[varName] = (0, _coerceInputValue.coerceInputValue)(
            value,
            varType,
            (path, invalidValue, error) => {
              let prefix = `Variable "$${varName}" got invalid value ` + (0, _inspect.inspect)(invalidValue);
              if (path.length > 0) {
                prefix += ` at "${varName}${(0, _printPathArray.printPathArray)(
                  path
                )}"`;
              }
              onError(
                new _GraphQLError.GraphQLError(prefix + "; " + error.message, {
                  nodes: varDefNode,
                  originalError: error
                })
              );
            }
          );
        }
        return coercedValues;
      }
      function getArgumentValues2(def, node, variableValues) {
        var _node$arguments;
        const coercedValues = {};
        const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
        const argNodeMap = (0, _keyMap.keyMap)(
          argumentNodes,
          (arg) => arg.name.value
        );
        for (const argDef of def.args) {
          const name2 = argDef.name;
          const argType = argDef.type;
          const argumentNode = argNodeMap[name2];
          if (!argumentNode) {
            if (argDef.defaultValue !== void 0) {
              coercedValues[name2] = argDef.defaultValue;
            } else if ((0, _definition.isNonNullType)(argType)) {
              throw new _GraphQLError.GraphQLError(
                `Argument "${name2}" of required type "${(0, _inspect.inspect)(
                  argType
                )}" was not provided.`,
                {
                  nodes: node
                }
              );
            }
            continue;
          }
          const valueNode = argumentNode.value;
          let isNull = valueNode.kind === _kinds.Kind.NULL;
          if (valueNode.kind === _kinds.Kind.VARIABLE) {
            const variableName = valueNode.name.value;
            if (variableValues == null || !hasOwnProperty2(variableValues, variableName)) {
              if (argDef.defaultValue !== void 0) {
                coercedValues[name2] = argDef.defaultValue;
              } else if ((0, _definition.isNonNullType)(argType)) {
                throw new _GraphQLError.GraphQLError(
                  `Argument "${name2}" of required type "${(0, _inspect.inspect)(
                    argType
                  )}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
                  {
                    nodes: valueNode
                  }
                );
              }
              continue;
            }
            isNull = variableValues[variableName] == null;
          }
          if (isNull && (0, _definition.isNonNullType)(argType)) {
            throw new _GraphQLError.GraphQLError(
              `Argument "${name2}" of non-null type "${(0, _inspect.inspect)(
                argType
              )}" must not be null.`,
              {
                nodes: valueNode
              }
            );
          }
          const coercedValue = (0, _valueFromAST.valueFromAST)(
            valueNode,
            argType,
            variableValues
          );
          if (coercedValue === void 0) {
            throw new _GraphQLError.GraphQLError(
              `Argument "${name2}" has invalid value ${(0, _printer.print)(
                valueNode
              )}.`,
              {
                nodes: valueNode
              }
            );
          }
          coercedValues[name2] = coercedValue;
        }
        return coercedValues;
      }
      function getDirectiveValues2(directiveDef, node, variableValues) {
        var _node$directives;
        const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
          (directive) => directive.name.value === directiveDef.name
        );
        if (directiveNode) {
          return getArgumentValues2(directiveDef, directiveNode, variableValues);
        }
      }
      function hasOwnProperty2(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/collectFields.js
  var require_collectFields = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/execution/collectFields.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.collectFields = collectFields2;
      exports2.collectSubfields = collectSubfields3;
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _directives = require_directives();
      var _typeFromAST = require_typeFromAST();
      var _values = require_values();
      function collectFields2(schema, fragments, variableValues, runtimeType, selectionSet) {
        const fields = /* @__PURE__ */ new Map();
        collectFieldsImpl2(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selectionSet,
          fields,
          /* @__PURE__ */ new Set()
        );
        return fields;
      }
      function collectSubfields3(schema, fragments, variableValues, returnType, fieldNodes) {
        const subFieldNodes = /* @__PURE__ */ new Map();
        const visitedFragmentNames = /* @__PURE__ */ new Set();
        for (const node of fieldNodes) {
          if (node.selectionSet) {
            collectFieldsImpl2(
              schema,
              fragments,
              variableValues,
              returnType,
              node.selectionSet,
              subFieldNodes,
              visitedFragmentNames
            );
          }
        }
        return subFieldNodes;
      }
      function collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
        for (const selection of selectionSet.selections) {
          switch (selection.kind) {
            case _kinds.Kind.FIELD: {
              if (!shouldIncludeNode2(variableValues, selection)) {
                continue;
              }
              const name2 = getFieldEntryKey2(selection);
              const fieldList = fields.get(name2);
              if (fieldList !== void 0) {
                fieldList.push(selection);
              } else {
                fields.set(name2, [selection]);
              }
              break;
            }
            case _kinds.Kind.INLINE_FRAGMENT: {
              if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema, selection, runtimeType)) {
                continue;
              }
              collectFieldsImpl2(
                schema,
                fragments,
                variableValues,
                runtimeType,
                selection.selectionSet,
                fields,
                visitedFragmentNames
              );
              break;
            }
            case _kinds.Kind.FRAGMENT_SPREAD: {
              const fragName = selection.name.value;
              if (visitedFragmentNames.has(fragName) || !shouldIncludeNode2(variableValues, selection)) {
                continue;
              }
              visitedFragmentNames.add(fragName);
              const fragment = fragments[fragName];
              if (!fragment || !doesFragmentConditionMatch2(schema, fragment, runtimeType)) {
                continue;
              }
              collectFieldsImpl2(
                schema,
                fragments,
                variableValues,
                runtimeType,
                fragment.selectionSet,
                fields,
                visitedFragmentNames
              );
              break;
            }
          }
        }
      }
      function shouldIncludeNode2(variableValues, node) {
        const skip = (0, _values.getDirectiveValues)(
          _directives.GraphQLSkipDirective,
          node,
          variableValues
        );
        if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
          return false;
        }
        const include = (0, _values.getDirectiveValues)(
          _directives.GraphQLIncludeDirective,
          node,
          variableValues
        );
        if ((include === null || include === void 0 ? void 0 : include.if) === false) {
          return false;
        }
        return true;
      }
      function doesFragmentConditionMatch2(schema, fragment, type) {
        const typeConditionNode = fragment.typeCondition;
        if (!typeConditionNode) {
          return true;
        }
        const conditionalType = (0, _typeFromAST.typeFromAST)(
          schema,
          typeConditionNode
        );
        if (conditionalType === type) {
          return true;
        }
        if ((0, _definition.isAbstractType)(conditionalType)) {
          return schema.isSubType(conditionalType, type);
        }
        return false;
      }
      function getFieldEntryKey2(node) {
        return node.alias ? node.alias.value : node.name.value;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js
  var require_SingleFieldSubscriptionsRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule2;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _collectFields = require_collectFields();
      function SingleFieldSubscriptionsRule2(context) {
        return {
          OperationDefinition(node) {
            if (node.operation === "subscription") {
              const schema = context.getSchema();
              const subscriptionType = schema.getSubscriptionType();
              if (subscriptionType) {
                const operationName = node.name ? node.name.value : null;
                const variableValues = /* @__PURE__ */ Object.create(null);
                const document = context.getDocument();
                const fragments = /* @__PURE__ */ Object.create(null);
                for (const definition of document.definitions) {
                  if (definition.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                    fragments[definition.name.value] = definition;
                  }
                }
                const fields = (0, _collectFields.collectFields)(
                  schema,
                  fragments,
                  variableValues,
                  subscriptionType,
                  node.selectionSet
                );
                if (fields.size > 1) {
                  const fieldSelectionLists = [...fields.values()];
                  const extraFieldSelectionLists = fieldSelectionLists.slice(1);
                  const extraFieldSelections = extraFieldSelectionLists.flat();
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                      {
                        nodes: extraFieldSelections
                      }
                    )
                  );
                }
                for (const fieldNodes of fields.values()) {
                  const field = fieldNodes[0];
                  const fieldName = field.name.value;
                  if (fieldName.startsWith("__")) {
                    context.reportError(
                      new _GraphQLError.GraphQLError(
                        operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                        {
                          nodes: fieldNodes
                        }
                      )
                    );
                  }
                }
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/groupBy.js
  var require_groupBy = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/jsutils/groupBy.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.groupBy = groupBy2;
      function groupBy2(list, keyFn) {
        const result = /* @__PURE__ */ new Map();
        for (const item of list) {
          const key = keyFn(item);
          const group = result.get(key);
          if (group === void 0) {
            result.set(key, [item]);
          } else {
            group.push(item);
          }
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js
  var require_UniqueArgumentDefinitionNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule2;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueArgumentDefinitionNamesRule2(context) {
        return {
          DirectiveDefinition(directiveNode) {
            var _directiveNode$argume;
            const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
            return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
          },
          InterfaceTypeDefinition: checkArgUniquenessPerField,
          InterfaceTypeExtension: checkArgUniquenessPerField,
          ObjectTypeDefinition: checkArgUniquenessPerField,
          ObjectTypeExtension: checkArgUniquenessPerField
        };
        function checkArgUniquenessPerField(typeNode) {
          var _typeNode$fields;
          const typeName = typeNode.name.value;
          const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
          for (const fieldDef of fieldNodes) {
            var _fieldDef$arguments;
            const fieldName = fieldDef.name.value;
            const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
            checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
          }
          return false;
        }
        function checkArgUniqueness(parentName, argumentNodes) {
          const seenArgs = (0, _groupBy.groupBy)(
            argumentNodes,
            (arg) => arg.name.value
          );
          for (const [argName, argNodes] of seenArgs) {
            if (argNodes.length > 1) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Argument "${parentName}(${argName}:)" can only be defined once.`,
                  {
                    nodes: argNodes.map((node) => node.name)
                  }
                )
              );
            }
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js
  var require_UniqueArgumentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueArgumentNamesRule = UniqueArgumentNamesRule2;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueArgumentNamesRule2(context) {
        return {
          Field: checkArgUniqueness,
          Directive: checkArgUniqueness
        };
        function checkArgUniqueness(parentNode) {
          var _parentNode$arguments;
          const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
          const seenArgs = (0, _groupBy.groupBy)(
            argumentNodes,
            (arg) => arg.name.value
          );
          for (const [argName, argNodes] of seenArgs) {
            if (argNodes.length > 1) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one argument named "${argName}".`,
                  {
                    nodes: argNodes.map((node) => node.name)
                  }
                )
              );
            }
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js
  var require_UniqueDirectiveNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule2;
      var _GraphQLError = require_GraphQLError();
      function UniqueDirectiveNamesRule2(context) {
        const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        return {
          DirectiveDefinition(node) {
            const directiveName = node.name.value;
            if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
                  {
                    nodes: node.name
                  }
                )
              );
              return;
            }
            if (knownDirectiveNames[directiveName]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one directive named "@${directiveName}".`,
                  {
                    nodes: [knownDirectiveNames[directiveName], node.name]
                  }
                )
              );
            } else {
              knownDirectiveNames[directiveName] = node.name;
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js
  var require_UniqueDirectivesPerLocationRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule2;
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _predicates = require_predicates();
      var _directives = require_directives();
      function UniqueDirectivesPerLocationRule2(context) {
        const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        const definedDirectives = schema ? schema.getDirectives() : _directives.specifiedDirectives;
        for (const directive of definedDirectives) {
          uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
        }
        const astDefinitions = context.getDocument().definitions;
        for (const def of astDefinitions) {
          if (def.kind === _kinds.Kind.DIRECTIVE_DEFINITION) {
            uniqueDirectiveMap[def.name.value] = !def.repeatable;
          }
        }
        const schemaDirectives = /* @__PURE__ */ Object.create(null);
        const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
        return {
          // Many different AST nodes may contain directives. Rather than listing
          // them all, just listen for entering any node, and check to see if it
          // defines any directives.
          enter(node) {
            if (!("directives" in node) || !node.directives) {
              return;
            }
            let seenDirectives;
            if (node.kind === _kinds.Kind.SCHEMA_DEFINITION || node.kind === _kinds.Kind.SCHEMA_EXTENSION) {
              seenDirectives = schemaDirectives;
            } else if ((0, _predicates.isTypeDefinitionNode)(node) || (0, _predicates.isTypeExtensionNode)(node)) {
              const typeName = node.name.value;
              seenDirectives = typeDirectivesMap[typeName];
              if (seenDirectives === void 0) {
                typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
              }
            } else {
              seenDirectives = /* @__PURE__ */ Object.create(null);
            }
            for (const directive of node.directives) {
              const directiveName = directive.name.value;
              if (uniqueDirectiveMap[directiveName]) {
                if (seenDirectives[directiveName]) {
                  context.reportError(
                    new _GraphQLError.GraphQLError(
                      `The directive "@${directiveName}" can only be used once at this location.`,
                      {
                        nodes: [seenDirectives[directiveName], directive]
                      }
                    )
                  );
                } else {
                  seenDirectives[directiveName] = directive;
                }
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js
  var require_UniqueEnumValueNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule2;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function UniqueEnumValueNamesRule2(context) {
        const schema = context.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const knownValueNames = /* @__PURE__ */ Object.create(null);
        return {
          EnumTypeDefinition: checkValueUniqueness,
          EnumTypeExtension: checkValueUniqueness
        };
        function checkValueUniqueness(node) {
          var _node$values;
          const typeName = node.name.value;
          if (!knownValueNames[typeName]) {
            knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
          }
          const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
          const valueNames = knownValueNames[typeName];
          for (const valueDef of valueNodes) {
            const valueName = valueDef.name.value;
            const existingType = existingTypeMap[typeName];
            if ((0, _definition.isEnumType)(existingType) && existingType.getValue(valueName)) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
                  {
                    nodes: valueDef.name
                  }
                )
              );
            } else if (valueNames[valueName]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Enum value "${typeName}.${valueName}" can only be defined once.`,
                  {
                    nodes: [valueNames[valueName], valueDef.name]
                  }
                )
              );
            } else {
              valueNames[valueName] = valueDef.name;
            }
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js
  var require_UniqueFieldDefinitionNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule2;
      var _GraphQLError = require_GraphQLError();
      var _definition = require_definition();
      function UniqueFieldDefinitionNamesRule2(context) {
        const schema = context.getSchema();
        const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
        const knownFieldNames = /* @__PURE__ */ Object.create(null);
        return {
          InputObjectTypeDefinition: checkFieldUniqueness,
          InputObjectTypeExtension: checkFieldUniqueness,
          InterfaceTypeDefinition: checkFieldUniqueness,
          InterfaceTypeExtension: checkFieldUniqueness,
          ObjectTypeDefinition: checkFieldUniqueness,
          ObjectTypeExtension: checkFieldUniqueness
        };
        function checkFieldUniqueness(node) {
          var _node$fields;
          const typeName = node.name.value;
          if (!knownFieldNames[typeName]) {
            knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
          }
          const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
          const fieldNames = knownFieldNames[typeName];
          for (const fieldDef of fieldNodes) {
            const fieldName = fieldDef.name.value;
            if (hasField2(existingTypeMap[typeName], fieldName)) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
                  {
                    nodes: fieldDef.name
                  }
                )
              );
            } else if (fieldNames[fieldName]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${typeName}.${fieldName}" can only be defined once.`,
                  {
                    nodes: [fieldNames[fieldName], fieldDef.name]
                  }
                )
              );
            } else {
              fieldNames[fieldName] = fieldDef.name;
            }
          }
          return false;
        }
      }
      function hasField2(type, fieldName) {
        if ((0, _definition.isObjectType)(type) || (0, _definition.isInterfaceType)(type) || (0, _definition.isInputObjectType)(type)) {
          return type.getFields()[fieldName] != null;
        }
        return false;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js
  var require_UniqueFragmentNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueFragmentNamesRule = UniqueFragmentNamesRule2;
      var _GraphQLError = require_GraphQLError();
      function UniqueFragmentNamesRule2(context) {
        const knownFragmentNames = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: () => false,
          FragmentDefinition(node) {
            const fragmentName = node.name.value;
            if (knownFragmentNames[fragmentName]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one fragment named "${fragmentName}".`,
                  {
                    nodes: [knownFragmentNames[fragmentName], node.name]
                  }
                )
              );
            } else {
              knownFragmentNames[fragmentName] = node.name;
            }
            return false;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js
  var require_UniqueInputFieldNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule2;
      var _invariant = require_invariant();
      var _GraphQLError = require_GraphQLError();
      function UniqueInputFieldNamesRule2(context) {
        const knownNameStack = [];
        let knownNames = /* @__PURE__ */ Object.create(null);
        return {
          ObjectValue: {
            enter() {
              knownNameStack.push(knownNames);
              knownNames = /* @__PURE__ */ Object.create(null);
            },
            leave() {
              const prevKnownNames = knownNameStack.pop();
              prevKnownNames || (0, _invariant.invariant)(false);
              knownNames = prevKnownNames;
            }
          },
          ObjectField(node) {
            const fieldName = node.name.value;
            if (knownNames[fieldName]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one input field named "${fieldName}".`,
                  {
                    nodes: [knownNames[fieldName], node.name]
                  }
                )
              );
            } else {
              knownNames[fieldName] = node.name;
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js
  var require_UniqueOperationNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueOperationNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueOperationNamesRule = UniqueOperationNamesRule2;
      var _GraphQLError = require_GraphQLError();
      function UniqueOperationNamesRule2(context) {
        const knownOperationNames = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition(node) {
            const operationName = node.name;
            if (operationName) {
              if (knownOperationNames[operationName.value]) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `There can be only one operation named "${operationName.value}".`,
                    {
                      nodes: [
                        knownOperationNames[operationName.value],
                        operationName
                      ]
                    }
                  )
                );
              } else {
                knownOperationNames[operationName.value] = operationName;
              }
            }
            return false;
          },
          FragmentDefinition: () => false
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js
  var require_UniqueOperationTypesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueOperationTypesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueOperationTypesRule = UniqueOperationTypesRule2;
      var _GraphQLError = require_GraphQLError();
      function UniqueOperationTypesRule2(context) {
        const schema = context.getSchema();
        const definedOperationTypes = /* @__PURE__ */ Object.create(null);
        const existingOperationTypes = schema ? {
          query: schema.getQueryType(),
          mutation: schema.getMutationType(),
          subscription: schema.getSubscriptionType()
        } : {};
        return {
          SchemaDefinition: checkOperationTypes,
          SchemaExtension: checkOperationTypes
        };
        function checkOperationTypes(node) {
          var _node$operationTypes;
          const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
          for (const operationType of operationTypesNodes) {
            const operation = operationType.operation;
            const alreadyDefinedOperationType = definedOperationTypes[operation];
            if (existingOperationTypes[operation]) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Type for ${operation} already defined in the schema. It cannot be redefined.`,
                  {
                    nodes: operationType
                  }
                )
              );
            } else if (alreadyDefinedOperationType) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `There can be only one ${operation} type in schema.`,
                  {
                    nodes: [alreadyDefinedOperationType, operationType]
                  }
                )
              );
            } else {
              definedOperationTypes[operation] = operationType;
            }
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js
  var require_UniqueTypeNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueTypeNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueTypeNamesRule = UniqueTypeNamesRule2;
      var _GraphQLError = require_GraphQLError();
      function UniqueTypeNamesRule2(context) {
        const knownTypeNames = /* @__PURE__ */ Object.create(null);
        const schema = context.getSchema();
        return {
          ScalarTypeDefinition: checkTypeName,
          ObjectTypeDefinition: checkTypeName,
          InterfaceTypeDefinition: checkTypeName,
          UnionTypeDefinition: checkTypeName,
          EnumTypeDefinition: checkTypeName,
          InputObjectTypeDefinition: checkTypeName
        };
        function checkTypeName(node) {
          const typeName = node.name.value;
          if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
                {
                  nodes: node.name
                }
              )
            );
            return;
          }
          if (knownTypeNames[typeName]) {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `There can be only one type named "${typeName}".`,
                {
                  nodes: [knownTypeNames[typeName], node.name]
                }
              )
            );
          } else {
            knownTypeNames[typeName] = node.name;
          }
          return false;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js
  var require_UniqueVariableNamesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/UniqueVariableNamesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.UniqueVariableNamesRule = UniqueVariableNamesRule2;
      var _groupBy = require_groupBy();
      var _GraphQLError = require_GraphQLError();
      function UniqueVariableNamesRule2(context) {
        return {
          OperationDefinition(operationNode) {
            var _operationNode$variab;
            const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
            const seenVariableDefinitions = (0, _groupBy.groupBy)(
              variableDefinitions,
              (node) => node.variable.name.value
            );
            for (const [variableName, variableNodes] of seenVariableDefinitions) {
              if (variableNodes.length > 1) {
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `There can be only one variable named "$${variableName}".`,
                    {
                      nodes: variableNodes.map((node) => node.variable.name)
                    }
                  )
                );
              }
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js
  var require_ValuesOfCorrectTypeRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule2;
      var _didYouMean = require_didYouMean();
      var _inspect = require_inspect();
      var _keyMap = require_keyMap();
      var _suggestionList = require_suggestionList();
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      function ValuesOfCorrectTypeRule2(context) {
        return {
          ListValue(node) {
            const type = (0, _definition.getNullableType)(
              context.getParentInputType()
            );
            if (!(0, _definition.isListType)(type)) {
              isValidValueNode2(context, node);
              return false;
            }
          },
          ObjectValue(node) {
            const type = (0, _definition.getNamedType)(context.getInputType());
            if (!(0, _definition.isInputObjectType)(type)) {
              isValidValueNode2(context, node);
              return false;
            }
            const fieldNodeMap = (0, _keyMap.keyMap)(
              node.fields,
              (field) => field.name.value
            );
            for (const fieldDef of Object.values(type.getFields())) {
              const fieldNode = fieldNodeMap[fieldDef.name];
              if (!fieldNode && (0, _definition.isRequiredInputField)(fieldDef)) {
                const typeStr = (0, _inspect.inspect)(fieldDef.type);
                context.reportError(
                  new _GraphQLError.GraphQLError(
                    `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
                    {
                      nodes: node
                    }
                  )
                );
              }
            }
          },
          ObjectField(node) {
            const parentType = (0, _definition.getNamedType)(
              context.getParentInputType()
            );
            const fieldType = context.getInputType();
            if (!fieldType && (0, _definition.isInputObjectType)(parentType)) {
              const suggestions = (0, _suggestionList.suggestionList)(
                node.name.value,
                Object.keys(parentType.getFields())
              );
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Field "${node.name.value}" is not defined by type "${parentType.name}".` + (0, _didYouMean.didYouMean)(suggestions),
                  {
                    nodes: node
                  }
                )
              );
            }
          },
          NullValue(node) {
            const type = context.getInputType();
            if ((0, _definition.isNonNullType)(type)) {
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Expected value of type "${(0, _inspect.inspect)(
                    type
                  )}", found ${(0, _printer.print)(node)}.`,
                  {
                    nodes: node
                  }
                )
              );
            }
          },
          EnumValue: (node) => isValidValueNode2(context, node),
          IntValue: (node) => isValidValueNode2(context, node),
          FloatValue: (node) => isValidValueNode2(context, node),
          StringValue: (node) => isValidValueNode2(context, node),
          BooleanValue: (node) => isValidValueNode2(context, node)
        };
      }
      function isValidValueNode2(context, node) {
        const locationType = context.getInputType();
        if (!locationType) {
          return;
        }
        const type = (0, _definition.getNamedType)(locationType);
        if (!(0, _definition.isLeafType)(type)) {
          const typeStr = (0, _inspect.inspect)(locationType);
          context.reportError(
            new _GraphQLError.GraphQLError(
              `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                node
              )}.`,
              {
                nodes: node
              }
            )
          );
          return;
        }
        try {
          const parseResult = type.parseLiteral(
            node,
            void 0
            /* variables */
          );
          if (parseResult === void 0) {
            const typeStr = (0, _inspect.inspect)(locationType);
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                  node
                )}.`,
                {
                  nodes: node
                }
              )
            );
          }
        } catch (error) {
          const typeStr = (0, _inspect.inspect)(locationType);
          if (error instanceof _GraphQLError.GraphQLError) {
            context.reportError(error);
          } else {
            context.reportError(
              new _GraphQLError.GraphQLError(
                `Expected value of type "${typeStr}", found ${(0, _printer.print)(
                  node
                )}; ` + error.message,
                {
                  nodes: node,
                  originalError: error
                }
              )
            );
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js
  var require_VariablesAreInputTypesRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.VariablesAreInputTypesRule = VariablesAreInputTypesRule2;
      var _GraphQLError = require_GraphQLError();
      var _printer = require_printer();
      var _definition = require_definition();
      var _typeFromAST = require_typeFromAST();
      function VariablesAreInputTypesRule2(context) {
        return {
          VariableDefinition(node) {
            const type = (0, _typeFromAST.typeFromAST)(
              context.getSchema(),
              node.type
            );
            if (type !== void 0 && !(0, _definition.isInputType)(type)) {
              const variableName = node.variable.name.value;
              const typeName = (0, _printer.print)(node.type);
              context.reportError(
                new _GraphQLError.GraphQLError(
                  `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
                  {
                    nodes: node.type
                  }
                )
              );
            }
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js
  var require_VariablesInAllowedPositionRule = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule2;
      var _inspect = require_inspect();
      var _GraphQLError = require_GraphQLError();
      var _kinds = require_kinds();
      var _definition = require_definition();
      var _typeComparators = require_typeComparators();
      var _typeFromAST = require_typeFromAST();
      function VariablesInAllowedPositionRule2(context) {
        let varDefMap = /* @__PURE__ */ Object.create(null);
        return {
          OperationDefinition: {
            enter() {
              varDefMap = /* @__PURE__ */ Object.create(null);
            },
            leave(operation) {
              const usages = context.getRecursiveVariableUsages(operation);
              for (const { node, type, defaultValue } of usages) {
                const varName = node.name.value;
                const varDef = varDefMap[varName];
                if (varDef && type) {
                  const schema = context.getSchema();
                  const varType = (0, _typeFromAST.typeFromAST)(schema, varDef.type);
                  if (varType && !allowedVariableUsage2(
                    schema,
                    varType,
                    varDef.defaultValue,
                    type,
                    defaultValue
                  )) {
                    const varTypeStr = (0, _inspect.inspect)(varType);
                    const typeStr = (0, _inspect.inspect)(type);
                    context.reportError(
                      new _GraphQLError.GraphQLError(
                        `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                        {
                          nodes: [varDef, node]
                        }
                      )
                    );
                  }
                }
              }
            }
          },
          VariableDefinition(node) {
            varDefMap[node.variable.name.value] = node;
          }
        };
      }
      function allowedVariableUsage2(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
        if ((0, _definition.isNonNullType)(locationType) && !(0, _definition.isNonNullType)(varType)) {
          const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _kinds.Kind.NULL;
          const hasLocationDefaultValue = locationDefaultValue !== void 0;
          if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
            return false;
          }
          const nullableLocationType = locationType.ofType;
          return (0, _typeComparators.isTypeSubTypeOf)(
            schema,
            varType,
            nullableLocationType
          );
        }
        return (0, _typeComparators.isTypeSubTypeOf)(schema, varType, locationType);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/specifiedRules.js
  var require_specifiedRules = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/specifiedRules.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.specifiedSDLRules = exports2.specifiedRules = void 0;
      var _ExecutableDefinitionsRule = require_ExecutableDefinitionsRule();
      var _FieldsOnCorrectTypeRule = require_FieldsOnCorrectTypeRule();
      var _FragmentsOnCompositeTypesRule = require_FragmentsOnCompositeTypesRule();
      var _KnownArgumentNamesRule = require_KnownArgumentNamesRule();
      var _KnownDirectivesRule = require_KnownDirectivesRule();
      var _KnownFragmentNamesRule = require_KnownFragmentNamesRule();
      var _KnownTypeNamesRule = require_KnownTypeNamesRule();
      var _LoneAnonymousOperationRule = require_LoneAnonymousOperationRule();
      var _LoneSchemaDefinitionRule = require_LoneSchemaDefinitionRule();
      var _NoFragmentCyclesRule = require_NoFragmentCyclesRule();
      var _NoUndefinedVariablesRule = require_NoUndefinedVariablesRule();
      var _NoUnusedFragmentsRule = require_NoUnusedFragmentsRule();
      var _NoUnusedVariablesRule = require_NoUnusedVariablesRule();
      var _OverlappingFieldsCanBeMergedRule = require_OverlappingFieldsCanBeMergedRule();
      var _PossibleFragmentSpreadsRule = require_PossibleFragmentSpreadsRule();
      var _PossibleTypeExtensionsRule = require_PossibleTypeExtensionsRule();
      var _ProvidedRequiredArgumentsRule = require_ProvidedRequiredArgumentsRule();
      var _ScalarLeafsRule = require_ScalarLeafsRule();
      var _SingleFieldSubscriptionsRule = require_SingleFieldSubscriptionsRule();
      var _UniqueArgumentDefinitionNamesRule = require_UniqueArgumentDefinitionNamesRule();
      var _UniqueArgumentNamesRule = require_UniqueArgumentNamesRule();
      var _UniqueDirectiveNamesRule = require_UniqueDirectiveNamesRule();
      var _UniqueDirectivesPerLocationRule = require_UniqueDirectivesPerLocationRule();
      var _UniqueEnumValueNamesRule = require_UniqueEnumValueNamesRule();
      var _UniqueFieldDefinitionNamesRule = require_UniqueFieldDefinitionNamesRule();
      var _UniqueFragmentNamesRule = require_UniqueFragmentNamesRule();
      var _UniqueInputFieldNamesRule = require_UniqueInputFieldNamesRule();
      var _UniqueOperationNamesRule = require_UniqueOperationNamesRule();
      var _UniqueOperationTypesRule = require_UniqueOperationTypesRule();
      var _UniqueTypeNamesRule = require_UniqueTypeNamesRule();
      var _UniqueVariableNamesRule = require_UniqueVariableNamesRule();
      var _ValuesOfCorrectTypeRule = require_ValuesOfCorrectTypeRule();
      var _VariablesAreInputTypesRule = require_VariablesAreInputTypesRule();
      var _VariablesInAllowedPositionRule = require_VariablesInAllowedPositionRule();
      var specifiedRules2 = Object.freeze([
        _ExecutableDefinitionsRule.ExecutableDefinitionsRule,
        _UniqueOperationNamesRule.UniqueOperationNamesRule,
        _LoneAnonymousOperationRule.LoneAnonymousOperationRule,
        _SingleFieldSubscriptionsRule.SingleFieldSubscriptionsRule,
        _KnownTypeNamesRule.KnownTypeNamesRule,
        _FragmentsOnCompositeTypesRule.FragmentsOnCompositeTypesRule,
        _VariablesAreInputTypesRule.VariablesAreInputTypesRule,
        _ScalarLeafsRule.ScalarLeafsRule,
        _FieldsOnCorrectTypeRule.FieldsOnCorrectTypeRule,
        _UniqueFragmentNamesRule.UniqueFragmentNamesRule,
        _KnownFragmentNamesRule.KnownFragmentNamesRule,
        _NoUnusedFragmentsRule.NoUnusedFragmentsRule,
        _PossibleFragmentSpreadsRule.PossibleFragmentSpreadsRule,
        _NoFragmentCyclesRule.NoFragmentCyclesRule,
        _UniqueVariableNamesRule.UniqueVariableNamesRule,
        _NoUndefinedVariablesRule.NoUndefinedVariablesRule,
        _NoUnusedVariablesRule.NoUnusedVariablesRule,
        _KnownDirectivesRule.KnownDirectivesRule,
        _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
        _KnownArgumentNamesRule.KnownArgumentNamesRule,
        _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
        _ValuesOfCorrectTypeRule.ValuesOfCorrectTypeRule,
        _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsRule,
        _VariablesInAllowedPositionRule.VariablesInAllowedPositionRule,
        _OverlappingFieldsCanBeMergedRule.OverlappingFieldsCanBeMergedRule,
        _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule
      ]);
      exports2.specifiedRules = specifiedRules2;
      var specifiedSDLRules2 = Object.freeze([
        _LoneSchemaDefinitionRule.LoneSchemaDefinitionRule,
        _UniqueOperationTypesRule.UniqueOperationTypesRule,
        _UniqueTypeNamesRule.UniqueTypeNamesRule,
        _UniqueEnumValueNamesRule.UniqueEnumValueNamesRule,
        _UniqueFieldDefinitionNamesRule.UniqueFieldDefinitionNamesRule,
        _UniqueArgumentDefinitionNamesRule.UniqueArgumentDefinitionNamesRule,
        _UniqueDirectiveNamesRule.UniqueDirectiveNamesRule,
        _KnownTypeNamesRule.KnownTypeNamesRule,
        _KnownDirectivesRule.KnownDirectivesRule,
        _UniqueDirectivesPerLocationRule.UniqueDirectivesPerLocationRule,
        _PossibleTypeExtensionsRule.PossibleTypeExtensionsRule,
        _KnownArgumentNamesRule.KnownArgumentNamesOnDirectivesRule,
        _UniqueArgumentNamesRule.UniqueArgumentNamesRule,
        _UniqueInputFieldNamesRule.UniqueInputFieldNamesRule,
        _ProvidedRequiredArgumentsRule.ProvidedRequiredArgumentsOnDirectivesRule
      ]);
      exports2.specifiedSDLRules = specifiedSDLRules2;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/ValidationContext.js
  var require_ValidationContext = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/ValidationContext.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.ValidationContext = exports2.SDLValidationContext = exports2.ASTValidationContext = void 0;
      var _kinds = require_kinds();
      var _visitor = require_visitor();
      var _TypeInfo = require_TypeInfo();
      var ASTValidationContext2 = class {
        constructor(ast, onError) {
          this._ast = ast;
          this._fragments = void 0;
          this._fragmentSpreads = /* @__PURE__ */ new Map();
          this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
          this._onError = onError;
        }
        get [Symbol.toStringTag]() {
          return "ASTValidationContext";
        }
        reportError(error) {
          this._onError(error);
        }
        getDocument() {
          return this._ast;
        }
        getFragment(name2) {
          let fragments;
          if (this._fragments) {
            fragments = this._fragments;
          } else {
            fragments = /* @__PURE__ */ Object.create(null);
            for (const defNode of this.getDocument().definitions) {
              if (defNode.kind === _kinds.Kind.FRAGMENT_DEFINITION) {
                fragments[defNode.name.value] = defNode;
              }
            }
            this._fragments = fragments;
          }
          return fragments[name2];
        }
        getFragmentSpreads(node) {
          let spreads = this._fragmentSpreads.get(node);
          if (!spreads) {
            spreads = [];
            const setsToVisit = [node];
            let set;
            while (set = setsToVisit.pop()) {
              for (const selection of set.selections) {
                if (selection.kind === _kinds.Kind.FRAGMENT_SPREAD) {
                  spreads.push(selection);
                } else if (selection.selectionSet) {
                  setsToVisit.push(selection.selectionSet);
                }
              }
            }
            this._fragmentSpreads.set(node, spreads);
          }
          return spreads;
        }
        getRecursivelyReferencedFragments(operation) {
          let fragments = this._recursivelyReferencedFragments.get(operation);
          if (!fragments) {
            fragments = [];
            const collectedNames = /* @__PURE__ */ Object.create(null);
            const nodesToVisit = [operation.selectionSet];
            let node;
            while (node = nodesToVisit.pop()) {
              for (const spread of this.getFragmentSpreads(node)) {
                const fragName = spread.name.value;
                if (collectedNames[fragName] !== true) {
                  collectedNames[fragName] = true;
                  const fragment = this.getFragment(fragName);
                  if (fragment) {
                    fragments.push(fragment);
                    nodesToVisit.push(fragment.selectionSet);
                  }
                }
              }
            }
            this._recursivelyReferencedFragments.set(operation, fragments);
          }
          return fragments;
        }
      };
      exports2.ASTValidationContext = ASTValidationContext2;
      var SDLValidationContext2 = class extends ASTValidationContext2 {
        constructor(ast, schema, onError) {
          super(ast, onError);
          this._schema = schema;
        }
        get [Symbol.toStringTag]() {
          return "SDLValidationContext";
        }
        getSchema() {
          return this._schema;
        }
      };
      exports2.SDLValidationContext = SDLValidationContext2;
      var ValidationContext2 = class extends ASTValidationContext2 {
        constructor(schema, ast, typeInfo, onError) {
          super(ast, onError);
          this._schema = schema;
          this._typeInfo = typeInfo;
          this._variableUsages = /* @__PURE__ */ new Map();
          this._recursiveVariableUsages = /* @__PURE__ */ new Map();
        }
        get [Symbol.toStringTag]() {
          return "ValidationContext";
        }
        getSchema() {
          return this._schema;
        }
        getVariableUsages(node) {
          let usages = this._variableUsages.get(node);
          if (!usages) {
            const newUsages = [];
            const typeInfo = new _TypeInfo.TypeInfo(this._schema);
            (0, _visitor.visit)(
              node,
              (0, _TypeInfo.visitWithTypeInfo)(typeInfo, {
                VariableDefinition: () => false,
                Variable(variable) {
                  newUsages.push({
                    node: variable,
                    type: typeInfo.getInputType(),
                    defaultValue: typeInfo.getDefaultValue()
                  });
                }
              })
            );
            usages = newUsages;
            this._variableUsages.set(node, usages);
          }
          return usages;
        }
        getRecursiveVariableUsages(operation) {
          let usages = this._recursiveVariableUsages.get(operation);
          if (!usages) {
            usages = this.getVariableUsages(operation);
            for (const frag of this.getRecursivelyReferencedFragments(operation)) {
              usages = usages.concat(this.getVariableUsages(frag));
            }
            this._recursiveVariableUsages.set(operation, usages);
          }
          return usages;
        }
        getType() {
          return this._typeInfo.getType();
        }
        getParentType() {
          return this._typeInfo.getParentType();
        }
        getInputType() {
          return this._typeInfo.getInputType();
        }
        getParentInputType() {
          return this._typeInfo.getParentInputType();
        }
        getFieldDef() {
          return this._typeInfo.getFieldDef();
        }
        getDirective() {
          return this._typeInfo.getDirective();
        }
        getArgument() {
          return this._typeInfo.getArgument();
        }
        getEnumValue() {
          return this._typeInfo.getEnumValue();
        }
      };
      exports2.ValidationContext = ValidationContext2;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/validate.js
  var require_validate2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.7.1/node_modules/graphql/validation/validate.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.assertValidSDL = assertValidSDL2;
      exports2.assertValidSDLExtension = assertValidSDLExtension2;
      exports2.validate = validate2;
      exports2.validateSDL = validateSDL2;
      var _devAssert = require_devAssert();
      var _GraphQLError = require_GraphQLError();
      var _visitor = require_visitor();
      var _validate = require_validate();
      var _TypeInfo = require_TypeInfo();
      var _specifiedRules = require_specifiedRules();
      var _ValidationContext = require_ValidationContext();
      function validate2(schema, documentAST, rules = _specifiedRules.specifiedRules, options, typeInfo = new _TypeInfo.TypeInfo(schema)) {
        var _options$maxErrors;
        const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
        documentAST || (0, _devAssert.devAssert)(false, "Must provide document.");
        (0, _validate.assertValidSchema)(schema);
        const abortObj = Object.freeze({});
        const errors = [];
        const context = new _ValidationContext.ValidationContext(
          schema,
          documentAST,
          typeInfo,
          (error) => {
            if (errors.length >= maxErrors) {
              errors.push(
                new _GraphQLError.GraphQLError(
                  "Too many validation errors, error limit reached. Validation aborted."
                )
              );
              throw abortObj;
            }
            errors.push(error);
          }
        );
        const visitor = (0, _visitor.visitInParallel)(
          rules.map((rule) => rule(context))
        );
        try {
          (0, _visitor.visit)(
            documentAST,
            (0, _TypeInfo.visitWithTypeInfo)(typeInfo, visitor)
          );
        } catch (e2) {
          if (e2 !== abortObj) {
            throw e2;
          }
        }
        return errors;
      }
      function validateSDL2(documentAST, schemaToExtend, rules = _specifiedRules.specifiedSDLRules) {
        const errors = [];
        const context = new _ValidationContext.SDLValidationContext(
          documentAST,
          schemaToExtend,
          (error) => {
            errors.push(error);
          }
        );
        const visitors = rules.map((rule) => rule(context));
        (0, _visitor.visit)(documentAST, (0, _visitor.visitInParallel)(visitors));
        return errors;
      }
      function assertValidSDL2(documentAST) {
        const errors = validateSDL2(documentAST);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
      function assertValidSDLExtension2(documentAST, schema) {
        const errors = validateSDL2(documentAST, schema);
        if (errors.length !== 0) {
          throw new Error(errors.map((error) => error.message).join("\n\n"));
        }
      }
    }
  });

  // ../../composition/dist/buildASTSchema/extendSchema.js
  var require_extendSchema = __commonJS({
    "../../composition/dist/buildASTSchema/extendSchema.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.extendSchemaImpl = exports2.mapValue = exports2.AccumulatorMap = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var AccumulatorMap = class extends Map {
        get [Symbol.toStringTag]() {
          return "AccumulatorMap";
        }
        add(key, item) {
          const group = this.get(key);
          if (group === void 0) {
            this.set(key, [item]);
          } else {
            group.push(item);
          }
        }
      };
      exports2.AccumulatorMap = AccumulatorMap;
      function mapValue2(map, fn) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key of Object.keys(map)) {
          result[key] = fn(map[key], key);
        }
        return result;
      }
      exports2.mapValue = mapValue2;
      function extendSchemaImpl2(schemaConfig, documentAST, options) {
        var _a, _b, _c, _d;
        const typeDefs = [];
        const scalarExtensions = new AccumulatorMap();
        const objectExtensions = new AccumulatorMap();
        const interfaceExtensions = new AccumulatorMap();
        const unionExtensions = new AccumulatorMap();
        const enumExtensions = new AccumulatorMap();
        const inputObjectExtensions = new AccumulatorMap();
        const directiveDefs = [];
        let schemaDef;
        const schemaExtensions = [];
        let isSchemaChanged = false;
        for (const def of documentAST.definitions) {
          switch (def.kind) {
            case graphql_1.Kind.SCHEMA_DEFINITION:
              schemaDef = def;
              break;
            case graphql_1.Kind.SCHEMA_EXTENSION:
              schemaExtensions.push(def);
              break;
            case graphql_1.Kind.DIRECTIVE_DEFINITION:
              directiveDefs.push(def);
              break;
            case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
            case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
            case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
            case graphql_1.Kind.UNION_TYPE_DEFINITION:
            case graphql_1.Kind.ENUM_TYPE_DEFINITION:
            case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
              typeDefs.push(def);
              break;
            case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
              scalarExtensions.add(def.name.value, def);
              break;
            case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
              objectExtensions.add(def.name.value, def);
              break;
            case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
              interfaceExtensions.add(def.name.value, def);
              break;
            case graphql_1.Kind.UNION_TYPE_EXTENSION:
              unionExtensions.add(def.name.value, def);
              break;
            case graphql_1.Kind.ENUM_TYPE_EXTENSION:
              enumExtensions.add(def.name.value, def);
              break;
            case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
              inputObjectExtensions.add(def.name.value, def);
              break;
            default:
              continue;
          }
          isSchemaChanged = true;
        }
        if (!isSchemaChanged) {
          return schemaConfig;
        }
        const typeMap = /* @__PURE__ */ new Map();
        for (const type of schemaConfig.types) {
          const graphQLNamedType = extendNamedType(type);
          if (graphQLNamedType) {
            typeMap.set(type.name, graphQLNamedType);
          }
        }
        for (const typeNode of typeDefs) {
          const name2 = typeNode.name.value;
          typeMap.set(name2, (_a = stdTypeMap2.get(name2)) != null ? _a : buildType(typeNode));
        }
        for (const [name2, extensionASTNodes] of objectExtensions) {
          typeMap.set(name2, new graphql_1.GraphQLObjectType({
            name: name2,
            interfaces: () => buildInterfaces(extensionASTNodes),
            fields: () => buildFieldMap(extensionASTNodes),
            extensionASTNodes
          }));
        }
        if (options == null ? void 0 : options.addInvalidExtensionOrphans) {
          for (const [name2, extensionASTNodes] of interfaceExtensions) {
            typeMap.set(name2, new graphql_1.GraphQLInterfaceType({
              name: name2,
              interfaces: () => buildInterfaces(extensionASTNodes),
              fields: () => buildFieldMap(extensionASTNodes),
              extensionASTNodes
            }));
          }
          for (const [name2, extensionASTNodes] of enumExtensions) {
            typeMap.set(name2, new graphql_1.GraphQLEnumType({
              name: name2,
              values: buildEnumValueMap(extensionASTNodes),
              extensionASTNodes
            }));
          }
          for (const [name2, extensionASTNodes] of unionExtensions) {
            typeMap.set(name2, new graphql_1.GraphQLUnionType({
              name: name2,
              types: () => buildUnionTypes(extensionASTNodes),
              extensionASTNodes
            }));
          }
          for (const [name2, extensionASTNodes] of scalarExtensions) {
            typeMap.set(name2, new graphql_1.GraphQLScalarType({
              name: name2,
              extensionASTNodes
            }));
          }
          for (const [name2, extensionASTNodes] of inputObjectExtensions) {
            typeMap.set(name2, new graphql_1.GraphQLInputObjectType({
              name: name2,
              fields: () => buildInputFieldMap(extensionASTNodes),
              extensionASTNodes
            }));
          }
        }
        const operationTypes = __spreadValues(__spreadValues({
          // Get the extended root operation types.
          query: schemaConfig.query && replaceNamedType(schemaConfig.query),
          mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
          subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)
        }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions));
        return __spreadProps(__spreadValues({
          description: (_c = (_b = schemaDef == null ? void 0 : schemaDef.description) == null ? void 0 : _b.value) != null ? _c : schemaConfig.description
        }, operationTypes), {
          types: Array.from(typeMap.values()),
          directives: [...schemaConfig.directives.map(replaceDirective), ...directiveDefs.map(buildDirective)],
          extensions: schemaConfig.extensions,
          astNode: schemaDef != null ? schemaDef : schemaConfig.astNode,
          extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
          assumeValid: (_d = options == null ? void 0 : options.assumeValid) != null ? _d : false
        });
        function replaceType(type) {
          if ((0, graphql_1.isListType)(type)) {
            return new graphql_1.GraphQLList(replaceType(type.ofType));
          }
          if ((0, graphql_1.isNonNullType)(type)) {
            return new graphql_1.GraphQLNonNull(replaceType(type.ofType));
          }
          return replaceNamedType(type);
        }
        function replaceNamedType(type) {
          return typeMap.get(type.name);
        }
        function replaceDirective(directive) {
          if ((0, graphql_1.isSpecifiedDirective)(directive)) {
            return directive;
          }
          const config2 = directive.toConfig();
          return new graphql_1.GraphQLDirective(__spreadProps(__spreadValues({}, config2), {
            args: mapValue2(config2.args, extendArg)
          }));
        }
        function extendNamedType(type) {
          if ((0, graphql_1.isIntrospectionType)(type) || (0, graphql_1.isSpecifiedScalarType)(type)) {
            return type;
          }
          if ((0, graphql_1.isScalarType)(type)) {
            return extendScalarType(type);
          }
          if ((0, graphql_1.isObjectType)(type)) {
            return extendObjectType(type);
          }
          if ((0, graphql_1.isInterfaceType)(type)) {
            return extendInterfaceType(type);
          }
          if ((0, graphql_1.isUnionType)(type)) {
            return extendUnionType(type);
          }
          if ((0, graphql_1.isEnumType)(type)) {
            return extendEnumType(type);
          }
          if ((0, graphql_1.isInputObjectType)(type)) {
            return extendInputObjectType(type);
          }
        }
        function extendInputObjectType(type) {
          var _a2;
          const config2 = type.toConfig();
          const extensions = (_a2 = inputObjectExtensions.get(config2.name)) != null ? _a2 : [];
          return new graphql_1.GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {
            fields: () => __spreadValues(__spreadValues({}, mapValue2(config2.fields, (field) => __spreadProps(__spreadValues({}, field), {
              type: replaceType(field.type)
            }))), buildInputFieldMap(extensions)),
            extensionASTNodes: config2.extensionASTNodes.concat(extensions)
          }));
        }
        function extendEnumType(type) {
          var _a2;
          const config2 = type.toConfig();
          const extensions = (_a2 = enumExtensions.get(type.name)) != null ? _a2 : [];
          return new graphql_1.GraphQLEnumType(__spreadProps(__spreadValues({}, config2), {
            values: __spreadValues(__spreadValues({}, config2.values), buildEnumValueMap(extensions)),
            extensionASTNodes: config2.extensionASTNodes.concat(extensions)
          }));
        }
        function extendScalarType(type) {
          var _a2, _b2;
          const config2 = type.toConfig();
          const extensions = (_a2 = scalarExtensions.get(config2.name)) != null ? _a2 : [];
          let specifiedByURL = config2.specifiedByURL;
          for (const extensionNode of extensions) {
            specifiedByURL = (_b2 = getSpecifiedByURL2(extensionNode)) != null ? _b2 : specifiedByURL;
          }
          return new graphql_1.GraphQLScalarType(__spreadProps(__spreadValues({}, config2), {
            specifiedByURL,
            extensionASTNodes: config2.extensionASTNodes.concat(extensions)
          }));
        }
        function extendObjectType(type) {
          var _a2;
          const config2 = type.toConfig();
          const extensions = (_a2 = objectExtensions.get(config2.name)) != null ? _a2 : [];
          return new graphql_1.GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
            interfaces: () => [...type.getInterfaces().map(replaceNamedType), ...buildInterfaces(extensions)],
            fields: () => __spreadValues(__spreadValues({}, mapValue2(config2.fields, extendField)), buildFieldMap(extensions)),
            extensionASTNodes: config2.extensionASTNodes.concat(extensions)
          }));
        }
        function extendInterfaceType(type) {
          var _a2;
          const config2 = type.toConfig();
          const extensions = (_a2 = interfaceExtensions.get(config2.name)) != null ? _a2 : [];
          return new graphql_1.GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {
            interfaces: () => [...type.getInterfaces().map(replaceNamedType), ...buildInterfaces(extensions)],
            fields: () => __spreadValues(__spreadValues({}, mapValue2(config2.fields, extendField)), buildFieldMap(extensions)),
            extensionASTNodes: config2.extensionASTNodes.concat(extensions)
          }));
        }
        function extendUnionType(type) {
          var _a2;
          const config2 = type.toConfig();
          const extensions = (_a2 = unionExtensions.get(config2.name)) != null ? _a2 : [];
          return new graphql_1.GraphQLUnionType(__spreadProps(__spreadValues({}, config2), {
            types: () => [...type.getTypes().map(replaceNamedType), ...buildUnionTypes(extensions)],
            extensionASTNodes: config2.extensionASTNodes.concat(extensions)
          }));
        }
        function extendField(field) {
          return __spreadProps(__spreadValues({}, field), {
            type: replaceType(field.type),
            args: field.args && mapValue2(field.args, extendArg)
          });
        }
        function extendArg(arg) {
          return __spreadProps(__spreadValues({}, arg), {
            type: replaceType(arg.type)
          });
        }
        function getOperationTypes(nodes) {
          var _a2;
          const opTypes = {};
          for (const node of nodes) {
            const operationTypesNodes = (
              /* c8 ignore next */
              (_a2 = node.operationTypes) != null ? _a2 : []
            );
            for (const operationType of operationTypesNodes) {
              opTypes[operationType.operation] = getNamedType2(operationType.type);
            }
          }
          return opTypes;
        }
        function getNamedType2(node) {
          var _a2;
          const name2 = node.name.value;
          const type = (_a2 = stdTypeMap2.get(name2)) != null ? _a2 : typeMap.get(name2);
          if (type === void 0) {
            throw new Error(`Unknown type: "${name2}".`);
          }
          return type;
        }
        function getWrappedType(node) {
          if (node.kind === graphql_1.Kind.LIST_TYPE) {
            return new graphql_1.GraphQLList(getWrappedType(node.type));
          }
          if (node.kind === graphql_1.Kind.NON_NULL_TYPE) {
            return new graphql_1.GraphQLNonNull(getWrappedType(node.type));
          }
          return getNamedType2(node);
        }
        function buildDirective(node) {
          var _a2;
          return new graphql_1.GraphQLDirective({
            name: node.name.value,
            description: (_a2 = node.description) == null ? void 0 : _a2.value,
            // @ts-expect-error
            locations: node.locations.map(({ value }) => value),
            isRepeatable: node.repeatable,
            args: buildArgumentMap(node.arguments),
            astNode: node
          });
        }
        function buildFieldMap(nodes) {
          var _a2, _b2;
          const fieldConfigMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            const nodeFields = (
              /* c8 ignore next */
              (_a2 = node.fields) != null ? _a2 : []
            );
            for (const field of nodeFields) {
              fieldConfigMap[field.name.value] = {
                // Note: While this could make assertions to get the correctly typed
                // value, that would throw immediately while type system validation
                // with validateSchema() will produce more actionable results.
                type: getWrappedType(field.type),
                description: (_b2 = field.description) == null ? void 0 : _b2.value,
                args: buildArgumentMap(field.arguments),
                deprecationReason: getDeprecationReason2(field),
                astNode: field
              };
            }
          }
          return fieldConfigMap;
        }
        function buildArgumentMap(args) {
          var _a2;
          const argsNodes = (
            /* c8 ignore next */
            args != null ? args : []
          );
          const argConfigMap = /* @__PURE__ */ Object.create(null);
          for (const arg of argsNodes) {
            const type = getWrappedType(arg.type);
            argConfigMap[arg.name.value] = {
              type,
              description: (_a2 = arg.description) == null ? void 0 : _a2.value,
              defaultValue: (0, graphql_1.valueFromAST)(arg.defaultValue, type),
              deprecationReason: getDeprecationReason2(arg),
              astNode: arg
            };
          }
          return argConfigMap;
        }
        function buildInputFieldMap(nodes) {
          var _a2, _b2;
          const inputFieldMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            const fieldsNodes = (
              /* c8 ignore next */
              (_a2 = node.fields) != null ? _a2 : []
            );
            for (const field of fieldsNodes) {
              const type = getWrappedType(field.type);
              inputFieldMap[field.name.value] = {
                type,
                description: (_b2 = field.description) == null ? void 0 : _b2.value,
                defaultValue: (0, graphql_1.valueFromAST)(field.defaultValue, type),
                deprecationReason: getDeprecationReason2(field),
                astNode: field
              };
            }
          }
          return inputFieldMap;
        }
        function buildEnumValueMap(nodes) {
          var _a2, _b2;
          const enumValueMap = /* @__PURE__ */ Object.create(null);
          for (const node of nodes) {
            const valuesNodes = (
              /* c8 ignore next */
              (_a2 = node.values) != null ? _a2 : []
            );
            for (const value of valuesNodes) {
              enumValueMap[value.name.value] = {
                description: (_b2 = value.description) == null ? void 0 : _b2.value,
                deprecationReason: getDeprecationReason2(value),
                astNode: value
              };
            }
          }
          return enumValueMap;
        }
        function buildInterfaces(nodes) {
          return nodes.flatMap(
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            (node) => {
              var _a2, _b2;
              return (
                /* c8 ignore next */
                (_b2 = (_a2 = node.interfaces) == null ? void 0 : _a2.map(getNamedType2)) != null ? _b2 : []
              );
            }
          );
        }
        function buildUnionTypes(nodes) {
          return nodes.flatMap(
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            (node) => {
              var _a2, _b2;
              return (
                /* c8 ignore next */
                (_b2 = (_a2 = node.types) == null ? void 0 : _a2.map(getNamedType2)) != null ? _b2 : []
              );
            }
          );
        }
        function buildType(astNode) {
          var _a2, _b2, _c2, _d2, _e, _f, _g, _h, _i, _j, _k, _l;
          const name2 = astNode.name.value;
          switch (astNode.kind) {
            case graphql_1.Kind.OBJECT_TYPE_DEFINITION: {
              const extensionASTNodes = (_a2 = objectExtensions.get(name2)) != null ? _a2 : [];
              const allNodes = [astNode, ...extensionASTNodes];
              objectExtensions.delete(name2);
              return new graphql_1.GraphQLObjectType({
                name: name2,
                description: (_b2 = astNode.description) == null ? void 0 : _b2.value,
                interfaces: () => buildInterfaces(allNodes),
                fields: () => buildFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case graphql_1.Kind.INTERFACE_TYPE_DEFINITION: {
              const extensionASTNodes = (_c2 = interfaceExtensions.get(name2)) != null ? _c2 : [];
              const allNodes = [astNode, ...extensionASTNodes];
              interfaceExtensions.delete(name2);
              return new graphql_1.GraphQLInterfaceType({
                name: name2,
                description: (_d2 = astNode.description) == null ? void 0 : _d2.value,
                interfaces: () => buildInterfaces(allNodes),
                fields: () => buildFieldMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case graphql_1.Kind.ENUM_TYPE_DEFINITION: {
              const extensionASTNodes = (_e = enumExtensions.get(name2)) != null ? _e : [];
              const allNodes = [astNode, ...extensionASTNodes];
              enumExtensions.delete(name2);
              return new graphql_1.GraphQLEnumType({
                name: name2,
                description: (_f = astNode.description) == null ? void 0 : _f.value,
                values: buildEnumValueMap(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case graphql_1.Kind.UNION_TYPE_DEFINITION: {
              const extensionASTNodes = (_g = unionExtensions.get(name2)) != null ? _g : [];
              const allNodes = [astNode, ...extensionASTNodes];
              unionExtensions.delete(name2);
              return new graphql_1.GraphQLUnionType({
                name: name2,
                description: (_h = astNode.description) == null ? void 0 : _h.value,
                types: () => buildUnionTypes(allNodes),
                astNode,
                extensionASTNodes
              });
            }
            case graphql_1.Kind.SCALAR_TYPE_DEFINITION: {
              const extensionASTNodes = (_i = scalarExtensions.get(name2)) != null ? _i : [];
              scalarExtensions.delete(name2);
              return new graphql_1.GraphQLScalarType({
                name: name2,
                description: (_j = astNode.description) == null ? void 0 : _j.value,
                specifiedByURL: getSpecifiedByURL2(astNode),
                astNode,
                extensionASTNodes
              });
            }
            case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
              const extensionASTNodes = (_k = inputObjectExtensions.get(name2)) != null ? _k : [];
              const allNodes = [astNode, ...extensionASTNodes];
              inputObjectExtensions.delete(name2);
              return new graphql_1.GraphQLInputObjectType({
                name: name2,
                description: (_l = astNode.description) == null ? void 0 : _l.value,
                fields: () => buildInputFieldMap(allNodes),
                astNode,
                extensionASTNodes
                //   isOneOf: isOneOf(astNode),
              });
            }
          }
        }
      }
      exports2.extendSchemaImpl = extendSchemaImpl2;
      var stdTypeMap2 = new Map([...graphql_1.specifiedScalarTypes, ...graphql_1.introspectionTypes].map((type) => [type.name, type]));
      function getDeprecationReason2(node) {
        const deprecated = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLDeprecatedDirective, node);
        return deprecated == null ? void 0 : deprecated.reason;
      }
      function getSpecifiedByURL2(node) {
        const specifiedBy = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSpecifiedByDirective, node);
        return specifiedBy == null ? void 0 : specifiedBy.url;
      }
    }
  });

  // ../../composition/dist/buildASTSchema/buildASTSchema.js
  var require_buildASTSchema = __commonJS({
    "../../composition/dist/buildASTSchema/buildASTSchema.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.buildASTSchema = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var validate_1 = require_validate2();
      var extendSchema_1 = require_extendSchema();
      function buildASTSchema2(documentAST, options) {
        if ((options == null ? void 0 : options.assumeValid) !== true && (options == null ? void 0 : options.assumeValidSDL) !== true) {
          (0, validate_1.assertValidSDL)(documentAST);
        }
        const emptySchemaConfig = {
          description: void 0,
          types: [],
          directives: [],
          extensions: /* @__PURE__ */ Object.create(null),
          extensionASTNodes: [],
          assumeValid: false
        };
        const config2 = (0, extendSchema_1.extendSchemaImpl)(emptySchemaConfig, documentAST, options);
        if (config2.astNode == null) {
          for (const type of config2.types) {
            switch (type.name) {
              case "Query":
                config2.query = type;
                break;
              case "Mutation":
                config2.mutation = type;
                break;
              case "Subscription":
                config2.subscription = type;
                break;
            }
          }
        }
        const directives = [
          ...config2.directives,
          // If specified directives were not explicitly declared, add them.
          ...graphql_1.specifiedDirectives.filter((stdDirective) => config2.directives.every((directive) => directive.name !== stdDirective.name))
        ];
        return new graphql_1.GraphQLSchema(__spreadProps(__spreadValues({}, config2), { directives }));
      }
      exports2.buildASTSchema = buildASTSchema2;
    }
  });

  // ../../node_modules/.pnpm/tslib@2.6.1/node_modules/tslib/tslib.es6.mjs
  var tslib_es6_exports = {};
  __export(tslib_es6_exports, {
    __addDisposableResource: () => __addDisposableResource,
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet,
    __classPrivateFieldIn: () => __classPrivateFieldIn,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __disposeResources: () => __disposeResources,
    __esDecorate: () => __esDecorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __propKey: () => __propKey,
    __read: () => __read,
    __rest: () => __rest,
    __runInitializers: () => __runInitializers,
    __setFunctionName: () => __setFunctionName,
    __spread: () => __spread,
    __spreadArray: () => __spreadArray,
    __spreadArrays: () => __spreadArrays,
    __values: () => __values,
    default: () => tslib_es6_default
  });
  function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __rest(s2, e2) {
    var t2 = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t2[p2[i2]] = s2[p2[i2]];
      }
    return t2;
  }
  function __decorate(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d = decorators[i2])
          r2 = (c2 < 3 ? d(r2) : c2 > 3 ? d(target, key, r2) : d(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f2) {
      if (f2 !== void 0 && typeof f2 !== "function")
        throw new TypeError("Function expected");
      return f2;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
      var context = {};
      for (var p2 in contextIn)
        context[p2] = p2 === "access" ? {} : contextIn[p2];
      for (var p2 in contextIn.access)
        context.access[p2] = contextIn.access[p2];
      context.addInitializer = function(f2) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f2 || null));
      };
      var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_ = accept(result.get))
          descriptor.get = _;
        if (_ = accept(result.set))
          descriptor.set = _;
        if (_ = accept(result.init))
          initializers.unshift(_);
      } else if (_ = accept(result)) {
        if (kind === "field")
          initializers.unshift(_);
        else
          descriptor[key] = _;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  }
  function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i2 = 0; i2 < initializers.length; i2++) {
      value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
    }
    return useValue ? value : void 0;
  }
  function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
  }
  function __setFunctionName(f2, name2, prefix) {
    if (typeof name2 === "symbol")
      name2 = name2.description ? "[".concat(name2.description, "]") : "";
    return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y2, t2, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n2) {
      return function(v2) {
        return step([n2, v2]);
      };
    }
    function step(op) {
      if (f2)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e2) {
          op = [6, e2];
          y2 = 0;
        } finally {
          f2 = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __exportStar(m, o2) {
    for (var p2 in m)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
        __createBinding(o2, m, p2);
  }
  function __values(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o2[s2], i2 = 0;
    if (m)
      return m.call(o2);
    if (o2 && typeof o2.length === "number")
      return {
        next: function() {
          if (o2 && i2 >= o2.length)
            o2 = void 0;
          return { value: o2 && o2[i2++], done: !o2 };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o2, n2) {
    var m = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m)
      return o2;
    var i2 = m.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
      ar = ar.concat(__read(arguments[i2]));
    return ar;
  }
  function __spreadArrays() {
    for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
      s2 += arguments[i2].length;
    for (var r2 = Array(s2), k = 0, i2 = 0; i2 < il; i2++)
      for (var a2 = arguments[i2], j = 0, jl = a2.length; j < jl; j++, k++)
        r2[k] = a2[j];
    return r2;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
        if (ar || !(i2 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i2);
          ar[i2] = from[i2];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __await(v2) {
    return this instanceof __await ? (this.v = v2, this) : new __await(v2);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n2) {
      if (g[n2])
        i2[n2] = function(v2) {
          return new Promise(function(a2, b) {
            q.push([n2, v2, a2, b]) > 1 || resume(n2, v2);
          });
        };
    }
    function resume(n2, v2) {
      try {
        step(g[n2](v2));
      } catch (e2) {
        settle(q[0][3], e2);
      }
    }
    function step(r2) {
      r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f2, v2) {
      if (f2(v2), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o2) {
    var i2, p2;
    return i2 = {}, verb("next"), verb("throw", function(e2) {
      throw e2;
    }), verb("return"), i2[Symbol.iterator] = function() {
      return this;
    }, i2;
    function verb(n2, f2) {
      i2[n2] = o2[n2] ? function(v2) {
        return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: false } : f2 ? f2(v2) : v2;
      } : f2;
    }
  }
  function __asyncValues(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o2[Symbol.asyncIterator], i2;
    return m ? m.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, state, kind, f2) {
    if (kind === "a" && !f2)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f2) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f2)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
  }
  function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
      throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
  }
  function __addDisposableResource(env2, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env2.stack.push({ value, dispose, async });
    } else if (async) {
      env2.stack.push({ async: true });
    }
    return value;
  }
  function __disposeResources(env2) {
    function fail(e2) {
      env2.error = env2.hasError ? new _SuppressedError(e2, env2.error, "An error was suppressed during disposal.") : e2;
      env2.hasError = true;
    }
    function next() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async)
            return Promise.resolve(result).then(next, function(e2) {
              fail(e2);
              return next();
            });
        } catch (e2) {
          fail(e2);
        }
      }
      if (env2.hasError)
        throw env2.error;
    }
    return next();
  }
  var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
  var init_tslib_es6 = __esm({
    "../../node_modules/.pnpm/tslib@2.6.1/node_modules/tslib/tslib.es6.mjs"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p2 in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p2))
              d2[p2] = b2[p2];
        };
        return extendStatics(d, b);
      };
      __assign = function() {
        __assign = Object.assign || function __assign2(t2) {
          for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
            s2 = arguments[i2];
            for (var p2 in s2)
              if (Object.prototype.hasOwnProperty.call(s2, p2))
                t2[p2] = s2[p2];
          }
          return t2;
        };
        return __assign.apply(this, arguments);
      };
      __createBinding = Object.create ? function(o2, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o2, k2, desc);
      } : function(o2, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o2[k2] = m[k];
      };
      __setModuleDefault = Object.create ? function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      } : function(o2, v2) {
        o2["default"] = v2;
      };
      _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e2 = new Error(message);
        return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
      };
      tslib_es6_default = {
        __extends,
        __assign,
        __rest,
        __decorate,
        __param,
        __metadata,
        __awaiter,
        __generator,
        __createBinding,
        __exportStar,
        __values,
        __read,
        __spread,
        __spreadArrays,
        __spreadArray,
        __await,
        __asyncGenerator,
        __asyncDelegator,
        __asyncValues,
        __makeTemplateObject,
        __importStar,
        __importDefault,
        __classPrivateFieldGet,
        __classPrivateFieldSet,
        __classPrivateFieldIn,
        __addDisposableResource,
        __disposeResources
      };
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/loaders.js
  var require_loaders = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/loaders.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/helpers.js
  var require_helpers = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/helpers.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.assertSome = exports2.isSome = exports2.compareNodes = exports2.nodeToString = exports2.compareStrings = exports2.isValidPath = exports2.isDocumentString = exports2.asArray = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
      exports2.asArray = asArray;
      var invalidDocRegex = /\.[a-z0-9]+$/i;
      function isDocumentString(str) {
        if (typeof str !== "string") {
          return false;
        }
        if (invalidDocRegex.test(str)) {
          return false;
        }
        try {
          (0, graphql_1.parse)(str);
          return true;
        } catch (e2) {
        }
        return false;
      }
      exports2.isDocumentString = isDocumentString;
      var invalidPathRegex = /[‘“!%^<=>`]/;
      function isValidPath(str) {
        return typeof str === "string" && !invalidPathRegex.test(str);
      }
      exports2.isValidPath = isValidPath;
      function compareStrings(a2, b) {
        if (String(a2) < String(b)) {
          return -1;
        }
        if (String(a2) > String(b)) {
          return 1;
        }
        return 0;
      }
      exports2.compareStrings = compareStrings;
      function nodeToString(a2) {
        var _a, _b;
        let name2;
        if ("alias" in a2) {
          name2 = (_a = a2.alias) == null ? void 0 : _a.value;
        }
        if (name2 == null && "name" in a2) {
          name2 = (_b = a2.name) == null ? void 0 : _b.value;
        }
        if (name2 == null) {
          name2 = a2.kind;
        }
        return name2;
      }
      exports2.nodeToString = nodeToString;
      function compareNodes(a2, b, customFn) {
        const aStr = nodeToString(a2);
        const bStr = nodeToString(b);
        if (typeof customFn === "function") {
          return customFn(aStr, bStr);
        }
        return compareStrings(aStr, bStr);
      }
      exports2.compareNodes = compareNodes;
      function isSome(input) {
        return input != null;
      }
      exports2.isSome = isSome;
      function assertSome(input, message = "Value should be something") {
        if (input == null) {
          throw new Error(message);
        }
      }
      exports2.assertSome = assertSome;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/jsutils.js
  var require_jsutils = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/jsutils.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hasOwnProperty = exports2.promiseReduce = exports2.isPromise = exports2.isObjectLike = exports2.isIterableObject = void 0;
      function isIterableObject2(value) {
        return value != null && typeof value === "object" && Symbol.iterator in value;
      }
      exports2.isIterableObject = isIterableObject2;
      function isObjectLike2(value) {
        return typeof value === "object" && value !== null;
      }
      exports2.isObjectLike = isObjectLike2;
      function isPromise2(value) {
        return isObjectLike2(value) && typeof value["then"] === "function";
      }
      exports2.isPromise = isPromise2;
      function promiseReduce2(values, callbackFn, initialValue) {
        let accumulator = initialValue;
        for (const value of values) {
          accumulator = isPromise2(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
        }
        return accumulator;
      }
      exports2.promiseReduce = promiseReduce2;
      function hasOwnProperty2(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      exports2.hasOwnProperty = hasOwnProperty2;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/errors.js
  var require_errors2 = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/errors.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.relocatedError = exports2.createGraphQLError = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function createGraphQLError(message, options) {
        if (graphql_1.versionInfo.major >= 17) {
          return new graphql_1.GraphQLError(message, options);
        }
        return new graphql_1.GraphQLError(message, options == null ? void 0 : options.nodes, options == null ? void 0 : options.source, options == null ? void 0 : options.positions, options == null ? void 0 : options.path, options == null ? void 0 : options.originalError, options == null ? void 0 : options.extensions);
      }
      exports2.createGraphQLError = createGraphQLError;
      function relocatedError(originalError, path) {
        return createGraphQLError(originalError.message, {
          nodes: originalError.nodes,
          source: originalError.source,
          positions: originalError.positions,
          path: path == null ? originalError.path : path,
          originalError,
          extensions: originalError.extensions
        });
      }
      exports2.relocatedError = relocatedError;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/inspect.js
  var require_inspect2 = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/inspect.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.inspect = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var MAX_RECURSIVE_DEPTH2 = 3;
      function inspect2(value) {
        return formatValue2(value, []);
      }
      exports2.inspect = inspect2;
      function formatValue2(value, seenValues) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(value);
          case "function":
            return value.name ? `[function ${value.name}]` : "[function]";
          case "object":
            return formatObjectValue2(value, seenValues);
          default:
            return String(value);
        }
      }
      function formatError2(value) {
        if (value instanceof graphql_1.GraphQLError) {
          return value.toString();
        }
        return `${value.name}: ${value.message};
 ${value.stack}`;
      }
      function formatObjectValue2(value, previouslySeenValues) {
        if (value === null) {
          return "null";
        }
        if (value instanceof Error) {
          if (value.name === "AggregateError") {
            return formatError2(value) + "\n" + formatArray2(value.errors, previouslySeenValues);
          }
          return formatError2(value);
        }
        if (previouslySeenValues.includes(value)) {
          return "[Circular]";
        }
        const seenValues = [...previouslySeenValues, value];
        if (isJSONable2(value)) {
          const jsonValue = value.toJSON();
          if (jsonValue !== value) {
            return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
          }
        } else if (Array.isArray(value)) {
          return formatArray2(value, seenValues);
        }
        return formatObject2(value, seenValues);
      }
      function isJSONable2(value) {
        return typeof value.toJSON === "function";
      }
      function formatObject2(object, seenValues) {
        const entries = Object.entries(object);
        if (entries.length === 0) {
          return "{}";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
          return "[" + getObjectTag2(object) + "]";
        }
        const properties = entries.map(([key, value]) => key + ": " + formatValue2(value, seenValues));
        return "{ " + properties.join(", ") + " }";
      }
      function formatArray2(array, seenValues) {
        if (array.length === 0) {
          return "[]";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
          return "[Array]";
        }
        const len = array.length;
        const items = [];
        for (let i2 = 0; i2 < len; ++i2) {
          items.push(formatValue2(array[i2], seenValues));
        }
        return "[" + items.join(", ") + "]";
      }
      function getObjectTag2(object) {
        const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
        if (tag === "Object" && typeof object.constructor === "function") {
          const name2 = object.constructor.name;
          if (typeof name2 === "string" && name2 !== "") {
            return name2;
          }
        }
        return tag;
      }
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js
  var require_getArgumentValues = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/getArgumentValues.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getArgumentValues = void 0;
      var jsutils_js_1 = require_jsutils();
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var errors_js_1 = require_errors2();
      var inspect_js_1 = require_inspect2();
      function getArgumentValues2(def, node, variableValues = {}) {
        var _a;
        const coercedValues = {};
        const argumentNodes = (_a = node.arguments) != null ? _a : [];
        const argNodeMap = argumentNodes.reduce((prev, arg) => __spreadProps(__spreadValues({}, prev), {
          [arg.name.value]: arg
        }), {});
        for (const { name: name2, type: argType, defaultValue } of def.args) {
          const argumentNode = argNodeMap[name2];
          if (!argumentNode) {
            if (defaultValue !== void 0) {
              coercedValues[name2] = defaultValue;
            } else if ((0, graphql_1.isNonNullType)(argType)) {
              throw (0, errors_js_1.createGraphQLError)(`Argument "${name2}" of required type "${(0, inspect_js_1.inspect)(argType)}" was not provided.`, {
                nodes: [node]
              });
            }
            continue;
          }
          const valueNode = argumentNode.value;
          let isNull = valueNode.kind === graphql_1.Kind.NULL;
          if (valueNode.kind === graphql_1.Kind.VARIABLE) {
            const variableName = valueNode.name.value;
            if (variableValues == null || !(0, jsutils_js_1.hasOwnProperty)(variableValues, variableName)) {
              if (defaultValue !== void 0) {
                coercedValues[name2] = defaultValue;
              } else if ((0, graphql_1.isNonNullType)(argType)) {
                throw (0, errors_js_1.createGraphQLError)(`Argument "${name2}" of required type "${(0, inspect_js_1.inspect)(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, {
                  nodes: [valueNode]
                });
              }
              continue;
            }
            isNull = variableValues[variableName] == null;
          }
          if (isNull && (0, graphql_1.isNonNullType)(argType)) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name2}" of non-null type "${(0, inspect_js_1.inspect)(argType)}" must not be null.`, {
              nodes: [valueNode]
            });
          }
          const coercedValue = (0, graphql_1.valueFromAST)(valueNode, argType, variableValues);
          if (coercedValue === void 0) {
            throw (0, errors_js_1.createGraphQLError)(`Argument "${name2}" has invalid value ${(0, graphql_1.print)(valueNode)}.`, {
              nodes: [valueNode]
            });
          }
          coercedValues[name2] = coercedValue;
        }
        return coercedValues;
      }
      exports2.getArgumentValues = getArgumentValues2;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/get-directives.js
  var require_get_directives = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/get-directives.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getDirective = exports2.getDirectives = exports2.getDirectiveInExtensions = exports2.getDirectivesInExtensions = void 0;
      var getArgumentValues_js_1 = require_getArgumentValues();
      function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
        return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node == null ? void 0 : node.extensions);
      }
      exports2.getDirectivesInExtensions = getDirectivesInExtensions;
      function _getDirectiveInExtensions(directivesInExtensions, directiveName) {
        const directiveInExtensions = directivesInExtensions.filter((directiveAnnotation) => directiveAnnotation.name === directiveName);
        if (!directiveInExtensions.length) {
          return void 0;
        }
        return directiveInExtensions.map((directive) => {
          var _a;
          return (_a = directive.args) != null ? _a : {};
        });
      }
      function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
        const directivesInExtensions = pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node == null ? void 0 : node.extensions);
        if (directivesInExtensions === void 0) {
          return void 0;
        }
        if (Array.isArray(directivesInExtensions)) {
          return _getDirectiveInExtensions(directivesInExtensions, directiveName);
        }
        const reformattedDirectivesInExtensions = [];
        for (const [name2, argsOrArrayOfArgs] of Object.entries(directivesInExtensions)) {
          if (Array.isArray(argsOrArrayOfArgs)) {
            for (const args of argsOrArrayOfArgs) {
              reformattedDirectivesInExtensions.push({ name: name2, args });
            }
          } else {
            reformattedDirectivesInExtensions.push({ name: name2, args: argsOrArrayOfArgs });
          }
        }
        return _getDirectiveInExtensions(reformattedDirectivesInExtensions, directiveName);
      }
      exports2.getDirectiveInExtensions = getDirectiveInExtensions;
      function getDirectives(schema, node, pathToDirectivesInExtensions = ["directives"]) {
        const directivesInExtensions = getDirectivesInExtensions(node, pathToDirectivesInExtensions);
        if (directivesInExtensions != null && directivesInExtensions.length > 0) {
          return directivesInExtensions;
        }
        const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];
        const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap2, schemaDirective) => {
          schemaDirectiveMap2[schemaDirective.name] = schemaDirective;
          return schemaDirectiveMap2;
        }, {});
        let astNodes = [];
        if (node.astNode) {
          astNodes.push(node.astNode);
        }
        if ("extensionASTNodes" in node && node.extensionASTNodes) {
          astNodes = [...astNodes, ...node.extensionASTNodes];
        }
        const result = [];
        for (const astNode of astNodes) {
          if (astNode.directives) {
            for (const directiveNode of astNode.directives) {
              const schemaDirective = schemaDirectiveMap[directiveNode.name.value];
              if (schemaDirective) {
                result.push({ name: directiveNode.name.value, args: (0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode) });
              }
            }
          }
        }
        return result;
      }
      exports2.getDirectives = getDirectives;
      function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ["directives"]) {
        const directiveInExtensions = getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions);
        if (directiveInExtensions != null) {
          return directiveInExtensions;
        }
        const schemaDirective = schema && schema.getDirective ? schema.getDirective(directiveName) : void 0;
        if (schemaDirective == null) {
          return void 0;
        }
        let astNodes = [];
        if (node.astNode) {
          astNodes.push(node.astNode);
        }
        if ("extensionASTNodes" in node && node.extensionASTNodes) {
          astNodes = [...astNodes, ...node.extensionASTNodes];
        }
        const result = [];
        for (const astNode of astNodes) {
          if (astNode.directives) {
            for (const directiveNode of astNode.directives) {
              if (directiveNode.name.value === directiveName) {
                result.push((0, getArgumentValues_js_1.getArgumentValues)(schemaDirective, directiveNode));
              }
            }
          }
        }
        if (!result.length) {
          return void 0;
        }
        return result;
      }
      exports2.getDirective = getDirective;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js
  var require_get_fields_with_directives = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getFieldsWithDirectives = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function getFieldsWithDirectives(documentNode, options = {}) {
        const result = {};
        let selected = ["ObjectTypeDefinition", "ObjectTypeExtension"];
        if (options.includeInputTypes) {
          selected = [...selected, "InputObjectTypeDefinition", "InputObjectTypeExtension"];
        }
        const allTypes = documentNode.definitions.filter((obj) => selected.includes(obj.kind));
        for (const type of allTypes) {
          const typeName = type.name.value;
          if (type.fields == null) {
            continue;
          }
          for (const field of type.fields) {
            if (field.directives && field.directives.length > 0) {
              const fieldName = field.name.value;
              const key = `${typeName}.${fieldName}`;
              const directives = field.directives.map((d) => ({
                name: d.name.value,
                args: (d.arguments || []).reduce((prev, arg) => __spreadProps(__spreadValues({}, prev), { [arg.name.value]: (0, graphql_1.valueFromASTUntyped)(arg.value) }), {})
              }));
              result[key] = directives;
            }
          }
        }
        return result;
      }
      exports2.getFieldsWithDirectives = getFieldsWithDirectives;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/get-arguments-with-directives.js
  var require_get_arguments_with_directives = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/get-arguments-with-directives.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getArgumentsWithDirectives = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function isTypeWithFields(t2) {
        return t2.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || t2.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION;
      }
      function getArgumentsWithDirectives(documentNode) {
        var _a;
        const result = {};
        const allTypes = documentNode.definitions.filter(isTypeWithFields);
        for (const type of allTypes) {
          if (type.fields == null) {
            continue;
          }
          for (const field of type.fields) {
            const argsWithDirectives = (_a = field.arguments) == null ? void 0 : _a.filter((arg) => {
              var _a2;
              return (_a2 = arg.directives) == null ? void 0 : _a2.length;
            });
            if (!(argsWithDirectives == null ? void 0 : argsWithDirectives.length)) {
              continue;
            }
            const typeFieldResult = result[`${type.name.value}.${field.name.value}`] = {};
            for (const arg of argsWithDirectives) {
              const directives = arg.directives.map((d) => ({
                name: d.name.value,
                args: (d.arguments || []).reduce((prev, dArg) => __spreadProps(__spreadValues({}, prev), { [dArg.name.value]: (0, graphql_1.valueFromASTUntyped)(dArg.value) }), {})
              }));
              typeFieldResult[arg.name.value] = directives;
            }
          }
        }
        return result;
      }
      exports2.getArgumentsWithDirectives = getArgumentsWithDirectives;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js
  var require_get_implementing_types = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/get-implementing-types.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getImplementingTypes = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function getImplementingTypes(interfaceName, schema) {
        const allTypesMap = schema.getTypeMap();
        const result = [];
        for (const graphqlTypeName in allTypesMap) {
          const graphqlType = allTypesMap[graphqlTypeName];
          if ((0, graphql_1.isObjectType)(graphqlType)) {
            const allInterfaces = graphqlType.getInterfaces();
            if (allInterfaces.find((int) => int.name === interfaceName)) {
              result.push(graphqlType.name);
            }
          }
        }
        return result;
      }
      exports2.getImplementingTypes = getImplementingTypes;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/astFromType.js
  var require_astFromType = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/astFromType.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.astFromType = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var inspect_js_1 = require_inspect2();
      function astFromType(type) {
        if ((0, graphql_1.isNonNullType)(type)) {
          const innerType = astFromType(type.ofType);
          if (innerType.kind === graphql_1.Kind.NON_NULL_TYPE) {
            throw new Error(`Invalid type node ${(0, inspect_js_1.inspect)(type)}. Inner type of non-null type cannot be a non-null type.`);
          }
          return {
            kind: graphql_1.Kind.NON_NULL_TYPE,
            type: innerType
          };
        } else if ((0, graphql_1.isListType)(type)) {
          return {
            kind: graphql_1.Kind.LIST_TYPE,
            type: astFromType(type.ofType)
          };
        }
        return {
          kind: graphql_1.Kind.NAMED_TYPE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          }
        };
      }
      exports2.astFromType = astFromType;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js
  var require_astFromValueUntyped = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/astFromValueUntyped.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.astFromValueUntyped = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function astFromValueUntyped(value) {
        if (value === null) {
          return { kind: graphql_1.Kind.NULL };
        }
        if (value === void 0) {
          return null;
        }
        if (Array.isArray(value)) {
          const valuesNodes = [];
          for (const item of value) {
            const itemNode = astFromValueUntyped(item);
            if (itemNode != null) {
              valuesNodes.push(itemNode);
            }
          }
          return { kind: graphql_1.Kind.LIST, values: valuesNodes };
        }
        if (typeof value === "object") {
          const fieldNodes = [];
          for (const fieldName in value) {
            const fieldValue = value[fieldName];
            const ast = astFromValueUntyped(fieldValue);
            if (ast) {
              fieldNodes.push({
                kind: graphql_1.Kind.OBJECT_FIELD,
                name: { kind: graphql_1.Kind.NAME, value: fieldName },
                value: ast
              });
            }
          }
          return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
        }
        if (typeof value === "boolean") {
          return { kind: graphql_1.Kind.BOOLEAN, value };
        }
        if (typeof value === "bigint") {
          return { kind: graphql_1.Kind.INT, value: String(value) };
        }
        if (typeof value === "number" && isFinite(value)) {
          const stringNum = String(value);
          return integerStringRegExp2.test(stringNum) ? { kind: graphql_1.Kind.INT, value: stringNum } : { kind: graphql_1.Kind.FLOAT, value: stringNum };
        }
        if (typeof value === "string") {
          return { kind: graphql_1.Kind.STRING, value };
        }
        throw new TypeError(`Cannot convert value to AST: ${value}.`);
      }
      exports2.astFromValueUntyped = astFromValueUntyped;
      var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/memoize.js
  var require_memoize = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/memoize.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.memoize2of5 = exports2.memoize2of4 = exports2.memoize5 = exports2.memoize4 = exports2.memoize3 = exports2.memoize2 = exports2.memoize1 = void 0;
      function memoize1(fn) {
        const memoize1cache = /* @__PURE__ */ new WeakMap();
        return function memoized(a1) {
          const cachedValue = memoize1cache.get(a1);
          if (cachedValue === void 0) {
            const newValue = fn(a1);
            memoize1cache.set(a1, newValue);
            return newValue;
          }
          return cachedValue;
        };
      }
      exports2.memoize1 = memoize1;
      function memoize2(fn) {
        const memoize2cache = /* @__PURE__ */ new WeakMap();
        return function memoized(a1, a2) {
          let cache2 = memoize2cache.get(a1);
          if (!cache2) {
            cache2 = /* @__PURE__ */ new WeakMap();
            memoize2cache.set(a1, cache2);
            const newValue = fn(a1, a2);
            cache2.set(a2, newValue);
            return newValue;
          }
          const cachedValue = cache2.get(a2);
          if (cachedValue === void 0) {
            const newValue = fn(a1, a2);
            cache2.set(a2, newValue);
            return newValue;
          }
          return cachedValue;
        };
      }
      exports2.memoize2 = memoize2;
      function memoize32(fn) {
        const memoize3Cache = /* @__PURE__ */ new WeakMap();
        return function memoized(a1, a2, a3) {
          let cache2 = memoize3Cache.get(a1);
          if (!cache2) {
            cache2 = /* @__PURE__ */ new WeakMap();
            memoize3Cache.set(a1, cache2);
            const cache32 = /* @__PURE__ */ new WeakMap();
            cache2.set(a2, cache32);
            const newValue = fn(a1, a2, a3);
            cache32.set(a3, newValue);
            return newValue;
          }
          let cache3 = cache2.get(a2);
          if (!cache3) {
            cache3 = /* @__PURE__ */ new WeakMap();
            cache2.set(a2, cache3);
            const newValue = fn(a1, a2, a3);
            cache3.set(a3, newValue);
            return newValue;
          }
          const cachedValue = cache3.get(a3);
          if (cachedValue === void 0) {
            const newValue = fn(a1, a2, a3);
            cache3.set(a3, newValue);
            return newValue;
          }
          return cachedValue;
        };
      }
      exports2.memoize3 = memoize32;
      function memoize4(fn) {
        const memoize4Cache = /* @__PURE__ */ new WeakMap();
        return function memoized(a1, a2, a3, a4) {
          let cache2 = memoize4Cache.get(a1);
          if (!cache2) {
            cache2 = /* @__PURE__ */ new WeakMap();
            memoize4Cache.set(a1, cache2);
            const cache32 = /* @__PURE__ */ new WeakMap();
            cache2.set(a2, cache32);
            const cache42 = /* @__PURE__ */ new WeakMap();
            cache32.set(a3, cache42);
            const newValue = fn(a1, a2, a3, a4);
            cache42.set(a4, newValue);
            return newValue;
          }
          let cache3 = cache2.get(a2);
          if (!cache3) {
            cache3 = /* @__PURE__ */ new WeakMap();
            cache2.set(a2, cache3);
            const cache42 = /* @__PURE__ */ new WeakMap();
            cache3.set(a3, cache42);
            const newValue = fn(a1, a2, a3, a4);
            cache42.set(a4, newValue);
            return newValue;
          }
          const cache4 = cache3.get(a3);
          if (!cache4) {
            const cache42 = /* @__PURE__ */ new WeakMap();
            cache3.set(a3, cache42);
            const newValue = fn(a1, a2, a3, a4);
            cache42.set(a4, newValue);
            return newValue;
          }
          const cachedValue = cache4.get(a4);
          if (cachedValue === void 0) {
            const newValue = fn(a1, a2, a3, a4);
            cache4.set(a4, newValue);
            return newValue;
          }
          return cachedValue;
        };
      }
      exports2.memoize4 = memoize4;
      function memoize5(fn) {
        const memoize5Cache = /* @__PURE__ */ new WeakMap();
        return function memoized(a1, a2, a3, a4, a5) {
          let cache2 = memoize5Cache.get(a1);
          if (!cache2) {
            cache2 = /* @__PURE__ */ new WeakMap();
            memoize5Cache.set(a1, cache2);
            const cache32 = /* @__PURE__ */ new WeakMap();
            cache2.set(a2, cache32);
            const cache42 = /* @__PURE__ */ new WeakMap();
            cache32.set(a3, cache42);
            const cache52 = /* @__PURE__ */ new WeakMap();
            cache42.set(a4, cache52);
            const newValue = fn(a1, a2, a3, a4, a5);
            cache52.set(a5, newValue);
            return newValue;
          }
          let cache3 = cache2.get(a2);
          if (!cache3) {
            cache3 = /* @__PURE__ */ new WeakMap();
            cache2.set(a2, cache3);
            const cache42 = /* @__PURE__ */ new WeakMap();
            cache3.set(a3, cache42);
            const cache52 = /* @__PURE__ */ new WeakMap();
            cache42.set(a4, cache52);
            const newValue = fn(a1, a2, a3, a4, a5);
            cache52.set(a5, newValue);
            return newValue;
          }
          let cache4 = cache3.get(a3);
          if (!cache4) {
            cache4 = /* @__PURE__ */ new WeakMap();
            cache3.set(a3, cache4);
            const cache52 = /* @__PURE__ */ new WeakMap();
            cache4.set(a4, cache52);
            const newValue = fn(a1, a2, a3, a4, a5);
            cache52.set(a5, newValue);
            return newValue;
          }
          let cache5 = cache4.get(a4);
          if (!cache5) {
            cache5 = /* @__PURE__ */ new WeakMap();
            cache4.set(a4, cache5);
            const newValue = fn(a1, a2, a3, a4, a5);
            cache5.set(a5, newValue);
            return newValue;
          }
          const cachedValue = cache5.get(a5);
          if (cachedValue === void 0) {
            const newValue = fn(a1, a2, a3, a4, a5);
            cache5.set(a5, newValue);
            return newValue;
          }
          return cachedValue;
        };
      }
      exports2.memoize5 = memoize5;
      function memoize2of4(fn) {
        const memoize2of4cache = /* @__PURE__ */ new WeakMap();
        return function memoized(a1, a2, a3, a4) {
          let cache2 = memoize2of4cache.get(a1);
          if (!cache2) {
            cache2 = /* @__PURE__ */ new WeakMap();
            memoize2of4cache.set(a1, cache2);
            const newValue = fn(a1, a2, a3, a4);
            cache2.set(a2, newValue);
            return newValue;
          }
          const cachedValue = cache2.get(a2);
          if (cachedValue === void 0) {
            const newValue = fn(a1, a2, a3, a4);
            cache2.set(a2, newValue);
            return newValue;
          }
          return cachedValue;
        };
      }
      exports2.memoize2of4 = memoize2of4;
      function memoize2of5(fn) {
        const memoize2of4cache = /* @__PURE__ */ new WeakMap();
        return function memoized(a1, a2, a3, a4, a5) {
          let cache2 = memoize2of4cache.get(a1);
          if (!cache2) {
            cache2 = /* @__PURE__ */ new WeakMap();
            memoize2of4cache.set(a1, cache2);
            const newValue = fn(a1, a2, a3, a4, a5);
            cache2.set(a2, newValue);
            return newValue;
          }
          const cachedValue = cache2.get(a2);
          if (cachedValue === void 0) {
            const newValue = fn(a1, a2, a3, a4, a5);
            cache2.set(a2, newValue);
            return newValue;
          }
          return cachedValue;
        };
      }
      exports2.memoize2of5 = memoize2of5;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/rootTypes.js
  var require_rootTypes = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/rootTypes.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getRootTypeMap = exports2.getRootTypes = exports2.getRootTypeNames = exports2.getDefinedRootType = void 0;
      var errors_js_1 = require_errors2();
      var memoize_js_1 = require_memoize();
      function getDefinedRootType(schema, operation, nodes) {
        const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
        const rootType = rootTypeMap.get(operation);
        if (rootType == null) {
          throw (0, errors_js_1.createGraphQLError)(`Schema is not configured to execute ${operation} operation.`, {
            nodes
          });
        }
        return rootType;
      }
      exports2.getDefinedRootType = getDefinedRootType;
      exports2.getRootTypeNames = (0, memoize_js_1.memoize1)(function getRootTypeNames(schema) {
        const rootTypes = (0, exports2.getRootTypes)(schema);
        return new Set([...rootTypes].map((type) => type.name));
      });
      exports2.getRootTypes = (0, memoize_js_1.memoize1)(function getRootTypes(schema) {
        const rootTypeMap = (0, exports2.getRootTypeMap)(schema);
        return new Set(rootTypeMap.values());
      });
      exports2.getRootTypeMap = (0, memoize_js_1.memoize1)(function getRootTypeMap(schema) {
        const rootTypeMap = /* @__PURE__ */ new Map();
        const queryType = schema.getQueryType();
        if (queryType) {
          rootTypeMap.set("query", queryType);
        }
        const mutationType = schema.getMutationType();
        if (mutationType) {
          rootTypeMap.set("mutation", mutationType);
        }
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          rootTypeMap.set("subscription", subscriptionType);
        }
        return rootTypeMap;
      });
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/astFromValue.js
  var require_astFromValue2 = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/astFromValue.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.astFromValue = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var jsutils_js_1 = require_jsutils();
      var inspect_js_1 = require_inspect2();
      var astFromValueUntyped_js_1 = require_astFromValueUntyped();
      function astFromValue2(value, type) {
        if ((0, graphql_1.isNonNullType)(type)) {
          const astValue = astFromValue2(value, type.ofType);
          if ((astValue == null ? void 0 : astValue.kind) === graphql_1.Kind.NULL) {
            return null;
          }
          return astValue;
        }
        if (value === null) {
          return { kind: graphql_1.Kind.NULL };
        }
        if (value === void 0) {
          return null;
        }
        if ((0, graphql_1.isListType)(type)) {
          const itemType = type.ofType;
          if ((0, jsutils_js_1.isIterableObject)(value)) {
            const valuesNodes = [];
            for (const item of value) {
              const itemNode = astFromValue2(item, itemType);
              if (itemNode != null) {
                valuesNodes.push(itemNode);
              }
            }
            return { kind: graphql_1.Kind.LIST, values: valuesNodes };
          }
          return astFromValue2(value, itemType);
        }
        if ((0, graphql_1.isInputObjectType)(type)) {
          if (!(0, jsutils_js_1.isObjectLike)(value)) {
            return null;
          }
          const fieldNodes = [];
          for (const field of Object.values(type.getFields())) {
            const fieldValue = astFromValue2(value[field.name], field.type);
            if (fieldValue) {
              fieldNodes.push({
                kind: graphql_1.Kind.OBJECT_FIELD,
                name: { kind: graphql_1.Kind.NAME, value: field.name },
                value: fieldValue
              });
            }
          }
          return { kind: graphql_1.Kind.OBJECT, fields: fieldNodes };
        }
        if ((0, graphql_1.isLeafType)(type)) {
          const serialized = type.serialize(value);
          if (serialized == null) {
            return null;
          }
          if ((0, graphql_1.isEnumType)(type)) {
            return { kind: graphql_1.Kind.ENUM, value: serialized };
          }
          if (type.name === "ID" && typeof serialized === "string" && integerStringRegExp2.test(serialized)) {
            return { kind: graphql_1.Kind.INT, value: serialized };
          }
          return (0, astFromValueUntyped_js_1.astFromValueUntyped)(serialized);
        }
        console.assert(false, "Unexpected input type: " + (0, inspect_js_1.inspect)(type));
      }
      exports2.astFromValue = astFromValue2;
      var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js
  var require_print_schema_with_directives = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/print-schema-with-directives.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.makeDirectiveNodes = exports2.makeDirectiveNode = exports2.makeDeprecatedDirective = exports2.astFromEnumValue = exports2.astFromInputField = exports2.astFromField = exports2.astFromScalarType = exports2.astFromEnumType = exports2.astFromInputObjectType = exports2.astFromUnionType = exports2.astFromInterfaceType = exports2.astFromObjectType = exports2.astFromArg = exports2.getDeprecatableDirectiveNodes = exports2.getDirectiveNodes = exports2.astFromDirective = exports2.astFromSchema = exports2.printSchemaWithDirectives = exports2.getDocumentNodeFromSchema = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var astFromType_js_1 = require_astFromType();
      var get_directives_js_1 = require_get_directives();
      var astFromValueUntyped_js_1 = require_astFromValueUntyped();
      var helpers_js_1 = require_helpers();
      var rootTypes_js_1 = require_rootTypes();
      var astFromValue_js_1 = require_astFromValue2();
      function getDocumentNodeFromSchema(schema, options = {}) {
        const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
        const typesMap = schema.getTypeMap();
        const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);
        const definitions = schemaNode != null ? [schemaNode] : [];
        const directives = schema.getDirectives();
        for (const directive of directives) {
          if ((0, graphql_1.isSpecifiedDirective)(directive)) {
            continue;
          }
          definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));
        }
        for (const typeName in typesMap) {
          const type = typesMap[typeName];
          const isPredefinedScalar = (0, graphql_1.isSpecifiedScalarType)(type);
          const isIntrospection = (0, graphql_1.isIntrospectionType)(type);
          if (isPredefinedScalar || isIntrospection) {
            continue;
          }
          if ((0, graphql_1.isObjectType)(type)) {
            definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));
          } else if ((0, graphql_1.isInterfaceType)(type)) {
            definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));
          } else if ((0, graphql_1.isUnionType)(type)) {
            definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));
          } else if ((0, graphql_1.isInputObjectType)(type)) {
            definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));
          } else if ((0, graphql_1.isEnumType)(type)) {
            definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));
          } else if ((0, graphql_1.isScalarType)(type)) {
            definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));
          } else {
            throw new Error(`Unknown type ${type}.`);
          }
        }
        return {
          kind: graphql_1.Kind.DOCUMENT,
          definitions
        };
      }
      exports2.getDocumentNodeFromSchema = getDocumentNodeFromSchema;
      function printSchemaWithDirectives(schema, options = {}) {
        const documentNode = getDocumentNodeFromSchema(schema, options);
        return (0, graphql_1.print)(documentNode);
      }
      exports2.printSchemaWithDirectives = printSchemaWithDirectives;
      function astFromSchema(schema, pathToDirectivesInExtensions) {
        var _a, _b;
        const operationTypeMap = /* @__PURE__ */ new Map([
          ["query", void 0],
          ["mutation", void 0],
          ["subscription", void 0]
        ]);
        const nodes = [];
        if (schema.astNode != null) {
          nodes.push(schema.astNode);
        }
        if (schema.extensionASTNodes != null) {
          for (const extensionASTNode of schema.extensionASTNodes) {
            nodes.push(extensionASTNode);
          }
        }
        for (const node of nodes) {
          if (node.operationTypes) {
            for (const operationTypeDefinitionNode of node.operationTypes) {
              operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
            }
          }
        }
        const rootTypeMap = (0, rootTypes_js_1.getRootTypeMap)(schema);
        for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
          const rootType = rootTypeMap.get(operationTypeNode);
          if (rootType != null) {
            const rootTypeAST = (0, astFromType_js_1.astFromType)(rootType);
            if (operationTypeDefinitionNode != null) {
              operationTypeDefinitionNode.type = rootTypeAST;
            } else {
              operationTypeMap.set(operationTypeNode, {
                kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                operation: operationTypeNode,
                type: rootTypeAST
              });
            }
          }
        }
        const operationTypes = [...operationTypeMap.values()].filter(helpers_js_1.isSome);
        const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);
        if (!operationTypes.length && !directives.length) {
          return null;
        }
        const schemaNode = {
          kind: operationTypes != null ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
          operationTypes,
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives
        };
        schemaNode.description = ((_b = (_a = schema.astNode) == null ? void 0 : _a.description) != null ? _b : schema.description != null) ? {
          kind: graphql_1.Kind.STRING,
          value: schema.description,
          block: true
        } : void 0;
        return schemaNode;
      }
      exports2.astFromSchema = astFromSchema;
      function astFromDirective(directive, schema, pathToDirectivesInExtensions) {
        var _a, _b, _c, _d;
        return {
          kind: graphql_1.Kind.DIRECTIVE_DEFINITION,
          description: (_b = (_a = directive.astNode) == null ? void 0 : _a.description) != null ? _b : directive.description ? {
            kind: graphql_1.Kind.STRING,
            value: directive.description
          } : void 0,
          name: {
            kind: graphql_1.Kind.NAME,
            value: directive.name
          },
          arguments: (_c = directive.args) == null ? void 0 : _c.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
          repeatable: directive.isRepeatable,
          locations: ((_d = directive.locations) == null ? void 0 : _d.map((location) => ({
            kind: graphql_1.Kind.NAME,
            value: location
          }))) || []
        };
      }
      exports2.astFromDirective = astFromDirective;
      function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
        const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
        let nodes = [];
        if (entity.astNode != null) {
          nodes.push(entity.astNode);
        }
        if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
          nodes = nodes.concat(entity.extensionASTNodes);
        }
        let directives;
        if (directivesInExtensions != null) {
          directives = makeDirectiveNodes(schema, directivesInExtensions);
        } else {
          directives = [];
          for (const node of nodes) {
            if (node.directives) {
              directives.push(...node.directives);
            }
          }
        }
        return directives;
      }
      exports2.getDirectiveNodes = getDirectiveNodes;
      function getDeprecatableDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {
        var _a, _b;
        let directiveNodesBesidesDeprecated = [];
        let deprecatedDirectiveNode = null;
        const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(entity, pathToDirectivesInExtensions);
        let directives;
        if (directivesInExtensions != null) {
          directives = makeDirectiveNodes(schema, directivesInExtensions);
        } else {
          directives = (_a = entity.astNode) == null ? void 0 : _a.directives;
        }
        if (directives != null) {
          directiveNodesBesidesDeprecated = directives.filter((directive) => directive.name.value !== "deprecated");
          if (entity.deprecationReason != null) {
            deprecatedDirectiveNode = (_b = directives.filter((directive) => directive.name.value === "deprecated")) == null ? void 0 : _b[0];
          }
        }
        if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
          deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
        }
        return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
      }
      exports2.getDeprecatableDirectiveNodes = getDeprecatableDirectiveNodes;
      function astFromArg(arg, schema, pathToDirectivesInExtensions) {
        var _a, _b, _c;
        return {
          kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
          description: (_b = (_a = arg.astNode) == null ? void 0 : _a.description) != null ? _b : arg.description ? {
            kind: graphql_1.Kind.STRING,
            value: arg.description,
            block: true
          } : void 0,
          name: {
            kind: graphql_1.Kind.NAME,
            value: arg.name
          },
          type: (0, astFromType_js_1.astFromType)(arg.type),
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          defaultValue: arg.defaultValue !== void 0 ? (_c = (0, astFromValue_js_1.astFromValue)(arg.defaultValue, arg.type)) != null ? _c : void 0 : void 0,
          directives: getDeprecatableDirectiveNodes(arg, schema, pathToDirectivesInExtensions)
        };
      }
      exports2.astFromArg = astFromArg;
      function astFromObjectType(type, schema, pathToDirectivesInExtensions) {
        var _a, _b;
        return {
          kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
          description: (_b = (_a = type.astNode) == null ? void 0 : _a.description) != null ? _b : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
          } : void 0,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          },
          fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
          interfaces: Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace)),
          directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
        };
      }
      exports2.astFromObjectType = astFromObjectType;
      function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {
        var _a, _b;
        const node = {
          kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
          description: (_b = (_a = type.astNode) == null ? void 0 : _a.description) != null ? _b : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
          } : void 0,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          },
          fields: Object.values(type.getFields()).map((field) => astFromField(field, schema, pathToDirectivesInExtensions)),
          directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
        };
        if ("getInterfaces" in type) {
          node.interfaces = Object.values(type.getInterfaces()).map((iFace) => (0, astFromType_js_1.astFromType)(iFace));
        }
        return node;
      }
      exports2.astFromInterfaceType = astFromInterfaceType;
      function astFromUnionType(type, schema, pathToDirectivesInExtensions) {
        var _a, _b;
        return {
          kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
          description: (_b = (_a = type.astNode) == null ? void 0 : _a.description) != null ? _b : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
          } : void 0,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          },
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),
          types: type.getTypes().map((type2) => (0, astFromType_js_1.astFromType)(type2))
        };
      }
      exports2.astFromUnionType = astFromUnionType;
      function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {
        var _a, _b;
        return {
          kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description: (_b = (_a = type.astNode) == null ? void 0 : _a.description) != null ? _b : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
          } : void 0,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          },
          fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema, pathToDirectivesInExtensions)),
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
        };
      }
      exports2.astFromInputObjectType = astFromInputObjectType;
      function astFromEnumType(type, schema, pathToDirectivesInExtensions) {
        var _a, _b;
        return {
          kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
          description: (_b = (_a = type.astNode) == null ? void 0 : _a.description) != null ? _b : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
          } : void 0,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          },
          values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions)
        };
      }
      exports2.astFromEnumType = astFromEnumType;
      function astFromScalarType(type, schema, pathToDirectivesInExtensions) {
        var _a, _b, _c;
        const directivesInExtensions = (0, get_directives_js_1.getDirectivesInExtensions)(type, pathToDirectivesInExtensions);
        const directives = directivesInExtensions ? makeDirectiveNodes(schema, directivesInExtensions) : ((_a = type.astNode) == null ? void 0 : _a.directives) || [];
        const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
        if (specifiedByValue && !directives.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
          const specifiedByArgs = {
            url: specifiedByValue
          };
          directives.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
        }
        return {
          kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
          description: (_c = (_b = type.astNode) == null ? void 0 : _b.description) != null ? _c : type.description ? {
            kind: graphql_1.Kind.STRING,
            value: type.description,
            block: true
          } : void 0,
          name: {
            kind: graphql_1.Kind.NAME,
            value: type.name
          },
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives
        };
      }
      exports2.astFromScalarType = astFromScalarType;
      function astFromField(field, schema, pathToDirectivesInExtensions) {
        var _a, _b;
        return {
          kind: graphql_1.Kind.FIELD_DEFINITION,
          description: (_b = (_a = field.astNode) == null ? void 0 : _a.description) != null ? _b : field.description ? {
            kind: graphql_1.Kind.STRING,
            value: field.description,
            block: true
          } : void 0,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          arguments: field.args.map((arg) => astFromArg(arg, schema, pathToDirectivesInExtensions)),
          type: (0, astFromType_js_1.astFromType)(field.type),
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions)
        };
      }
      exports2.astFromField = astFromField;
      function astFromInputField(field, schema, pathToDirectivesInExtensions) {
        var _a, _b, _c;
        return {
          kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
          description: (_b = (_a = field.astNode) == null ? void 0 : _a.description) != null ? _b : field.description ? {
            kind: graphql_1.Kind.STRING,
            value: field.description,
            block: true
          } : void 0,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          },
          type: (0, astFromType_js_1.astFromType)(field.type),
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: getDeprecatableDirectiveNodes(field, schema, pathToDirectivesInExtensions),
          defaultValue: (_c = (0, astFromValue_js_1.astFromValue)(field.defaultValue, field.type)) != null ? _c : void 0
        };
      }
      exports2.astFromInputField = astFromInputField;
      function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {
        var _a, _b;
        return {
          kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
          description: (_b = (_a = value.astNode) == null ? void 0 : _a.description) != null ? _b : value.description ? {
            kind: graphql_1.Kind.STRING,
            value: value.description,
            block: true
          } : void 0,
          name: {
            kind: graphql_1.Kind.NAME,
            value: value.name
          },
          // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
          directives: getDeprecatableDirectiveNodes(value, schema, pathToDirectivesInExtensions)
        };
      }
      exports2.astFromEnumValue = astFromEnumValue;
      function makeDeprecatedDirective(deprecationReason) {
        return makeDirectiveNode("deprecated", { reason: deprecationReason }, graphql_1.GraphQLDeprecatedDirective);
      }
      exports2.makeDeprecatedDirective = makeDeprecatedDirective;
      function makeDirectiveNode(name2, args, directive) {
        const directiveArguments = [];
        if (directive != null) {
          for (const arg of directive.args) {
            const argName = arg.name;
            const argValue = args[argName];
            if (argValue !== void 0) {
              const value = (0, astFromValue_js_1.astFromValue)(argValue, arg.type);
              if (value) {
                directiveArguments.push({
                  kind: graphql_1.Kind.ARGUMENT,
                  name: {
                    kind: graphql_1.Kind.NAME,
                    value: argName
                  },
                  value
                });
              }
            }
          }
        } else {
          for (const argName in args) {
            const argValue = args[argName];
            const value = (0, astFromValueUntyped_js_1.astFromValueUntyped)(argValue);
            if (value) {
              directiveArguments.push({
                kind: graphql_1.Kind.ARGUMENT,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: argName
                },
                value
              });
            }
          }
        }
        return {
          kind: graphql_1.Kind.DIRECTIVE,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name2
          },
          arguments: directiveArguments
        };
      }
      exports2.makeDirectiveNode = makeDirectiveNode;
      function makeDirectiveNodes(schema, directiveValues) {
        const directiveNodes = [];
        for (const directiveName in directiveValues) {
          const arrayOrSingleValue = directiveValues[directiveName];
          const directive = schema == null ? void 0 : schema.getDirective(directiveName);
          if (Array.isArray(arrayOrSingleValue)) {
            for (const value of arrayOrSingleValue) {
              directiveNodes.push(makeDirectiveNode(directiveName, value, directive));
            }
          } else {
            directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive));
          }
        }
        return directiveNodes;
      }
      exports2.makeDirectiveNodes = makeDirectiveNodes;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/validate-documents.js
  var require_validate_documents = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/validate-documents.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createDefaultRules = exports2.validateGraphQlDocuments = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function validateGraphQlDocuments(schema, documents, rules = createDefaultRules()) {
        var _a;
        const definitionMap = /* @__PURE__ */ new Map();
        for (const document of documents) {
          for (const docDefinition of document.definitions) {
            if ("name" in docDefinition && docDefinition.name) {
              definitionMap.set(`${docDefinition.kind}_${docDefinition.name.value}`, docDefinition);
            } else {
              definitionMap.set(Date.now().toString(), docDefinition);
            }
          }
        }
        const fullAST = {
          kind: graphql_1.Kind.DOCUMENT,
          definitions: Array.from(definitionMap.values())
        };
        const errors = (0, graphql_1.validate)(schema, fullAST, rules);
        for (const error of errors) {
          error.stack = error.message;
          if (error.locations) {
            for (const location of error.locations) {
              error.stack += `
    at ${(_a = error.source) == null ? void 0 : _a.name}:${location.line}:${location.column}`;
            }
          }
        }
        return errors;
      }
      exports2.validateGraphQlDocuments = validateGraphQlDocuments;
      function createDefaultRules() {
        let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
        if (graphql_1.versionInfo.major < 15) {
          ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
        }
        return graphql_1.specifiedRules.filter((f2) => !ignored.includes(f2.name));
      }
      exports2.createDefaultRules = createDefaultRules;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js
  var require_parse_graphql_json = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/parse-graphql-json.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseGraphQLJSON = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function stripBOM(content) {
        content = content.toString();
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      }
      function parseBOM(content) {
        return JSON.parse(stripBOM(content));
      }
      function parseGraphQLJSON(location, jsonContent, options) {
        let parsedJson = parseBOM(jsonContent);
        if (parsedJson.data) {
          parsedJson = parsedJson.data;
        }
        if (parsedJson.kind === "Document") {
          return {
            location,
            document: parsedJson
          };
        } else if (parsedJson.__schema) {
          const schema = (0, graphql_1.buildClientSchema)(parsedJson, options);
          return {
            location,
            schema
          };
        } else if (typeof parsedJson === "string") {
          return {
            location,
            rawSDL: parsedJson
          };
        }
        throw new Error(`Not valid JSON content`);
      }
      exports2.parseGraphQLJSON = parseGraphQLJSON;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/comments.js
  var require_comments = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/comments.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getBlockStringIndentation = exports2.dedentBlockStringValue = exports2.getLeadingCommentBlock = exports2.getComment = exports2.getDescription = exports2.printWithComments = exports2.printComment = exports2.pushComment = exports2.collectComment = exports2.resetComments = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var MAX_LINE_LENGTH2 = 80;
      var commentsRegistry = {};
      function resetComments() {
        commentsRegistry = {};
      }
      exports2.resetComments = resetComments;
      function collectComment(node) {
        var _a;
        const entityName = (_a = node.name) == null ? void 0 : _a.value;
        if (entityName == null) {
          return;
        }
        pushComment(node, entityName);
        switch (node.kind) {
          case "EnumTypeDefinition":
            if (node.values) {
              for (const value of node.values) {
                pushComment(value, entityName, value.name.value);
              }
            }
            break;
          case "ObjectTypeDefinition":
          case "InputObjectTypeDefinition":
          case "InterfaceTypeDefinition":
            if (node.fields) {
              for (const field of node.fields) {
                pushComment(field, entityName, field.name.value);
                if (isFieldDefinitionNode(field) && field.arguments) {
                  for (const arg of field.arguments) {
                    pushComment(arg, entityName, field.name.value, arg.name.value);
                  }
                }
              }
            }
            break;
        }
      }
      exports2.collectComment = collectComment;
      function pushComment(node, entity, field, argument) {
        const comment = getComment(node);
        if (typeof comment !== "string" || comment.length === 0) {
          return;
        }
        const keys = [entity];
        if (field) {
          keys.push(field);
          if (argument) {
            keys.push(argument);
          }
        }
        const path = keys.join(".");
        if (!commentsRegistry[path]) {
          commentsRegistry[path] = [];
        }
        commentsRegistry[path].push(comment);
      }
      exports2.pushComment = pushComment;
      function printComment(comment) {
        return "\n# " + comment.replace(/\n/g, "\n# ");
      }
      exports2.printComment = printComment;
      function join2(maybeArray, separator) {
        return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
      }
      function hasMultilineItems2(maybeArray) {
        var _a;
        return (_a = maybeArray == null ? void 0 : maybeArray.some((str) => str.includes("\n"))) != null ? _a : false;
      }
      function addDescription(cb) {
        return (node, _key, _parent, path, ancestors) => {
          var _a;
          const keys = [];
          const parent = path.reduce((prev, key2) => {
            if (["fields", "arguments", "values"].includes(key2) && prev.name) {
              keys.push(prev.name.value);
            }
            return prev[key2];
          }, ancestors[0]);
          const key = [...keys, (_a = parent == null ? void 0 : parent.name) == null ? void 0 : _a.value].filter(Boolean).join(".");
          const items = [];
          if (node.kind.includes("Definition") && commentsRegistry[key]) {
            items.push(...commentsRegistry[key]);
          }
          return join2([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
        };
      }
      function indent2(maybeString) {
        return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
      }
      function block2(array) {
        return array && array.length !== 0 ? `{
${indent2(join2(array, "\n"))}
}` : "";
      }
      function wrap2(start, maybeString, end) {
        return maybeString ? start + maybeString + (end || "") : "";
      }
      function printBlockString2(value, isDescription = false) {
        const escaped = value.replace(/"""/g, '\\"""');
        return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent2(escaped)}
"""`;
      }
      var printDocASTReducer2 = {
        Name: { leave: (node) => node.value },
        Variable: { leave: (node) => "$" + node.name },
        // Document
        Document: {
          leave: (node) => join2(node.definitions, "\n\n")
        },
        OperationDefinition: {
          leave: (node) => {
            const varDefs = wrap2("(", join2(node.variableDefinitions, ", "), ")");
            const prefix = join2([node.operation, join2([node.name, varDefs]), join2(node.directives, " ")], " ");
            return prefix + " " + node.selectionSet;
          }
        },
        VariableDefinition: {
          leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join2(directives, " "))
        },
        SelectionSet: { leave: ({ selections }) => block2(selections) },
        Field: {
          leave({ alias, name: name2, arguments: args, directives, selectionSet }) {
            const prefix = wrap2("", alias, ": ") + name2;
            let argsLine = prefix + wrap2("(", join2(args, ", "), ")");
            if (argsLine.length > MAX_LINE_LENGTH2) {
              argsLine = prefix + wrap2("(\n", indent2(join2(args, "\n")), "\n)");
            }
            return join2([argsLine, join2(directives, " "), selectionSet], " ");
          }
        },
        Argument: { leave: ({ name: name2, value }) => name2 + ": " + value },
        // Fragments
        FragmentSpread: {
          leave: ({ name: name2, directives }) => "..." + name2 + wrap2(" ", join2(directives, " "))
        },
        InlineFragment: {
          leave: ({ typeCondition, directives, selectionSet }) => join2(["...", wrap2("on ", typeCondition), join2(directives, " "), selectionSet], " ")
        },
        FragmentDefinition: {
          leave: ({ name: name2, typeCondition, variableDefinitions, directives, selectionSet }) => (
            // Note: fragment variable definitions are experimental and may be changed
            // or removed in the future.
            `fragment ${name2}${wrap2("(", join2(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap2("", join2(directives, " "), " ")}` + selectionSet
          )
        },
        // Value
        IntValue: { leave: ({ value }) => value },
        FloatValue: { leave: ({ value }) => value },
        StringValue: {
          leave: ({ value, block: isBlockString }) => {
            if (isBlockString) {
              return printBlockString2(value);
            }
            return JSON.stringify(value);
          }
        },
        BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
        NullValue: { leave: () => "null" },
        EnumValue: { leave: ({ value }) => value },
        ListValue: { leave: ({ values }) => "[" + join2(values, ", ") + "]" },
        ObjectValue: { leave: ({ fields }) => "{" + join2(fields, ", ") + "}" },
        ObjectField: { leave: ({ name: name2, value }) => name2 + ": " + value },
        // Directive
        Directive: {
          leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap2("(", join2(args, ", "), ")")
        },
        // Type
        NamedType: { leave: ({ name: name2 }) => name2 },
        ListType: { leave: ({ type }) => "[" + type + "]" },
        NonNullType: { leave: ({ type }) => type + "!" },
        // Type System Definitions
        SchemaDefinition: {
          leave: ({ directives, operationTypes }) => join2(["schema", join2(directives, " "), block2(operationTypes)], " ")
        },
        OperationTypeDefinition: {
          leave: ({ operation, type }) => operation + ": " + type
        },
        ScalarTypeDefinition: {
          leave: ({ name: name2, directives }) => join2(["scalar", name2, join2(directives, " ")], " ")
        },
        ObjectTypeDefinition: {
          leave: ({ name: name2, interfaces, directives, fields }) => join2(["type", name2, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
        },
        FieldDefinition: {
          leave: ({ name: name2, arguments: args, type, directives }) => name2 + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + ": " + type + wrap2(" ", join2(directives, " "))
        },
        InputValueDefinition: {
          leave: ({ name: name2, type, defaultValue, directives }) => join2([name2 + ": " + type, wrap2("= ", defaultValue), join2(directives, " ")], " ")
        },
        InterfaceTypeDefinition: {
          leave: ({ name: name2, interfaces, directives, fields }) => join2(["interface", name2, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
        },
        UnionTypeDefinition: {
          leave: ({ name: name2, directives, types }) => join2(["union", name2, join2(directives, " "), wrap2("= ", join2(types, " | "))], " ")
        },
        EnumTypeDefinition: {
          leave: ({ name: name2, directives, values }) => join2(["enum", name2, join2(directives, " "), block2(values)], " ")
        },
        EnumValueDefinition: {
          leave: ({ name: name2, directives }) => join2([name2, join2(directives, " ")], " ")
        },
        InputObjectTypeDefinition: {
          leave: ({ name: name2, directives, fields }) => join2(["input", name2, join2(directives, " "), block2(fields)], " ")
        },
        DirectiveDefinition: {
          leave: ({ name: name2, arguments: args, repeatable, locations }) => "directive @" + name2 + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
        },
        SchemaExtension: {
          leave: ({ directives, operationTypes }) => join2(["extend schema", join2(directives, " "), block2(operationTypes)], " ")
        },
        ScalarTypeExtension: {
          leave: ({ name: name2, directives }) => join2(["extend scalar", name2, join2(directives, " ")], " ")
        },
        ObjectTypeExtension: {
          leave: ({ name: name2, interfaces, directives, fields }) => join2(["extend type", name2, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
        },
        InterfaceTypeExtension: {
          leave: ({ name: name2, interfaces, directives, fields }) => join2(["extend interface", name2, wrap2("implements ", join2(interfaces, " & ")), join2(directives, " "), block2(fields)], " ")
        },
        UnionTypeExtension: {
          leave: ({ name: name2, directives, types }) => join2(["extend union", name2, join2(directives, " "), wrap2("= ", join2(types, " | "))], " ")
        },
        EnumTypeExtension: {
          leave: ({ name: name2, directives, values }) => join2(["extend enum", name2, join2(directives, " "), block2(values)], " ")
        },
        InputObjectTypeExtension: {
          leave: ({ name: name2, directives, fields }) => join2(["extend input", name2, join2(directives, " "), block2(fields)], " ")
        }
      };
      var printDocASTReducerWithComments = Object.keys(printDocASTReducer2).reduce((prev, key) => __spreadProps(__spreadValues({}, prev), {
        [key]: {
          leave: addDescription(printDocASTReducer2[key].leave)
        }
      }), {});
      function printWithComments(ast) {
        return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);
      }
      exports2.printWithComments = printWithComments;
      function isFieldDefinitionNode(node) {
        return node.kind === "FieldDefinition";
      }
      function getDescription(node, options) {
        if (node.description != null) {
          return node.description.value;
        }
        if (options == null ? void 0 : options.commentDescriptions) {
          return getComment(node);
        }
      }
      exports2.getDescription = getDescription;
      function getComment(node) {
        const rawValue = getLeadingCommentBlock(node);
        if (rawValue !== void 0) {
          return dedentBlockStringValue(`
${rawValue}`);
        }
      }
      exports2.getComment = getComment;
      function getLeadingCommentBlock(node) {
        const loc = node.loc;
        if (!loc) {
          return;
        }
        const comments = [];
        let token = loc.startToken.prev;
        while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
          const value = String(token.value);
          comments.push(value);
          token = token.prev;
        }
        return comments.length > 0 ? comments.reverse().join("\n") : void 0;
      }
      exports2.getLeadingCommentBlock = getLeadingCommentBlock;
      function dedentBlockStringValue(rawString) {
        const lines = rawString.split(/\r\n|[\n\r]/g);
        const commonIndent = getBlockStringIndentation(lines);
        if (commonIndent !== 0) {
          for (let i2 = 1; i2 < lines.length; i2++) {
            lines[i2] = lines[i2].slice(commonIndent);
          }
        }
        while (lines.length > 0 && isBlank(lines[0])) {
          lines.shift();
        }
        while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
          lines.pop();
        }
        return lines.join("\n");
      }
      exports2.dedentBlockStringValue = dedentBlockStringValue;
      function getBlockStringIndentation(lines) {
        let commonIndent = null;
        for (let i2 = 1; i2 < lines.length; i2++) {
          const line = lines[i2];
          const indent3 = leadingWhitespace2(line);
          if (indent3 === line.length) {
            continue;
          }
          if (commonIndent === null || indent3 < commonIndent) {
            commonIndent = indent3;
            if (commonIndent === 0) {
              break;
            }
          }
        }
        return commonIndent === null ? 0 : commonIndent;
      }
      exports2.getBlockStringIndentation = getBlockStringIndentation;
      function leadingWhitespace2(str) {
        let i2 = 0;
        while (i2 < str.length && (str[i2] === " " || str[i2] === "	")) {
          i2++;
        }
        return i2;
      }
      function isBlank(str) {
        return leadingWhitespace2(str) === str.length;
      }
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js
  var require_parse_graphql_sdl = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isDescribable = exports2.transformCommentsToDescriptions = exports2.parseGraphQLSDL = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var comments_js_1 = require_comments();
      function parseGraphQLSDL(location, rawSDL, options = {}) {
        let document;
        try {
          if (options.commentDescriptions && rawSDL.includes("#")) {
            document = transformCommentsToDescriptions(rawSDL, options);
            if (options.noLocation) {
              document = (0, graphql_1.parse)((0, graphql_1.print)(document), options);
            }
          } else {
            document = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);
          }
        } catch (e2) {
          if (e2.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
            document = {
              kind: graphql_1.Kind.DOCUMENT,
              definitions: []
            };
          } else {
            throw e2;
          }
        }
        return {
          location,
          document
        };
      }
      exports2.parseGraphQLSDL = parseGraphQLSDL;
      function transformCommentsToDescriptions(sourceSdl, options = {}) {
        const parsedDoc = (0, graphql_1.parse)(sourceSdl, __spreadProps(__spreadValues({}, options), {
          noLocation: false
        }));
        const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {
          leave: (node) => {
            if (isDescribable(node)) {
              const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);
              if (rawValue !== void 0) {
                const commentsBlock = (0, comments_js_1.dedentBlockStringValue)("\n" + rawValue);
                const isBlock = commentsBlock.includes("\n");
                if (!node.description) {
                  return __spreadProps(__spreadValues({}, node), {
                    description: {
                      kind: graphql_1.Kind.STRING,
                      value: commentsBlock,
                      block: isBlock
                    }
                  });
                } else {
                  return __spreadProps(__spreadValues({}, node), {
                    description: __spreadProps(__spreadValues({}, node.description), {
                      value: node.description.value + "\n" + commentsBlock,
                      block: true
                    })
                  });
                }
              }
            }
          }
        });
        return modifiedDoc;
      }
      exports2.transformCommentsToDescriptions = transformCommentsToDescriptions;
      function isDescribable(node) {
        return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;
      }
      exports2.isDescribable = isDescribable;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js
  var require_build_operation_for_field = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.buildOperationNodeForField = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var rootTypes_js_1 = require_rootTypes();
      var operationVariables = [];
      var fieldTypeMap = /* @__PURE__ */ new Map();
      function addOperationVariable(variable) {
        operationVariables.push(variable);
      }
      function resetOperationVariables() {
        operationVariables = [];
      }
      function resetFieldMap() {
        fieldTypeMap = /* @__PURE__ */ new Map();
      }
      function buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true }) {
        resetOperationVariables();
        resetFieldMap();
        const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);
        const operationNode = buildOperationAndCollectVariables({
          schema,
          fieldName: field,
          kind,
          models: models || [],
          ignore,
          depthLimit: depthLimit || Infinity,
          circularReferenceDepth: circularReferenceDepth || 1,
          argNames,
          selectedFields,
          rootTypeNames
        });
        operationNode.variableDefinitions = [...operationVariables];
        resetOperationVariables();
        resetFieldMap();
        return operationNode;
      }
      exports2.buildOperationNodeForField = buildOperationNodeForField;
      function buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames }) {
        const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);
        const field = type.getFields()[fieldName];
        const operationName = `${fieldName}_${kind}`;
        if (field.args) {
          for (const arg of field.args) {
            const argName = arg.name;
            if (!argNames || argNames.includes(argName)) {
              addOperationVariable(resolveVariable(arg, argName));
            }
          }
        }
        return {
          kind: graphql_1.Kind.OPERATION_DEFINITION,
          operation: kind,
          name: {
            kind: graphql_1.Kind.NAME,
            value: operationName
          },
          variableDefinitions: [],
          selectionSet: {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [
              resolveField({
                type,
                field,
                models,
                firstCall: true,
                path: [],
                ancestors: [],
                ignore,
                depthLimit,
                circularReferenceDepth,
                schema,
                depth: 0,
                argNames,
                selectedFields,
                rootTypeNames
              })
            ]
          }
        };
      }
      function resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
        if (typeof selectedFields === "boolean" && depth > depthLimit) {
          return;
        }
        if ((0, graphql_1.isUnionType)(type)) {
          const types = type.getTypes();
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: types.filter((t2) => !hasCircularRef([...ancestors, t2], {
              depth: circularReferenceDepth
            })).map((t2) => {
              return {
                kind: graphql_1.Kind.INLINE_FRAGMENT,
                typeCondition: {
                  kind: graphql_1.Kind.NAMED_TYPE,
                  name: {
                    kind: graphql_1.Kind.NAME,
                    value: t2.name
                  }
                },
                selectionSet: resolveSelectionSet({
                  parent: type,
                  type: t2,
                  models,
                  path,
                  ancestors,
                  ignore,
                  depthLimit,
                  circularReferenceDepth,
                  schema,
                  depth,
                  argNames,
                  selectedFields,
                  rootTypeNames
                })
              };
            }).filter((fragmentNode) => {
              var _a, _b;
              return ((_b = (_a = fragmentNode == null ? void 0 : fragmentNode.selectionSet) == null ? void 0 : _a.selections) == null ? void 0 : _b.length) > 0;
            })
          };
        }
        if ((0, graphql_1.isInterfaceType)(type)) {
          const types = Object.values(schema.getTypeMap()).filter((t2) => (0, graphql_1.isObjectType)(t2) && t2.getInterfaces().includes(type));
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: types.filter((t2) => !hasCircularRef([...ancestors, t2], {
              depth: circularReferenceDepth
            })).map((t2) => {
              return {
                kind: graphql_1.Kind.INLINE_FRAGMENT,
                typeCondition: {
                  kind: graphql_1.Kind.NAMED_TYPE,
                  name: {
                    kind: graphql_1.Kind.NAME,
                    value: t2.name
                  }
                },
                selectionSet: resolveSelectionSet({
                  parent: type,
                  type: t2,
                  models,
                  path,
                  ancestors,
                  ignore,
                  depthLimit,
                  circularReferenceDepth,
                  schema,
                  depth,
                  argNames,
                  selectedFields,
                  rootTypeNames
                })
              };
            }).filter((fragmentNode) => {
              var _a, _b;
              return ((_b = (_a = fragmentNode == null ? void 0 : fragmentNode.selectionSet) == null ? void 0 : _a.selections) == null ? void 0 : _b.length) > 0;
            })
          };
        }
        if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {
          const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);
          const isModel = models.includes(type.name);
          if (!firstCall && isModel && !isIgnored) {
            return {
              kind: graphql_1.Kind.SELECTION_SET,
              selections: [
                {
                  kind: graphql_1.Kind.FIELD,
                  name: {
                    kind: graphql_1.Kind.NAME,
                    value: "id"
                  }
                }
              ]
            };
          }
          const fields = type.getFields();
          return {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: Object.keys(fields).filter((fieldName) => {
              return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {
                depth: circularReferenceDepth
              });
            }).map((fieldName) => {
              const selectedSubFields = typeof selectedFields === "object" ? selectedFields[fieldName] : true;
              if (selectedSubFields) {
                return resolveField({
                  type,
                  field: fields[fieldName],
                  models,
                  path: [...path, fieldName],
                  ancestors,
                  ignore,
                  depthLimit,
                  circularReferenceDepth,
                  schema,
                  depth,
                  argNames,
                  selectedFields: selectedSubFields,
                  rootTypeNames
                });
              }
              return null;
            }).filter((f2) => {
              var _a, _b;
              if (f2 == null) {
                return false;
              } else if ("selectionSet" in f2) {
                return !!((_b = (_a = f2.selectionSet) == null ? void 0 : _a.selections) == null ? void 0 : _b.length);
              }
              return true;
            })
          };
        }
      }
      function resolveVariable(arg, name2) {
        function resolveVariableType(type) {
          if ((0, graphql_1.isListType)(type)) {
            return {
              kind: graphql_1.Kind.LIST_TYPE,
              type: resolveVariableType(type.ofType)
            };
          }
          if ((0, graphql_1.isNonNullType)(type)) {
            return {
              kind: graphql_1.Kind.NON_NULL_TYPE,
              // for v16 compatibility
              type: resolveVariableType(type.ofType)
            };
          }
          return {
            kind: graphql_1.Kind.NAMED_TYPE,
            name: {
              kind: graphql_1.Kind.NAME,
              value: type.name
            }
          };
        }
        return {
          kind: graphql_1.Kind.VARIABLE_DEFINITION,
          variable: {
            kind: graphql_1.Kind.VARIABLE,
            name: {
              kind: graphql_1.Kind.NAME,
              value: name2 || arg.name
            }
          },
          type: resolveVariableType(arg.type)
        };
      }
      function getArgumentName(name2, path) {
        return [...path, name2].join("_");
      }
      function resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames }) {
        const namedType = (0, graphql_1.getNamedType)(field.type);
        let args = [];
        let removeField = false;
        if (field.args && field.args.length) {
          args = field.args.map((arg) => {
            const argumentName = getArgumentName(arg.name, path);
            if (argNames && !argNames.includes(argumentName)) {
              if ((0, graphql_1.isNonNullType)(arg.type)) {
                removeField = true;
              }
              return null;
            }
            if (!firstCall) {
              addOperationVariable(resolveVariable(arg, argumentName));
            }
            return {
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: arg.name
              },
              value: {
                kind: graphql_1.Kind.VARIABLE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: getArgumentName(arg.name, path)
                }
              }
            };
          }).filter(Boolean);
        }
        if (removeField) {
          return null;
        }
        const fieldPath = [...path, field.name];
        const fieldPathStr = fieldPath.join(".");
        let fieldName = field.name;
        if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {
          fieldName += field.type.toString().replace("!", "NonNull").replace("[", "List").replace("]", "");
        }
        fieldTypeMap.set(fieldPathStr, field.type.toString());
        if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {
          return __spreadProps(__spreadValues({
            kind: graphql_1.Kind.FIELD,
            name: {
              kind: graphql_1.Kind.NAME,
              value: field.name
            }
          }, fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } }), {
            selectionSet: resolveSelectionSet({
              parent: type,
              type: namedType,
              models,
              firstCall,
              path: fieldPath,
              ancestors: [...ancestors, type],
              ignore,
              depthLimit,
              circularReferenceDepth,
              schema,
              depth: depth + 1,
              argNames,
              selectedFields,
              rootTypeNames
            }) || void 0,
            arguments: args
          });
        }
        return __spreadProps(__spreadValues({
          kind: graphql_1.Kind.FIELD,
          name: {
            kind: graphql_1.Kind.NAME,
            value: field.name
          }
        }, fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } }), {
          arguments: args
        });
      }
      function hasCircularRef(types, config2 = {
        depth: 1
      }) {
        const type = types[types.length - 1];
        if ((0, graphql_1.isScalarType)(type)) {
          return false;
        }
        const size = types.filter((t2) => t2.name === type.name).length;
        return size > config2.depth;
      }
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/types.js
  var require_types = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/types.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DirectiveLocation = void 0;
      var DirectiveLocation2;
      (function(DirectiveLocation3) {
        DirectiveLocation3["QUERY"] = "QUERY";
        DirectiveLocation3["MUTATION"] = "MUTATION";
        DirectiveLocation3["SUBSCRIPTION"] = "SUBSCRIPTION";
        DirectiveLocation3["FIELD"] = "FIELD";
        DirectiveLocation3["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
        DirectiveLocation3["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
        DirectiveLocation3["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
        DirectiveLocation3["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
        DirectiveLocation3["SCHEMA"] = "SCHEMA";
        DirectiveLocation3["SCALAR"] = "SCALAR";
        DirectiveLocation3["OBJECT"] = "OBJECT";
        DirectiveLocation3["FIELD_DEFINITION"] = "FIELD_DEFINITION";
        DirectiveLocation3["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
        DirectiveLocation3["INTERFACE"] = "INTERFACE";
        DirectiveLocation3["UNION"] = "UNION";
        DirectiveLocation3["ENUM"] = "ENUM";
        DirectiveLocation3["ENUM_VALUE"] = "ENUM_VALUE";
        DirectiveLocation3["INPUT_OBJECT"] = "INPUT_OBJECT";
        DirectiveLocation3["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
      })(DirectiveLocation2 || (exports2.DirectiveLocation = DirectiveLocation2 = {}));
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/Interfaces.js
  var require_Interfaces = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/Interfaces.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.MapperKind = void 0;
      var MapperKind;
      (function(MapperKind2) {
        MapperKind2["TYPE"] = "MapperKind.TYPE";
        MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
        MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
        MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
        MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
        MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
        MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
        MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
        MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
        MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
        MapperKind2["QUERY"] = "MapperKind.QUERY";
        MapperKind2["MUTATION"] = "MapperKind.MUTATION";
        MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
        MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
        MapperKind2["FIELD"] = "MapperKind.FIELD";
        MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
        MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
        MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
        MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
        MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
        MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
        MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
        MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
        MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
        MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
      })(MapperKind || (exports2.MapperKind = MapperKind = {}));
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js
  var require_getObjectTypeFromTypeMap = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/getObjectTypeFromTypeMap.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getObjectTypeFromTypeMap = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function getObjectTypeFromTypeMap(typeMap, type) {
        if (type) {
          const maybeObjectType = typeMap[type.name];
          if ((0, graphql_1.isObjectType)(maybeObjectType)) {
            return maybeObjectType;
          }
        }
      }
      exports2.getObjectTypeFromTypeMap = getObjectTypeFromTypeMap;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/stub.js
  var require_stub = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/stub.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getBuiltInForStub = exports2.isNamedStub = exports2.createStub = exports2.createNamedStub = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function createNamedStub(name2, type) {
        let constructor;
        if (type === "object") {
          constructor = graphql_1.GraphQLObjectType;
        } else if (type === "interface") {
          constructor = graphql_1.GraphQLInterfaceType;
        } else {
          constructor = graphql_1.GraphQLInputObjectType;
        }
        return new constructor({
          name: name2,
          fields: {
            _fake: {
              type: graphql_1.GraphQLString
            }
          }
        });
      }
      exports2.createNamedStub = createNamedStub;
      function createStub(node, type) {
        switch (node.kind) {
          case graphql_1.Kind.LIST_TYPE:
            return new graphql_1.GraphQLList(createStub(node.type, type));
          case graphql_1.Kind.NON_NULL_TYPE:
            return new graphql_1.GraphQLNonNull(createStub(node.type, type));
          default:
            if (type === "output") {
              return createNamedStub(node.name.value, "object");
            }
            return createNamedStub(node.name.value, "input");
        }
      }
      exports2.createStub = createStub;
      function isNamedStub(type) {
        if ("getFields" in type) {
          const fields = type.getFields();
          for (const fieldName in fields) {
            const field = fields[fieldName];
            return field.name === "_fake";
          }
        }
        return false;
      }
      exports2.isNamedStub = isNamedStub;
      function getBuiltInForStub(type) {
        switch (type.name) {
          case graphql_1.GraphQLInt.name:
            return graphql_1.GraphQLInt;
          case graphql_1.GraphQLFloat.name:
            return graphql_1.GraphQLFloat;
          case graphql_1.GraphQLString.name:
            return graphql_1.GraphQLString;
          case graphql_1.GraphQLBoolean.name:
            return graphql_1.GraphQLBoolean;
          case graphql_1.GraphQLID.name:
            return graphql_1.GraphQLID;
          default:
            return type;
        }
      }
      exports2.getBuiltInForStub = getBuiltInForStub;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/rewire.js
  var require_rewire = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/rewire.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.rewireTypes = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var stub_js_1 = require_stub();
      function rewireTypes(originalTypeMap, directives) {
        const referenceTypeMap = /* @__PURE__ */ Object.create(null);
        for (const typeName in originalTypeMap) {
          referenceTypeMap[typeName] = originalTypeMap[typeName];
        }
        const newTypeMap = /* @__PURE__ */ Object.create(null);
        for (const typeName in referenceTypeMap) {
          const namedType = referenceTypeMap[typeName];
          if (namedType == null || typeName.startsWith("__")) {
            continue;
          }
          const newName = namedType.name;
          if (newName.startsWith("__")) {
            continue;
          }
          if (newTypeMap[newName] != null) {
            console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
            continue;
          }
          newTypeMap[newName] = namedType;
        }
        for (const typeName in newTypeMap) {
          newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
        }
        const newDirectives = directives.map((directive) => rewireDirective(directive));
        return {
          typeMap: newTypeMap,
          directives: newDirectives
        };
        function rewireDirective(directive) {
          if ((0, graphql_1.isSpecifiedDirective)(directive)) {
            return directive;
          }
          const directiveConfig = directive.toConfig();
          directiveConfig.args = rewireArgs(directiveConfig.args);
          return new graphql_1.GraphQLDirective(directiveConfig);
        }
        function rewireArgs(args) {
          const rewiredArgs = {};
          for (const argName in args) {
            const arg = args[argName];
            const rewiredArgType = rewireType(arg.type);
            if (rewiredArgType != null) {
              arg.type = rewiredArgType;
              rewiredArgs[argName] = arg;
            }
          }
          return rewiredArgs;
        }
        function rewireNamedType(type) {
          if ((0, graphql_1.isObjectType)(type)) {
            const config2 = type.toConfig();
            const newConfig = __spreadProps(__spreadValues({}, config2), {
              fields: () => rewireFields(config2.fields),
              interfaces: () => rewireNamedTypes(config2.interfaces)
            });
            return new graphql_1.GraphQLObjectType(newConfig);
          } else if ((0, graphql_1.isInterfaceType)(type)) {
            const config2 = type.toConfig();
            const newConfig = __spreadProps(__spreadValues({}, config2), {
              fields: () => rewireFields(config2.fields)
            });
            if ("interfaces" in newConfig) {
              newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);
            }
            return new graphql_1.GraphQLInterfaceType(newConfig);
          } else if ((0, graphql_1.isUnionType)(type)) {
            const config2 = type.toConfig();
            const newConfig = __spreadProps(__spreadValues({}, config2), {
              types: () => rewireNamedTypes(config2.types)
            });
            return new graphql_1.GraphQLUnionType(newConfig);
          } else if ((0, graphql_1.isInputObjectType)(type)) {
            const config2 = type.toConfig();
            const newConfig = __spreadProps(__spreadValues({}, config2), {
              fields: () => rewireInputFields(config2.fields)
            });
            return new graphql_1.GraphQLInputObjectType(newConfig);
          } else if ((0, graphql_1.isEnumType)(type)) {
            const enumConfig = type.toConfig();
            return new graphql_1.GraphQLEnumType(enumConfig);
          } else if ((0, graphql_1.isScalarType)(type)) {
            if ((0, graphql_1.isSpecifiedScalarType)(type)) {
              return type;
            }
            const scalarConfig = type.toConfig();
            return new graphql_1.GraphQLScalarType(scalarConfig);
          }
          throw new Error(`Unexpected schema type: ${type}`);
        }
        function rewireFields(fields) {
          const rewiredFields = {};
          for (const fieldName in fields) {
            const field = fields[fieldName];
            const rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null && field.args) {
              field.type = rewiredFieldType;
              field.args = rewireArgs(field.args);
              rewiredFields[fieldName] = field;
            }
          }
          return rewiredFields;
        }
        function rewireInputFields(fields) {
          const rewiredFields = {};
          for (const fieldName in fields) {
            const field = fields[fieldName];
            const rewiredFieldType = rewireType(field.type);
            if (rewiredFieldType != null) {
              field.type = rewiredFieldType;
              rewiredFields[fieldName] = field;
            }
          }
          return rewiredFields;
        }
        function rewireNamedTypes(namedTypes) {
          const rewiredTypes = [];
          for (const namedType of namedTypes) {
            const rewiredType = rewireType(namedType);
            if (rewiredType != null) {
              rewiredTypes.push(rewiredType);
            }
          }
          return rewiredTypes;
        }
        function rewireType(type) {
          if ((0, graphql_1.isListType)(type)) {
            const rewiredType = rewireType(type.ofType);
            return rewiredType != null ? new graphql_1.GraphQLList(rewiredType) : null;
          } else if ((0, graphql_1.isNonNullType)(type)) {
            const rewiredType = rewireType(type.ofType);
            return rewiredType != null ? new graphql_1.GraphQLNonNull(rewiredType) : null;
          } else if ((0, graphql_1.isNamedType)(type)) {
            let rewiredType = referenceTypeMap[type.name];
            if (rewiredType === void 0) {
              rewiredType = (0, stub_js_1.isNamedStub)(type) ? (0, stub_js_1.getBuiltInForStub)(type) : rewireNamedType(type);
              newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
            }
            return rewiredType != null ? newTypeMap[rewiredType.name] : null;
          }
          return null;
        }
      }
      exports2.rewireTypes = rewireTypes;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/transformInputValue.js
  var require_transformInputValue = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/transformInputValue.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseInputValueLiteral = exports2.parseInputValue = exports2.serializeInputValue = exports2.transformInputValue = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var helpers_js_1 = require_helpers();
      function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
        if (value == null) {
          return value;
        }
        const nullableType = (0, graphql_1.getNullableType)(type);
        if ((0, graphql_1.isLeafType)(nullableType)) {
          return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
        } else if ((0, graphql_1.isListType)(nullableType)) {
          return (0, helpers_js_1.asArray)(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
        } else if ((0, graphql_1.isInputObjectType)(nullableType)) {
          const fields = nullableType.getFields();
          const newValue = {};
          for (const key in value) {
            const field = fields[key];
            if (field != null) {
              newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
            }
          }
          return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
        }
      }
      exports2.transformInputValue = transformInputValue;
      function serializeInputValue(type, value) {
        return transformInputValue(type, value, (t2, v2) => {
          try {
            return t2.serialize(v2);
          } catch (e2) {
            return v2;
          }
        });
      }
      exports2.serializeInputValue = serializeInputValue;
      function parseInputValue(type, value) {
        return transformInputValue(type, value, (t2, v2) => {
          try {
            return t2.parseValue(v2);
          } catch (e2) {
            return v2;
          }
        });
      }
      exports2.parseInputValue = parseInputValue;
      function parseInputValueLiteral(type, value) {
        return transformInputValue(type, value, (t2, v2) => t2.parseLiteral(v2, {}));
      }
      exports2.parseInputValueLiteral = parseInputValueLiteral;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/mapSchema.js
  var require_mapSchema = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/mapSchema.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.correctASTNodes = exports2.mapSchema = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap();
      var Interfaces_js_1 = require_Interfaces();
      var rewire_js_1 = require_rewire();
      var transformInputValue_js_1 = require_transformInputValue();
      function mapSchema(schema, schemaMapper = {}) {
        const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, (type) => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, (type) => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);
        const originalDirectives = schema.getDirectives();
        const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
        const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);
        return new graphql_1.GraphQLSchema(__spreadProps(__spreadValues({}, schema.toConfig()), {
          query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),
          mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),
          subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),
          types: Object.values(typeMap),
          directives
        }));
      }
      exports2.mapSchema = mapSchema;
      function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
        const newTypeMap = {};
        for (const typeName in originalTypeMap) {
          if (!typeName.startsWith("__")) {
            const originalType = originalTypeMap[typeName];
            if (originalType == null || !testFn(originalType)) {
              newTypeMap[typeName] = originalType;
              continue;
            }
            const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
            if (typeMapper == null) {
              newTypeMap[typeName] = originalType;
              continue;
            }
            const maybeNewType = typeMapper(originalType, schema);
            if (maybeNewType === void 0) {
              newTypeMap[typeName] = originalType;
              continue;
            }
            newTypeMap[typeName] = maybeNewType;
          }
        }
        return newTypeMap;
      }
      function mapEnumValues(originalTypeMap, schema, schemaMapper) {
        const enumValueMapper = getEnumValueMapper(schemaMapper);
        if (!enumValueMapper) {
          return originalTypeMap;
        }
        return mapTypes(originalTypeMap, schema, {
          [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
            const config2 = type.toConfig();
            const originalEnumValueConfigMap = config2.values;
            const newEnumValueConfigMap = {};
            for (const externalValue in originalEnumValueConfigMap) {
              const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
              const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);
              if (mappedEnumValue === void 0) {
                newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
              } else if (Array.isArray(mappedEnumValue)) {
                const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
                newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
              } else if (mappedEnumValue !== null) {
                newEnumValueConfigMap[externalValue] = mappedEnumValue;
              }
            }
            return correctASTNodes(new graphql_1.GraphQLEnumType(__spreadProps(__spreadValues({}, config2), {
              values: newEnumValueConfigMap
            })));
          }
        }, (type) => (0, graphql_1.isEnumType)(type));
      }
      function mapDefaultValues(originalTypeMap, schema, fn) {
        const newTypeMap = mapArguments(originalTypeMap, schema, {
          [Interfaces_js_1.MapperKind.ARGUMENT]: (argumentConfig) => {
            if (argumentConfig.defaultValue === void 0) {
              return argumentConfig;
            }
            const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
            if (maybeNewType != null) {
              return __spreadProps(__spreadValues({}, argumentConfig), {
                defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
              });
            }
          }
        });
        return mapFields(newTypeMap, schema, {
          [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
            if (inputFieldConfig.defaultValue === void 0) {
              return inputFieldConfig;
            }
            const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
            if (maybeNewType != null) {
              return __spreadProps(__spreadValues({}, inputFieldConfig), {
                defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
              });
            }
          }
        });
      }
      function getNewType(newTypeMap, type) {
        if ((0, graphql_1.isListType)(type)) {
          const newType = getNewType(newTypeMap, type.ofType);
          return newType != null ? new graphql_1.GraphQLList(newType) : null;
        } else if ((0, graphql_1.isNonNullType)(type)) {
          const newType = getNewType(newTypeMap, type.ofType);
          return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;
        } else if ((0, graphql_1.isNamedType)(type)) {
          const newType = newTypeMap[type.name];
          return newType != null ? newType : null;
        }
        return null;
      }
      function mapFields(originalTypeMap, schema, schemaMapper) {
        const newTypeMap = {};
        for (const typeName in originalTypeMap) {
          if (!typeName.startsWith("__")) {
            const originalType = originalTypeMap[typeName];
            if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {
              newTypeMap[typeName] = originalType;
              continue;
            }
            const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
            if (fieldMapper == null) {
              newTypeMap[typeName] = originalType;
              continue;
            }
            const config2 = originalType.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
              if (mappedField === void 0) {
                newFieldConfigMap[fieldName] = originalFieldConfig;
              } else if (Array.isArray(mappedField)) {
                const [newFieldName, newFieldConfig] = mappedField;
                if (newFieldConfig.astNode != null) {
                  newFieldConfig.astNode = __spreadProps(__spreadValues({}, newFieldConfig.astNode), {
                    name: __spreadProps(__spreadValues({}, newFieldConfig.astNode.name), {
                      value: newFieldName
                    })
                  });
                }
                newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
              } else if (mappedField !== null) {
                newFieldConfigMap[fieldName] = mappedField;
              }
            }
            if ((0, graphql_1.isObjectType)(originalType)) {
              newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
                fields: newFieldConfigMap
              })));
            } else if ((0, graphql_1.isInterfaceType)(originalType)) {
              newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {
                fields: newFieldConfigMap
              })));
            } else {
              newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {
                fields: newFieldConfigMap
              })));
            }
          }
        }
        return newTypeMap;
      }
      function mapArguments(originalTypeMap, schema, schemaMapper) {
        const newTypeMap = {};
        for (const typeName in originalTypeMap) {
          if (!typeName.startsWith("__")) {
            const originalType = originalTypeMap[typeName];
            if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {
              newTypeMap[typeName] = originalType;
              continue;
            }
            const argumentMapper = getArgumentMapper(schemaMapper);
            if (argumentMapper == null) {
              newTypeMap[typeName] = originalType;
              continue;
            }
            const config2 = originalType.toConfig();
            const originalFieldConfigMap = config2.fields;
            const newFieldConfigMap = {};
            for (const fieldName in originalFieldConfigMap) {
              const originalFieldConfig = originalFieldConfigMap[fieldName];
              const originalArgumentConfigMap = originalFieldConfig.args;
              if (originalArgumentConfigMap == null) {
                newFieldConfigMap[fieldName] = originalFieldConfig;
                continue;
              }
              const argumentNames = Object.keys(originalArgumentConfigMap);
              if (!argumentNames.length) {
                newFieldConfigMap[fieldName] = originalFieldConfig;
                continue;
              }
              const newArgumentConfigMap = {};
              for (const argumentName of argumentNames) {
                const originalArgumentConfig = originalArgumentConfigMap[argumentName];
                const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
                if (mappedArgument === void 0) {
                  newArgumentConfigMap[argumentName] = originalArgumentConfig;
                } else if (Array.isArray(mappedArgument)) {
                  const [newArgumentName, newArgumentConfig] = mappedArgument;
                  newArgumentConfigMap[newArgumentName] = newArgumentConfig;
                } else if (mappedArgument !== null) {
                  newArgumentConfigMap[argumentName] = mappedArgument;
                }
              }
              newFieldConfigMap[fieldName] = __spreadProps(__spreadValues({}, originalFieldConfig), {
                args: newArgumentConfigMap
              });
            }
            if ((0, graphql_1.isObjectType)(originalType)) {
              newTypeMap[typeName] = new graphql_1.GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
                fields: newFieldConfigMap
              }));
            } else if ((0, graphql_1.isInterfaceType)(originalType)) {
              newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {
                fields: newFieldConfigMap
              }));
            } else {
              newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {
                fields: newFieldConfigMap
              }));
            }
          }
        }
        return newTypeMap;
      }
      function mapDirectives(originalDirectives, schema, schemaMapper) {
        const directiveMapper = getDirectiveMapper(schemaMapper);
        if (directiveMapper == null) {
          return originalDirectives.slice();
        }
        const newDirectives = [];
        for (const directive of originalDirectives) {
          const mappedDirective = directiveMapper(directive, schema);
          if (mappedDirective === void 0) {
            newDirectives.push(directive);
          } else if (mappedDirective !== null) {
            newDirectives.push(mappedDirective);
          }
        }
        return newDirectives;
      }
      function getTypeSpecifiers(schema, typeName) {
        var _a, _b, _c;
        const type = schema.getType(typeName);
        const specifiers = [Interfaces_js_1.MapperKind.TYPE];
        if ((0, graphql_1.isObjectType)(type)) {
          specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);
          if (typeName === ((_a = schema.getQueryType()) == null ? void 0 : _a.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);
          } else if (typeName === ((_b = schema.getMutationType()) == null ? void 0 : _b.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);
          } else if (typeName === ((_c = schema.getSubscriptionType()) == null ? void 0 : _c.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);
          }
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);
        } else if ((0, graphql_1.isUnionType)(type)) {
          specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);
        } else if ((0, graphql_1.isEnumType)(type)) {
          specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);
        } else if ((0, graphql_1.isScalarType)(type)) {
          specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);
        }
        return specifiers;
      }
      function getTypeMapper(schema, schemaMapper, typeName) {
        const specifiers = getTypeSpecifiers(schema, typeName);
        let typeMapper;
        const stack = [...specifiers];
        while (!typeMapper && stack.length > 0) {
          const next = stack.pop();
          typeMapper = schemaMapper[next];
        }
        return typeMapper != null ? typeMapper : null;
      }
      function getFieldSpecifiers(schema, typeName) {
        var _a, _b, _c;
        const type = schema.getType(typeName);
        const specifiers = [Interfaces_js_1.MapperKind.FIELD];
        if ((0, graphql_1.isObjectType)(type)) {
          specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);
          if (typeName === ((_a = schema.getQueryType()) == null ? void 0 : _a.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);
          } else if (typeName === ((_b = schema.getMutationType()) == null ? void 0 : _b.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);
          } else if (typeName === ((_c = schema.getSubscriptionType()) == null ? void 0 : _c.name)) {
            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);
          }
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);
        }
        return specifiers;
      }
      function getFieldMapper(schema, schemaMapper, typeName) {
        const specifiers = getFieldSpecifiers(schema, typeName);
        let fieldMapper;
        const stack = [...specifiers];
        while (!fieldMapper && stack.length > 0) {
          const next = stack.pop();
          fieldMapper = schemaMapper[next];
        }
        return fieldMapper != null ? fieldMapper : null;
      }
      function getArgumentMapper(schemaMapper) {
        const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];
        return argumentMapper != null ? argumentMapper : null;
      }
      function getDirectiveMapper(schemaMapper) {
        const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];
        return directiveMapper != null ? directiveMapper : null;
      }
      function getEnumValueMapper(schemaMapper) {
        const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];
        return enumValueMapper != null ? enumValueMapper : null;
      }
      function correctASTNodes(type) {
        if ((0, graphql_1.isObjectType)(type)) {
          const config2 = type.toConfig();
          if (config2.astNode != null) {
            const fields = [];
            for (const fieldName in config2.fields) {
              const fieldConfig = config2.fields[fieldName];
              if (fieldConfig.astNode != null) {
                fields.push(fieldConfig.astNode);
              }
            }
            config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {
              kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
              fields
            });
          }
          if (config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
              kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
              fields: void 0
            }));
          }
          return new graphql_1.GraphQLObjectType(config2);
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          const config2 = type.toConfig();
          if (config2.astNode != null) {
            const fields = [];
            for (const fieldName in config2.fields) {
              const fieldConfig = config2.fields[fieldName];
              if (fieldConfig.astNode != null) {
                fields.push(fieldConfig.astNode);
              }
            }
            config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {
              kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,
              fields
            });
          }
          if (config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
              kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,
              fields: void 0
            }));
          }
          return new graphql_1.GraphQLInterfaceType(config2);
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          const config2 = type.toConfig();
          if (config2.astNode != null) {
            const fields = [];
            for (const fieldName in config2.fields) {
              const fieldConfig = config2.fields[fieldName];
              if (fieldConfig.astNode != null) {
                fields.push(fieldConfig.astNode);
              }
            }
            config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {
              kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
              fields
            });
          }
          if (config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
              kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,
              fields: void 0
            }));
          }
          return new graphql_1.GraphQLInputObjectType(config2);
        } else if ((0, graphql_1.isEnumType)(type)) {
          const config2 = type.toConfig();
          if (config2.astNode != null) {
            const values = [];
            for (const enumKey in config2.values) {
              const enumValueConfig = config2.values[enumKey];
              if (enumValueConfig.astNode != null) {
                values.push(enumValueConfig.astNode);
              }
            }
            config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {
              values
            });
          }
          if (config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
              values: void 0
            }));
          }
          return new graphql_1.GraphQLEnumType(config2);
        } else {
          return type;
        }
      }
      exports2.correctASTNodes = correctASTNodes;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/filterSchema.js
  var require_filterSchema = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/filterSchema.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.filterSchema = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var Interfaces_js_1 = require_Interfaces();
      var mapSchema_js_1 = require_mapSchema();
      function filterSchema({ schema, typeFilter = () => true, fieldFilter = void 0, rootFieldFilter = void 0, objectFieldFilter = void 0, interfaceFieldFilter = void 0, inputObjectFieldFilter = void 0, argumentFilter = void 0 }) {
        const filteredSchema = (0, mapSchema_js_1.mapSchema)(schema, {
          [Interfaces_js_1.MapperKind.QUERY]: (type) => filterRootFields(type, "Query", rootFieldFilter, argumentFilter),
          [Interfaces_js_1.MapperKind.MUTATION]: (type) => filterRootFields(type, "Mutation", rootFieldFilter, argumentFilter),
          [Interfaces_js_1.MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, "Subscription", rootFieldFilter, argumentFilter),
          [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLObjectType, type, objectFieldFilter || fieldFilter, argumentFilter) : null,
          [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInterfaceType, type, interfaceFieldFilter || fieldFilter, argumentFilter) : null,
          [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterElementFields(graphql_1.GraphQLInputObjectType, type, inputObjectFieldFilter || fieldFilter) : null,
          [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
          [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null,
          [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => typeFilter(type.name, type) ? void 0 : null
        });
        return filteredSchema;
      }
      exports2.filterSchema = filterSchema;
      function filterRootFields(type, operation, rootFieldFilter, argumentFilter) {
        if (rootFieldFilter || argumentFilter) {
          const config2 = type.toConfig();
          for (const fieldName in config2.fields) {
            const field = config2.fields[fieldName];
            if (rootFieldFilter && !rootFieldFilter(operation, fieldName, config2.fields[fieldName])) {
              delete config2.fields[fieldName];
            } else if (argumentFilter && field.args) {
              for (const argName in field.args) {
                if (!argumentFilter(operation, fieldName, argName, field.args[argName])) {
                  delete field.args[argName];
                }
              }
            }
          }
          return new graphql_1.GraphQLObjectType(config2);
        }
        return type;
      }
      function filterElementFields(ElementConstructor, type, fieldFilter, argumentFilter) {
        if (fieldFilter || argumentFilter) {
          const config2 = type.toConfig();
          for (const fieldName in config2.fields) {
            const field = config2.fields[fieldName];
            if (fieldFilter && !fieldFilter(type.name, fieldName, config2.fields[fieldName])) {
              delete config2.fields[fieldName];
            } else if (argumentFilter && "args" in field) {
              for (const argName in field.args) {
                if (!argumentFilter(type.name, fieldName, argName, field.args[argName])) {
                  delete field.args[argName];
                }
              }
            }
          }
          return new ElementConstructor(config2);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/heal.js
  var require_heal = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/heal.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.healTypes = exports2.healSchema = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function healSchema(schema) {
        healTypes(schema.getTypeMap(), schema.getDirectives());
        return schema;
      }
      exports2.healSchema = healSchema;
      function healTypes(originalTypeMap, directives) {
        const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
        for (const typeName in originalTypeMap) {
          const namedType = originalTypeMap[typeName];
          if (namedType == null || typeName.startsWith("__")) {
            continue;
          }
          const actualName = namedType.name;
          if (actualName.startsWith("__")) {
            continue;
          }
          if (actualNamedTypeMap[actualName] != null) {
            console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
            continue;
          }
          actualNamedTypeMap[actualName] = namedType;
        }
        for (const typeName in actualNamedTypeMap) {
          const namedType = actualNamedTypeMap[typeName];
          originalTypeMap[typeName] = namedType;
        }
        for (const decl of directives) {
          decl.args = decl.args.filter((arg) => {
            arg.type = healType(arg.type);
            return arg.type !== null;
          });
        }
        for (const typeName in originalTypeMap) {
          const namedType = originalTypeMap[typeName];
          if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
            if (namedType != null) {
              healNamedType(namedType);
            }
          }
        }
        for (const typeName in originalTypeMap) {
          if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
            delete originalTypeMap[typeName];
          }
        }
        function healNamedType(type) {
          if ((0, graphql_1.isObjectType)(type)) {
            healFields(type);
            healInterfaces(type);
            return;
          } else if ((0, graphql_1.isInterfaceType)(type)) {
            healFields(type);
            if ("getInterfaces" in type) {
              healInterfaces(type);
            }
            return;
          } else if ((0, graphql_1.isUnionType)(type)) {
            healUnderlyingTypes(type);
            return;
          } else if ((0, graphql_1.isInputObjectType)(type)) {
            healInputFields(type);
            return;
          } else if ((0, graphql_1.isLeafType)(type)) {
            return;
          }
          throw new Error(`Unexpected schema type: ${type}`);
        }
        function healFields(type) {
          const fieldMap = type.getFields();
          for (const [key, field] of Object.entries(fieldMap)) {
            field.args.map((arg) => {
              arg.type = healType(arg.type);
              return arg.type === null ? null : arg;
            }).filter(Boolean);
            field.type = healType(field.type);
            if (field.type === null) {
              delete fieldMap[key];
            }
          }
        }
        function healInterfaces(type) {
          if ("getInterfaces" in type) {
            const interfaces = type.getInterfaces();
            interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
          }
        }
        function healInputFields(type) {
          const fieldMap = type.getFields();
          for (const [key, field] of Object.entries(fieldMap)) {
            field.type = healType(field.type);
            if (field.type === null) {
              delete fieldMap[key];
            }
          }
        }
        function healUnderlyingTypes(type) {
          const types = type.getTypes();
          types.push(...types.splice(0).map((t2) => healType(t2)).filter(Boolean));
        }
        function healType(type) {
          if ((0, graphql_1.isListType)(type)) {
            const healedType = healType(type.ofType);
            return healedType != null ? new graphql_1.GraphQLList(healedType) : null;
          } else if ((0, graphql_1.isNonNullType)(type)) {
            const healedType = healType(type.ofType);
            return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;
          } else if ((0, graphql_1.isNamedType)(type)) {
            const officialType = originalTypeMap[type.name];
            if (officialType && type !== officialType) {
              return officialType;
            }
          }
          return type;
        }
      }
      exports2.healTypes = healTypes;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js
  var require_getResolversFromSchema = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/getResolversFromSchema.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getResolversFromSchema = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function getResolversFromSchema(schema, includeDefaultMergedResolver) {
        var _a, _b;
        const resolvers = /* @__PURE__ */ Object.create(null);
        const typeMap = schema.getTypeMap();
        for (const typeName in typeMap) {
          if (!typeName.startsWith("__")) {
            const type = typeMap[typeName];
            if ((0, graphql_1.isScalarType)(type)) {
              if (!(0, graphql_1.isSpecifiedScalarType)(type)) {
                const config2 = type.toConfig();
                delete config2.astNode;
                resolvers[typeName] = new graphql_1.GraphQLScalarType(config2);
              }
            } else if ((0, graphql_1.isEnumType)(type)) {
              resolvers[typeName] = {};
              const values = type.getValues();
              for (const value of values) {
                resolvers[typeName][value.name] = value.value;
              }
            } else if ((0, graphql_1.isInterfaceType)(type)) {
              if (type.resolveType != null) {
                resolvers[typeName] = {
                  __resolveType: type.resolveType
                };
              }
            } else if ((0, graphql_1.isUnionType)(type)) {
              if (type.resolveType != null) {
                resolvers[typeName] = {
                  __resolveType: type.resolveType
                };
              }
            } else if ((0, graphql_1.isObjectType)(type)) {
              resolvers[typeName] = {};
              if (type.isTypeOf != null) {
                resolvers[typeName].__isTypeOf = type.isTypeOf;
              }
              const fields = type.getFields();
              for (const fieldName in fields) {
                const field = fields[fieldName];
                if (field.subscribe != null) {
                  resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                  resolvers[typeName][fieldName].subscribe = field.subscribe;
                }
                if (field.resolve != null && ((_a = field.resolve) == null ? void 0 : _a.name) !== "defaultFieldResolver") {
                  switch ((_b = field.resolve) == null ? void 0 : _b.name) {
                    case "defaultMergedResolver":
                      if (!includeDefaultMergedResolver) {
                        continue;
                      }
                      break;
                    case "defaultFieldResolver":
                      continue;
                  }
                  resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
                  resolvers[typeName][fieldName].resolve = field.resolve;
                }
              }
            }
          }
        }
        return resolvers;
      }
      exports2.getResolversFromSchema = getResolversFromSchema;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/forEachField.js
  var require_forEachField = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/forEachField.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.forEachField = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function forEachField(schema, fn) {
        const typeMap = schema.getTypeMap();
        for (const typeName in typeMap) {
          const type = typeMap[typeName];
          if (!(0, graphql_1.getNamedType)(type).name.startsWith("__") && (0, graphql_1.isObjectType)(type)) {
            const fields = type.getFields();
            for (const fieldName in fields) {
              const field = fields[fieldName];
              fn(field, typeName, fieldName);
            }
          }
        }
      }
      exports2.forEachField = forEachField;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js
  var require_forEachDefaultValue = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/forEachDefaultValue.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.forEachDefaultValue = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function forEachDefaultValue(schema, fn) {
        const typeMap = schema.getTypeMap();
        for (const typeName in typeMap) {
          const type = typeMap[typeName];
          if (!(0, graphql_1.getNamedType)(type).name.startsWith("__")) {
            if ((0, graphql_1.isObjectType)(type)) {
              const fields = type.getFields();
              for (const fieldName in fields) {
                const field = fields[fieldName];
                for (const arg of field.args) {
                  arg.defaultValue = fn(arg.type, arg.defaultValue);
                }
              }
            } else if ((0, graphql_1.isInputObjectType)(type)) {
              const fields = type.getFields();
              for (const fieldName in fields) {
                const field = fields[fieldName];
                field.defaultValue = fn(field.type, field.defaultValue);
              }
            }
          }
        }
      }
      exports2.forEachDefaultValue = forEachDefaultValue;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/addTypes.js
  var require_addTypes = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/addTypes.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.addTypes = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var getObjectTypeFromTypeMap_js_1 = require_getObjectTypeFromTypeMap();
      var rewire_js_1 = require_rewire();
      function addTypes(schema, newTypesOrDirectives) {
        const config2 = schema.toConfig();
        const originalTypeMap = {};
        for (const type of config2.types) {
          originalTypeMap[type.name] = type;
        }
        const originalDirectiveMap = {};
        for (const directive of config2.directives) {
          originalDirectiveMap[directive.name] = directive;
        }
        for (const newTypeOrDirective of newTypesOrDirectives) {
          if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {
            originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;
          } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {
            originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;
          }
        }
        const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));
        return new graphql_1.GraphQLSchema(__spreadProps(__spreadValues({}, config2), {
          query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),
          mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),
          subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),
          types: Object.values(typeMap),
          directives
        }));
      }
      exports2.addTypes = addTypes;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/prune.js
  var require_prune = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/prune.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.pruneSchema = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var mapSchema_js_1 = require_mapSchema();
      var Interfaces_js_1 = require_Interfaces();
      var rootTypes_js_1 = require_rootTypes();
      var get_implementing_types_js_1 = require_get_implementing_types();
      function pruneSchema(schema, options = {}) {
        const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning } = options;
        let prunedTypes = [];
        let prunedSchema = schema;
        do {
          let visited = visitSchema(prunedSchema);
          if (skipPruning) {
            const revisit = [];
            for (const typeName in prunedSchema.getTypeMap()) {
              if (typeName.startsWith("__")) {
                continue;
              }
              const type = prunedSchema.getType(typeName);
              if (type && skipPruning(type)) {
                revisit.push(typeName);
              }
            }
            visited = visitQueue(revisit, prunedSchema, visited);
          }
          prunedTypes = [];
          prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {
            [Interfaces_js_1.MapperKind.TYPE]: (type) => {
              if (!visited.has(type.name) && !(0, graphql_1.isSpecifiedScalarType)(type)) {
                if ((0, graphql_1.isUnionType)(type) || (0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type) || (0, graphql_1.isScalarType)(type)) {
                  if (skipUnusedTypesPruning) {
                    return type;
                  }
                  if ((0, graphql_1.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {
                    return type;
                  }
                  if ((0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type)) {
                    if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {
                      return type;
                    }
                  }
                  if ((0, graphql_1.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {
                    return type;
                  }
                }
                prunedTypes.push(type.name);
                visited.delete(type.name);
                return null;
              }
              return type;
            }
          });
        } while (prunedTypes.length);
        return prunedSchema;
      }
      exports2.pruneSchema = pruneSchema;
      function visitSchema(schema) {
        const queue2 = [];
        for (const type of (0, rootTypes_js_1.getRootTypes)(schema)) {
          queue2.push(type.name);
        }
        return visitQueue(queue2, schema);
      }
      function visitQueue(queue2, schema, visited = /* @__PURE__ */ new Set()) {
        const revisit = /* @__PURE__ */ new Map();
        while (queue2.length) {
          const typeName = queue2.pop();
          if (visited.has(typeName) && revisit[typeName] !== true) {
            continue;
          }
          const type = schema.getType(typeName);
          if (type) {
            if ((0, graphql_1.isUnionType)(type)) {
              queue2.push(...type.getTypes().map((type2) => type2.name));
            }
            if ((0, graphql_1.isInterfaceType)(type) && revisit[typeName] === true) {
              queue2.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type.name, schema));
              revisit[typeName] = false;
            }
            if ((0, graphql_1.isEnumType)(type)) {
              queue2.push(...type.getValues().flatMap((value) => {
                if (value.astNode) {
                  return getDirectivesArgumentsTypeNames(schema, value.astNode);
                }
                return [];
              }));
            }
            if ("getInterfaces" in type) {
              queue2.push(...type.getInterfaces().map((iface) => iface.name));
            }
            if ("getFields" in type) {
              const fields = type.getFields();
              const entries = Object.entries(fields);
              if (!entries.length) {
                continue;
              }
              for (const [, field] of entries) {
                if ((0, graphql_1.isObjectType)(type)) {
                  queue2.push(...field.args.flatMap((arg) => {
                    const typeNames = [(0, graphql_1.getNamedType)(arg.type).name];
                    if (arg.astNode) {
                      typeNames.push(...getDirectivesArgumentsTypeNames(schema, arg.astNode));
                    }
                    return typeNames;
                  }));
                }
                const namedType = (0, graphql_1.getNamedType)(field.type);
                queue2.push(namedType.name);
                if (field.astNode) {
                  queue2.push(...getDirectivesArgumentsTypeNames(schema, field.astNode));
                }
                if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {
                  revisit[namedType.name] = true;
                }
              }
            }
            if (type.astNode) {
              queue2.push(...getDirectivesArgumentsTypeNames(schema, type.astNode));
            }
            visited.add(typeName);
          }
        }
        return visited;
      }
      function getDirectivesArgumentsTypeNames(schema, astNode) {
        var _a;
        return ((_a = astNode.directives) != null ? _a : []).flatMap((directive) => {
          var _a2, _b;
          return (_b = (_a2 = schema.getDirective(directive.name.value)) == null ? void 0 : _a2.args.map((arg) => (0, graphql_1.getNamedType)(arg.type).name)) != null ? _b : [];
        });
      }
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/mergeDeep.js
  var require_mergeDeep = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/mergeDeep.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeDeep = void 0;
      var helpers_js_1 = require_helpers();
      function mergeDeep(sources, respectPrototype = false) {
        const target = sources[0] || {};
        const output = {};
        if (respectPrototype) {
          Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
        }
        for (const source of sources) {
          if (isObject(target) && isObject(source)) {
            if (respectPrototype) {
              const outputPrototype = Object.getPrototypeOf(output);
              const sourcePrototype = Object.getPrototypeOf(source);
              if (sourcePrototype) {
                for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
                  const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
                  if ((0, helpers_js_1.isSome)(descriptor)) {
                    Object.defineProperty(outputPrototype, key, descriptor);
                  }
                }
              }
            }
            for (const key in source) {
              if (isObject(source[key])) {
                if (!(key in output)) {
                  Object.assign(output, { [key]: source[key] });
                } else {
                  output[key] = mergeDeep([output[key], source[key]], respectPrototype);
                }
              } else {
                Object.assign(output, { [key]: source[key] });
              }
            }
          }
        }
        return output;
      }
      exports2.mergeDeep = mergeDeep;
      function isObject(item) {
        return item && typeof item === "object" && !Array.isArray(item);
      }
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/selectionSets.js
  var require_selectionSets = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/selectionSets.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseSelectionSet = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function parseSelectionSet(selectionSet, options) {
        const query = (0, graphql_1.parse)(selectionSet, options).definitions[0];
        return query.selectionSet;
      }
      exports2.parseSelectionSet = parseSelectionSet;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js
  var require_getResponseKeyFromInfo = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/getResponseKeyFromInfo.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getResponseKeyFromInfo = void 0;
      function getResponseKeyFromInfo(info) {
        return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;
      }
      exports2.getResponseKeyFromInfo = getResponseKeyFromInfo;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/fields.js
  var require_fields = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/fields.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.modifyObjectFields = exports2.selectObjectFields = exports2.removeObjectFields = exports2.appendObjectFields = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var Interfaces_js_1 = require_Interfaces();
      var mapSchema_js_1 = require_mapSchema();
      var addTypes_js_1 = require_addTypes();
      function appendObjectFields(schema, typeName, additionalFields) {
        if (schema.getType(typeName) == null) {
          return (0, addTypes_js_1.addTypes)(schema, [
            new graphql_1.GraphQLObjectType({
              name: typeName,
              fields: additionalFields
            })
          ]);
        }
        return (0, mapSchema_js_1.mapSchema)(schema, {
          [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
            if (type.name === typeName) {
              const config2 = type.toConfig();
              const originalFieldConfigMap = config2.fields;
              const newFieldConfigMap = {};
              for (const fieldName in originalFieldConfigMap) {
                newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];
              }
              for (const fieldName in additionalFields) {
                newFieldConfigMap[fieldName] = additionalFields[fieldName];
              }
              return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
                fields: newFieldConfigMap
              })));
            }
          }
        });
      }
      exports2.appendObjectFields = appendObjectFields;
      function removeObjectFields(schema, typeName, testFn) {
        const removedFields = {};
        const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
          [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
            if (type.name === typeName) {
              const config2 = type.toConfig();
              const originalFieldConfigMap = config2.fields;
              const newFieldConfigMap = {};
              for (const fieldName in originalFieldConfigMap) {
                const originalFieldConfig = originalFieldConfigMap[fieldName];
                if (testFn(fieldName, originalFieldConfig)) {
                  removedFields[fieldName] = originalFieldConfig;
                } else {
                  newFieldConfigMap[fieldName] = originalFieldConfig;
                }
              }
              return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
                fields: newFieldConfigMap
              })));
            }
          }
        });
        return [newSchema, removedFields];
      }
      exports2.removeObjectFields = removeObjectFields;
      function selectObjectFields(schema, typeName, testFn) {
        const selectedFields = {};
        (0, mapSchema_js_1.mapSchema)(schema, {
          [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
            if (type.name === typeName) {
              const config2 = type.toConfig();
              const originalFieldConfigMap = config2.fields;
              for (const fieldName in originalFieldConfigMap) {
                const originalFieldConfig = originalFieldConfigMap[fieldName];
                if (testFn(fieldName, originalFieldConfig)) {
                  selectedFields[fieldName] = originalFieldConfig;
                }
              }
            }
            return void 0;
          }
        });
        return selectedFields;
      }
      exports2.selectObjectFields = selectObjectFields;
      function modifyObjectFields(schema, typeName, testFn, newFields) {
        const removedFields = {};
        const newSchema = (0, mapSchema_js_1.mapSchema)(schema, {
          [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
            if (type.name === typeName) {
              const config2 = type.toConfig();
              const originalFieldConfigMap = config2.fields;
              const newFieldConfigMap = {};
              for (const fieldName in originalFieldConfigMap) {
                const originalFieldConfig = originalFieldConfigMap[fieldName];
                if (testFn(fieldName, originalFieldConfig)) {
                  removedFields[fieldName] = originalFieldConfig;
                } else {
                  newFieldConfigMap[fieldName] = originalFieldConfig;
                }
              }
              for (const fieldName in newFields) {
                const fieldConfig = newFields[fieldName];
                newFieldConfigMap[fieldName] = fieldConfig;
              }
              return (0, mapSchema_js_1.correctASTNodes)(new graphql_1.GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
                fields: newFieldConfigMap
              })));
            }
          }
        });
        return [newSchema, removedFields];
      }
      exports2.modifyObjectFields = modifyObjectFields;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/renameType.js
  var require_renameType = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/renameType.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.renameType = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function renameType(type, newTypeName) {
        if ((0, graphql_1.isObjectType)(type)) {
          return new graphql_1.GraphQLObjectType(__spreadProps(__spreadValues({}, type.toConfig()), {
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : __spreadProps(__spreadValues({}, type.astNode), {
              name: __spreadProps(__spreadValues({}, type.astNode.name), {
                value: newTypeName
              })
            }),
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
              name: __spreadProps(__spreadValues({}, node.name), {
                value: newTypeName
              })
            }))
          }));
        } else if ((0, graphql_1.isInterfaceType)(type)) {
          return new graphql_1.GraphQLInterfaceType(__spreadProps(__spreadValues({}, type.toConfig()), {
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : __spreadProps(__spreadValues({}, type.astNode), {
              name: __spreadProps(__spreadValues({}, type.astNode.name), {
                value: newTypeName
              })
            }),
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
              name: __spreadProps(__spreadValues({}, node.name), {
                value: newTypeName
              })
            }))
          }));
        } else if ((0, graphql_1.isUnionType)(type)) {
          return new graphql_1.GraphQLUnionType(__spreadProps(__spreadValues({}, type.toConfig()), {
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : __spreadProps(__spreadValues({}, type.astNode), {
              name: __spreadProps(__spreadValues({}, type.astNode.name), {
                value: newTypeName
              })
            }),
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
              name: __spreadProps(__spreadValues({}, node.name), {
                value: newTypeName
              })
            }))
          }));
        } else if ((0, graphql_1.isInputObjectType)(type)) {
          return new graphql_1.GraphQLInputObjectType(__spreadProps(__spreadValues({}, type.toConfig()), {
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : __spreadProps(__spreadValues({}, type.astNode), {
              name: __spreadProps(__spreadValues({}, type.astNode.name), {
                value: newTypeName
              })
            }),
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
              name: __spreadProps(__spreadValues({}, node.name), {
                value: newTypeName
              })
            }))
          }));
        } else if ((0, graphql_1.isEnumType)(type)) {
          return new graphql_1.GraphQLEnumType(__spreadProps(__spreadValues({}, type.toConfig()), {
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : __spreadProps(__spreadValues({}, type.astNode), {
              name: __spreadProps(__spreadValues({}, type.astNode.name), {
                value: newTypeName
              })
            }),
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
              name: __spreadProps(__spreadValues({}, node.name), {
                value: newTypeName
              })
            }))
          }));
        } else if ((0, graphql_1.isScalarType)(type)) {
          return new graphql_1.GraphQLScalarType(__spreadProps(__spreadValues({}, type.toConfig()), {
            name: newTypeName,
            astNode: type.astNode == null ? type.astNode : __spreadProps(__spreadValues({}, type.astNode), {
              name: __spreadProps(__spreadValues({}, type.astNode.name), {
                value: newTypeName
              })
            }),
            extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
              name: __spreadProps(__spreadValues({}, node.name), {
                value: newTypeName
              })
            }))
          }));
        }
        throw new Error(`Unknown type ${type}.`);
      }
      exports2.renameType = renameType;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js
  var require_mapAsyncIterator = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/mapAsyncIterator.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mapAsyncIterator = void 0;
      function mapAsyncIterator2(iterator, callback, rejectCallback) {
        let $return;
        let abruptClose;
        if (typeof iterator.return === "function") {
          $return = iterator.return;
          abruptClose = (error) => {
            const rethrow = () => Promise.reject(error);
            return $return.call(iterator).then(rethrow, rethrow);
          };
        }
        function mapResult(result) {
          return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
        }
        let mapReject;
        if (rejectCallback) {
          const reject = rejectCallback;
          mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
        }
        return {
          next() {
            return iterator.next().then(mapResult, mapReject);
          },
          return() {
            return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
          },
          throw(error) {
            if (typeof iterator.throw === "function") {
              return iterator.throw(error).then(mapResult, mapReject);
            }
            return Promise.reject(error).catch(abruptClose);
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      exports2.mapAsyncIterator = mapAsyncIterator2;
      function asyncMapValue(value, callback) {
        return new Promise((resolve) => resolve(callback(value)));
      }
      function iteratorResult(value) {
        return { value, done: false };
      }
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/updateArgument.js
  var require_updateArgument = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/updateArgument.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createVariableNameGenerator = exports2.updateArgument = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var astFromType_js_1 = require_astFromType();
      function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type, value) {
        argumentNodes[argName] = {
          kind: graphql_1.Kind.ARGUMENT,
          name: {
            kind: graphql_1.Kind.NAME,
            value: argName
          },
          value: {
            kind: graphql_1.Kind.VARIABLE,
            name: {
              kind: graphql_1.Kind.NAME,
              value: varName
            }
          }
        };
        variableDefinitionsMap[varName] = {
          kind: graphql_1.Kind.VARIABLE_DEFINITION,
          variable: {
            kind: graphql_1.Kind.VARIABLE,
            name: {
              kind: graphql_1.Kind.NAME,
              value: varName
            }
          },
          type: (0, astFromType_js_1.astFromType)(type)
        };
        if (value !== void 0) {
          variableValues[varName] = value;
          return;
        }
        if (varName in variableValues) {
          delete variableValues[varName];
        }
      }
      exports2.updateArgument = updateArgument;
      function createVariableNameGenerator(variableDefinitionMap) {
        let varCounter = 0;
        return (argName) => {
          let varName;
          do {
            varName = `_v${(varCounter++).toString()}_${argName}`;
          } while (varName in variableDefinitionMap);
          return varName;
        };
      }
      exports2.createVariableNameGenerator = createVariableNameGenerator;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js
  var require_implementsAbstractType = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/implementsAbstractType.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.implementsAbstractType = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function implementsAbstractType(schema, typeA, typeB) {
        if (typeB == null || typeA == null) {
          return false;
        } else if (typeA === typeB) {
          return true;
        } else if ((0, graphql_1.isCompositeType)(typeA) && (0, graphql_1.isCompositeType)(typeB)) {
          return (0, graphql_1.doTypesOverlap)(schema, typeA, typeB);
        }
        return false;
      }
      exports2.implementsAbstractType = implementsAbstractType;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js
  var require_observableToAsyncIterable = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.observableToAsyncIterable = void 0;
      function observableToAsyncIterable(observable) {
        const pullQueue = [];
        const pushQueue = [];
        let listening = true;
        const pushValue = (value) => {
          if (pullQueue.length !== 0) {
            pullQueue.shift()({ value, done: false });
          } else {
            pushQueue.push({ value, done: false });
          }
        };
        const pushError = (error) => {
          if (pullQueue.length !== 0) {
            pullQueue.shift()({ value: { errors: [error] }, done: false });
          } else {
            pushQueue.push({ value: { errors: [error] }, done: false });
          }
        };
        const pushDone = () => {
          if (pullQueue.length !== 0) {
            pullQueue.shift()({ done: true });
          } else {
            pushQueue.push({ done: true });
          }
        };
        const pullValue = () => new Promise((resolve) => {
          if (pushQueue.length !== 0) {
            const element = pushQueue.shift();
            resolve(element);
          } else {
            pullQueue.push(resolve);
          }
        });
        const subscription = observable.subscribe({
          next(value) {
            pushValue(value);
          },
          error(err) {
            pushError(err);
          },
          complete() {
            pushDone();
          }
        });
        const emptyQueue = () => {
          if (listening) {
            listening = false;
            subscription.unsubscribe();
            for (const resolve of pullQueue) {
              resolve({ value: void 0, done: true });
            }
            pullQueue.length = 0;
            pushQueue.length = 0;
          }
        };
        return {
          next() {
            return listening ? pullValue() : this.return();
          },
          return() {
            emptyQueue();
            return Promise.resolve({ value: void 0, done: true });
          },
          throw(error) {
            emptyQueue();
            return Promise.reject(error);
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      exports2.observableToAsyncIterable = observableToAsyncIterable;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js
  var require_getOperationASTFromRequest = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/getOperationASTFromRequest.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getOperationASTFromRequest = exports2.getOperationASTFromDocument = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var memoize_js_1 = require_memoize();
      function getOperationASTFromDocument(documentNode, operationName) {
        const doc = (0, graphql_1.getOperationAST)(documentNode, operationName);
        if (!doc) {
          throw new Error(`Cannot infer operation ${operationName || ""}`);
        }
        return doc;
      }
      exports2.getOperationASTFromDocument = getOperationASTFromDocument;
      exports2.getOperationASTFromRequest = (0, memoize_js_1.memoize1)(function getOperationASTFromRequest(request) {
        return getOperationASTFromDocument(request.document, request.operationName);
      });
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/directives.js
  var require_directives2 = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/directives.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.GraphQLStreamDirective = exports2.GraphQLDeferDirective = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      exports2.GraphQLDeferDirective = new graphql_1.GraphQLDirective({
        name: "defer",
        description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
        locations: [graphql_1.DirectiveLocation.FRAGMENT_SPREAD, graphql_1.DirectiveLocation.INLINE_FRAGMENT],
        args: {
          if: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
            description: "Deferred when true or undefined.",
            defaultValue: true
          },
          label: {
            type: graphql_1.GraphQLString,
            description: "Unique name"
          }
        }
      });
      exports2.GraphQLStreamDirective = new graphql_1.GraphQLDirective({
        name: "stream",
        description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
        locations: [graphql_1.DirectiveLocation.FIELD],
        args: {
          if: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLBoolean),
            description: "Stream when true or undefined.",
            defaultValue: true
          },
          label: {
            type: graphql_1.GraphQLString,
            description: "Unique name"
          },
          initialCount: {
            defaultValue: 0,
            type: graphql_1.GraphQLInt,
            description: "Number of items to return immediately"
          }
        }
      });
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/AccumulatorMap.js
  var require_AccumulatorMap = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/AccumulatorMap.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AccumulatorMap = void 0;
      var AccumulatorMap = class extends Map {
        get [Symbol.toStringTag]() {
          return "AccumulatorMap";
        }
        add(key, item) {
          const group = this.get(key);
          if (group === void 0) {
            this.set(key, [item]);
          } else {
            group.push(item);
          }
        }
      };
      exports2.AccumulatorMap = AccumulatorMap;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/collectFields.js
  var require_collectFields2 = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/collectFields.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.collectSubFields = exports2.getDeferValues = exports2.getFieldEntryKey = exports2.doesFragmentConditionMatch = exports2.shouldIncludeNode = exports2.collectFields = void 0;
      var memoize_js_1 = require_memoize();
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var directives_js_1 = require_directives2();
      var AccumulatorMap_js_1 = require_AccumulatorMap();
      function collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
        for (const selection of selectionSet.selections) {
          switch (selection.kind) {
            case graphql_1.Kind.FIELD: {
              if (!shouldIncludeNode2(variableValues, selection)) {
                continue;
              }
              fields.add(getFieldEntryKey2(selection), selection);
              break;
            }
            case graphql_1.Kind.INLINE_FRAGMENT: {
              if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema, selection, runtimeType)) {
                continue;
              }
              const defer = getDeferValues(variableValues, selection);
              if (defer) {
                const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
                collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
                patches.push({
                  label: defer.label,
                  fields: patchFields
                });
              } else {
                collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
              }
              break;
            }
            case graphql_1.Kind.FRAGMENT_SPREAD: {
              const fragName = selection.name.value;
              if (!shouldIncludeNode2(variableValues, selection)) {
                continue;
              }
              const defer = getDeferValues(variableValues, selection);
              if (visitedFragmentNames.has(fragName) && !defer) {
                continue;
              }
              const fragment = fragments[fragName];
              if (!fragment || !doesFragmentConditionMatch2(schema, fragment, runtimeType)) {
                continue;
              }
              if (!defer) {
                visitedFragmentNames.add(fragName);
              }
              if (defer) {
                const patchFields = new AccumulatorMap_js_1.AccumulatorMap();
                collectFieldsImpl2(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
                patches.push({
                  label: defer.label,
                  fields: patchFields
                });
              } else {
                collectFieldsImpl2(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
              }
              break;
            }
          }
        }
      }
      function collectFields2(schema, fragments, variableValues, runtimeType, selectionSet) {
        const fields = new AccumulatorMap_js_1.AccumulatorMap();
        const patches = [];
        collectFieldsImpl2(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, /* @__PURE__ */ new Set());
        return { fields, patches };
      }
      exports2.collectFields = collectFields2;
      function shouldIncludeNode2(variableValues, node) {
        const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);
        if ((skip == null ? void 0 : skip["if"]) === true) {
          return false;
        }
        const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);
        if ((include == null ? void 0 : include["if"]) === false) {
          return false;
        }
        return true;
      }
      exports2.shouldIncludeNode = shouldIncludeNode2;
      function doesFragmentConditionMatch2(schema, fragment, type) {
        const typeConditionNode = fragment.typeCondition;
        if (!typeConditionNode) {
          return true;
        }
        const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);
        if (conditionalType === type) {
          return true;
        }
        if ((0, graphql_1.isAbstractType)(conditionalType)) {
          const possibleTypes = schema.getPossibleTypes(conditionalType);
          return possibleTypes.includes(type);
        }
        return false;
      }
      exports2.doesFragmentConditionMatch = doesFragmentConditionMatch2;
      function getFieldEntryKey2(node) {
        return node.alias ? node.alias.value : node.name.value;
      }
      exports2.getFieldEntryKey = getFieldEntryKey2;
      function getDeferValues(variableValues, node) {
        const defer = (0, graphql_1.getDirectiveValues)(directives_js_1.GraphQLDeferDirective, node, variableValues);
        if (!defer) {
          return;
        }
        if (defer["if"] === false) {
          return;
        }
        return {
          label: typeof defer["label"] === "string" ? defer["label"] : void 0
        };
      }
      exports2.getDeferValues = getDeferValues;
      exports2.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubfields3(schema, fragments, variableValues, returnType, fieldNodes) {
        const subFieldNodes = new AccumulatorMap_js_1.AccumulatorMap();
        const visitedFragmentNames = /* @__PURE__ */ new Set();
        const subPatches = [];
        const subFieldsAndPatches = {
          fields: subFieldNodes,
          patches: subPatches
        };
        for (const node of fieldNodes) {
          if (node.selectionSet) {
            collectFieldsImpl2(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
          }
        }
        return subFieldsAndPatches;
      });
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/visitResult.js
  var require_visitResult = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/visitResult.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.visitResult = exports2.visitErrors = exports2.visitData = void 0;
      var getOperationASTFromRequest_js_1 = require_getOperationASTFromRequest();
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var collectFields_js_1 = require_collectFields2();
      function visitData(data, enter, leave) {
        if (Array.isArray(data)) {
          return data.map((value) => visitData(value, enter, leave));
        } else if (typeof data === "object") {
          const newData = enter != null ? enter(data) : data;
          if (newData != null) {
            for (const key in newData) {
              const value = newData[key];
              Object.defineProperty(newData, key, {
                value: visitData(value, enter, leave)
              });
            }
          }
          return leave != null ? leave(newData) : newData;
        }
        return data;
      }
      exports2.visitData = visitData;
      function visitErrors(errors, visitor) {
        return errors.map((error) => visitor(error));
      }
      exports2.visitErrors = visitErrors;
      function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {
        const fragments = request.document.definitions.reduce((acc, def) => {
          if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
            acc[def.name.value] = def;
          }
          return acc;
        }, {});
        const variableValues = request.variables || {};
        const errorInfo = {
          segmentInfoMap: /* @__PURE__ */ new Map(),
          unpathedErrors: /* @__PURE__ */ new Set()
        };
        const data = result.data;
        const errors = result.errors;
        const visitingErrors = errors != null && errorVisitorMap != null;
        const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request);
        if (data != null && operationDocumentNode != null) {
          result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : void 0, errorInfo);
        }
        if (errors != null && errorVisitorMap) {
          result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);
        }
        return result;
      }
      exports2.visitResult = visitResult;
      function visitErrorsByType(errors, errorVisitorMap, errorInfo) {
        const segmentInfoMap = errorInfo.segmentInfoMap;
        const unpathedErrors = errorInfo.unpathedErrors;
        const unpathedErrorVisitor = errorVisitorMap["__unpathed"];
        return errors.map((originalError) => {
          const pathSegmentsInfo = segmentInfoMap.get(originalError);
          const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {
            const typeName = segmentInfo.type.name;
            const typeVisitorMap = errorVisitorMap[typeName];
            if (typeVisitorMap == null) {
              return acc;
            }
            const errorVisitor = typeVisitorMap[segmentInfo.fieldName];
            return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);
          }, originalError);
          if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {
            return unpathedErrorVisitor(newError);
          }
          return newError;
        });
      }
      function getOperationRootType2(schema, operationDef) {
        switch (operationDef.operation) {
          case "query":
            return schema.getQueryType();
          case "mutation":
            return schema.getMutationType();
          case "subscription":
            return schema.getSubscriptionType();
        }
      }
      function visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {
        const operationRootType = getOperationRootType2(schema, operation);
        const { fields: collectedFields } = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet);
        return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);
      }
      function visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
        var _a;
        const fieldMap = type.getFields();
        const typeVisitorMap = resultVisitorMap == null ? void 0 : resultVisitorMap[type.name];
        const enterObject = typeVisitorMap == null ? void 0 : typeVisitorMap.__enter;
        const newObject = enterObject != null ? enterObject(object) : object;
        let sortedErrors;
        let errorMap = null;
        if (errors != null) {
          sortedErrors = sortErrorsByPathSegment(errors, pathIndex);
          errorMap = sortedErrors.errorMap;
          for (const error of sortedErrors.unpathedErrors) {
            errorInfo.unpathedErrors.add(error);
          }
        }
        for (const [responseKey, subFieldNodes] of fieldNodeMap) {
          const fieldName = subFieldNodes[0].name.value;
          let fieldType = (_a = fieldMap[fieldName]) == null ? void 0 : _a.type;
          if (fieldType == null) {
            switch (fieldName) {
              case "__typename":
                fieldType = graphql_1.TypeNameMetaFieldDef.type;
                break;
              case "__schema":
                fieldType = graphql_1.SchemaMetaFieldDef.type;
                break;
              case "__type":
                fieldType = graphql_1.TypeMetaFieldDef.type;
                break;
            }
          }
          const newPathIndex = pathIndex + 1;
          let fieldErrors;
          if (errorMap) {
            fieldErrors = errorMap[responseKey];
            if (fieldErrors != null) {
              delete errorMap[responseKey];
            }
            addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);
          }
          const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);
          updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);
        }
        const oldTypename = newObject.__typename;
        if (oldTypename != null) {
          updateObject(newObject, "__typename", oldTypename, typeVisitorMap, "__typename");
        }
        if (errorMap) {
          for (const errorsKey in errorMap) {
            const errors2 = errorMap[errorsKey];
            for (const error of errors2) {
              errorInfo.unpathedErrors.add(error);
            }
          }
        }
        const leaveObject = typeVisitorMap == null ? void 0 : typeVisitorMap.__leave;
        return leaveObject != null ? leaveObject(newObject) : newObject;
      }
      function updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {
        if (typeVisitorMap == null) {
          object[responseKey] = newValue;
          return;
        }
        const fieldVisitor = typeVisitorMap[fieldName];
        if (fieldVisitor == null) {
          object[responseKey] = newValue;
          return;
        }
        const visitedValue = fieldVisitor(newValue);
        if (visitedValue === void 0) {
          delete object[responseKey];
          return;
        }
        object[responseKey] = visitedValue;
      }
      function visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {
        return list.map((listMember) => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));
      }
      function visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {
        if (value == null) {
          return value;
        }
        const nullableType = (0, graphql_1.getNullableType)(returnType);
        if ((0, graphql_1.isListType)(nullableType)) {
          return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
        } else if ((0, graphql_1.isAbstractType)(nullableType)) {
          const finalType = schema.getType(value.__typename);
          const { fields: collectedFields } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);
          return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
        } else if ((0, graphql_1.isObjectType)(nullableType)) {
          const { fields: collectedFields } = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);
          return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);
        }
        const typeVisitorMap = resultVisitorMap == null ? void 0 : resultVisitorMap[nullableType.name];
        if (typeVisitorMap == null) {
          return value;
        }
        const visitedValue = typeVisitorMap(value);
        return visitedValue === void 0 ? value : visitedValue;
      }
      function sortErrorsByPathSegment(errors, pathIndex) {
        var _a;
        const errorMap = /* @__PURE__ */ Object.create(null);
        const unpathedErrors = /* @__PURE__ */ new Set();
        for (const error of errors) {
          const pathSegment = (_a = error.path) == null ? void 0 : _a[pathIndex];
          if (pathSegment == null) {
            unpathedErrors.add(error);
            continue;
          }
          if (pathSegment in errorMap) {
            errorMap[pathSegment].push(error);
          } else {
            errorMap[pathSegment] = [error];
          }
        }
        return {
          errorMap,
          unpathedErrors
        };
      }
      function addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {
        for (const error of errors) {
          const segmentInfo = {
            type,
            fieldName,
            pathIndex
          };
          const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);
          if (pathSegmentsInfo == null) {
            errorInfo.segmentInfoMap.set(error, [segmentInfo]);
          } else {
            pathSegmentsInfo.push(segmentInfo);
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js
  var require_valueMatchesCriteria = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/valueMatchesCriteria.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.valueMatchesCriteria = void 0;
      function valueMatchesCriteria(value, criteria) {
        if (value == null) {
          return value === criteria;
        } else if (Array.isArray(value)) {
          return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));
        } else if (typeof value === "object") {
          return typeof criteria === "object" && criteria && Object.keys(criteria).every((propertyName) => valueMatchesCriteria(value[propertyName], criteria[propertyName]));
        } else if (criteria instanceof RegExp) {
          return criteria.test(value);
        }
        return value === criteria;
      }
      exports2.valueMatchesCriteria = valueMatchesCriteria;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js
  var require_isAsyncIterable = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/isAsyncIterable.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isAsyncIterable = void 0;
      function isAsyncIterable2(value) {
        return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
      }
      exports2.isAsyncIterable = isAsyncIterable2;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js
  var require_isDocumentNode = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/isDocumentNode.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isDocumentNode = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function isDocumentNode(object) {
        return object && typeof object === "object" && "kind" in object && object.kind === graphql_1.Kind.DOCUMENT;
      }
      exports2.isDocumentNode = isDocumentNode;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/executor.js
  var require_executor = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/executor.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/withCancel.js
  var require_withCancel = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/withCancel.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.withCancel = exports2.getAsyncIterableWithCancel = exports2.getAsyncIteratorWithCancel = void 0;
      var memoize_js_1 = require_memoize();
      function defaultAsyncIteratorReturn(value) {
        return __async(this, null, function* () {
          return { value, done: true };
        });
      }
      var proxyMethodFactory = (0, memoize_js_1.memoize2)(function proxyMethodFactory2(target, targetMethod) {
        return function proxyMethod(...args) {
          return Reflect.apply(targetMethod, target, args);
        };
      });
      function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
        return new Proxy(asyncIterator, {
          has(asyncIterator2, prop) {
            if (prop === "return") {
              return true;
            }
            return Reflect.has(asyncIterator2, prop);
          },
          get(asyncIterator2, prop, receiver) {
            const existingPropValue = Reflect.get(asyncIterator2, prop, receiver);
            if (prop === "return") {
              const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
              return function returnWithCancel(value) {
                return __async(this, null, function* () {
                  const returnValue = yield onCancel(value);
                  return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
                });
              };
            } else if (typeof existingPropValue === "function") {
              return proxyMethodFactory(asyncIterator2, existingPropValue);
            }
            return existingPropValue;
          }
        });
      }
      exports2.getAsyncIteratorWithCancel = getAsyncIteratorWithCancel;
      function getAsyncIterableWithCancel(asyncIterable, onCancel) {
        return new Proxy(asyncIterable, {
          get(asyncIterable2, prop, receiver) {
            const existingPropValue = Reflect.get(asyncIterable2, prop, receiver);
            if (Symbol.asyncIterator === prop) {
              return function asyncIteratorFactory() {
                const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
                return getAsyncIteratorWithCancel(asyncIterator, onCancel);
              };
            } else if (typeof existingPropValue === "function") {
              return proxyMethodFactory(asyncIterable2, existingPropValue);
            }
            return existingPropValue;
          }
        });
      }
      exports2.getAsyncIterableWithCancel = getAsyncIterableWithCancel;
      exports2.withCancel = getAsyncIterableWithCancel;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js
  var require_fixSchemaAst = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/fixSchemaAst.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.fixSchemaAst = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var print_schema_with_directives_js_1 = require_print_schema_with_directives();
      function buildFixedSchema(schema, options) {
        const document = (0, print_schema_with_directives_js_1.getDocumentNodeFromSchema)(schema);
        return (0, graphql_1.buildASTSchema)(document, __spreadValues({}, options || {}));
      }
      function fixSchemaAst(schema, options) {
        let schemaWithValidAst = void 0;
        if (!schema.astNode || !schema.extensionASTNodes) {
          schemaWithValidAst = buildFixedSchema(schema, options);
        }
        if (!schema.astNode && (schemaWithValidAst == null ? void 0 : schemaWithValidAst.astNode)) {
          schema.astNode = schemaWithValidAst.astNode;
        }
        if (!schema.extensionASTNodes && (schemaWithValidAst == null ? void 0 : schemaWithValidAst.astNode)) {
          schema.extensionASTNodes = schemaWithValidAst.extensionASTNodes;
        }
        return schema;
      }
      exports2.fixSchemaAst = fixSchemaAst;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/extractExtensionsFromSchema.js
  var require_extractExtensionsFromSchema = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/extractExtensionsFromSchema.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.extractExtensionsFromSchema = void 0;
      var mapSchema_js_1 = require_mapSchema();
      var Interfaces_js_1 = require_Interfaces();
      function extractExtensionsFromSchema(schema) {
        const result = {
          schemaExtensions: schema.extensions || {},
          types: {}
        };
        (0, mapSchema_js_1.mapSchema)(schema, {
          [Interfaces_js_1.MapperKind.OBJECT_TYPE]: (type) => {
            result.types[type.name] = { fields: {}, type: "object", extensions: type.extensions || {} };
            return type;
          },
          [Interfaces_js_1.MapperKind.INTERFACE_TYPE]: (type) => {
            result.types[type.name] = { fields: {}, type: "interface", extensions: type.extensions || {} };
            return type;
          },
          [Interfaces_js_1.MapperKind.FIELD]: (field, fieldName, typeName) => {
            result.types[typeName].fields[fieldName] = {
              arguments: {},
              extensions: field.extensions || {}
            };
            const args = field.args;
            if (args != null) {
              for (const argName in args) {
                result.types[typeName].fields[fieldName].arguments[argName] = args[argName].extensions || {};
              }
            }
            return field;
          },
          [Interfaces_js_1.MapperKind.ENUM_TYPE]: (type) => {
            result.types[type.name] = { values: {}, type: "enum", extensions: type.extensions || {} };
            return type;
          },
          [Interfaces_js_1.MapperKind.ENUM_VALUE]: (value, typeName, _schema, valueName) => {
            result.types[typeName].values[valueName] = value.extensions || {};
            return value;
          },
          [Interfaces_js_1.MapperKind.SCALAR_TYPE]: (type) => {
            result.types[type.name] = { type: "scalar", extensions: type.extensions || {} };
            return type;
          },
          [Interfaces_js_1.MapperKind.UNION_TYPE]: (type) => {
            result.types[type.name] = { type: "union", extensions: type.extensions || {} };
            return type;
          },
          [Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE]: (type) => {
            result.types[type.name] = { fields: {}, type: "input", extensions: type.extensions || {} };
            return type;
          },
          [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: (field, fieldName, typeName) => {
            result.types[typeName].fields[fieldName] = {
              extensions: field.extensions || {}
            };
            return field;
          }
        });
        return result;
      }
      exports2.extractExtensionsFromSchema = extractExtensionsFromSchema;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/Path.js
  var require_Path2 = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/Path.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.printPathArray = exports2.pathToArray = exports2.addPath = void 0;
      function addPath2(prev, key, typename) {
        return { prev, key, typename };
      }
      exports2.addPath = addPath2;
      function pathToArray2(path) {
        const flattened = [];
        let curr = path;
        while (curr) {
          flattened.push(curr.key);
          curr = curr.prev;
        }
        return flattened.reverse();
      }
      exports2.pathToArray = pathToArray2;
      function printPathArray2(path) {
        return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
      }
      exports2.printPathArray = printPathArray2;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/index.js
  var require_cjs = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+utils@10.0.1_graphql@16.7.1/node_modules/@graphql-tools/utils/cjs/index.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_loaders(), exports2);
      tslib_1.__exportStar(require_helpers(), exports2);
      tslib_1.__exportStar(require_get_directives(), exports2);
      tslib_1.__exportStar(require_get_fields_with_directives(), exports2);
      tslib_1.__exportStar(require_get_arguments_with_directives(), exports2);
      tslib_1.__exportStar(require_get_implementing_types(), exports2);
      tslib_1.__exportStar(require_print_schema_with_directives(), exports2);
      tslib_1.__exportStar(require_get_fields_with_directives(), exports2);
      tslib_1.__exportStar(require_validate_documents(), exports2);
      tslib_1.__exportStar(require_parse_graphql_json(), exports2);
      tslib_1.__exportStar(require_parse_graphql_sdl(), exports2);
      tslib_1.__exportStar(require_build_operation_for_field(), exports2);
      tslib_1.__exportStar(require_types(), exports2);
      tslib_1.__exportStar(require_filterSchema(), exports2);
      tslib_1.__exportStar(require_heal(), exports2);
      tslib_1.__exportStar(require_getResolversFromSchema(), exports2);
      tslib_1.__exportStar(require_forEachField(), exports2);
      tslib_1.__exportStar(require_forEachDefaultValue(), exports2);
      tslib_1.__exportStar(require_mapSchema(), exports2);
      tslib_1.__exportStar(require_addTypes(), exports2);
      tslib_1.__exportStar(require_rewire(), exports2);
      tslib_1.__exportStar(require_prune(), exports2);
      tslib_1.__exportStar(require_mergeDeep(), exports2);
      tslib_1.__exportStar(require_Interfaces(), exports2);
      tslib_1.__exportStar(require_stub(), exports2);
      tslib_1.__exportStar(require_selectionSets(), exports2);
      tslib_1.__exportStar(require_getResponseKeyFromInfo(), exports2);
      tslib_1.__exportStar(require_fields(), exports2);
      tslib_1.__exportStar(require_renameType(), exports2);
      tslib_1.__exportStar(require_transformInputValue(), exports2);
      tslib_1.__exportStar(require_mapAsyncIterator(), exports2);
      tslib_1.__exportStar(require_updateArgument(), exports2);
      tslib_1.__exportStar(require_implementsAbstractType(), exports2);
      tslib_1.__exportStar(require_errors2(), exports2);
      tslib_1.__exportStar(require_observableToAsyncIterable(), exports2);
      tslib_1.__exportStar(require_visitResult(), exports2);
      tslib_1.__exportStar(require_getArgumentValues(), exports2);
      tslib_1.__exportStar(require_valueMatchesCriteria(), exports2);
      tslib_1.__exportStar(require_isAsyncIterable(), exports2);
      tslib_1.__exportStar(require_isDocumentNode(), exports2);
      tslib_1.__exportStar(require_astFromValueUntyped(), exports2);
      tslib_1.__exportStar(require_executor(), exports2);
      tslib_1.__exportStar(require_withCancel(), exports2);
      tslib_1.__exportStar(require_rootTypes(), exports2);
      tslib_1.__exportStar(require_comments(), exports2);
      tslib_1.__exportStar(require_collectFields2(), exports2);
      tslib_1.__exportStar(require_inspect2(), exports2);
      tslib_1.__exportStar(require_memoize(), exports2);
      tslib_1.__exportStar(require_fixSchemaAst(), exports2);
      tslib_1.__exportStar(require_getOperationASTFromRequest(), exports2);
      tslib_1.__exportStar(require_extractExtensionsFromSchema(), exports2);
      tslib_1.__exportStar(require_Path2(), exports2);
      tslib_1.__exportStar(require_jsutils(), exports2);
      tslib_1.__exportStar(require_directives2(), exports2);
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js
  var require_merge_resolvers = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/merge-resolvers.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeResolvers = void 0;
      var utils_1 = require_cjs();
      function mergeResolvers(resolversDefinitions, options) {
        if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
          return {};
        }
        if (!Array.isArray(resolversDefinitions)) {
          return resolversDefinitions;
        }
        if (resolversDefinitions.length === 1) {
          return resolversDefinitions[0] || {};
        }
        const resolvers = new Array();
        for (let resolversDefinition of resolversDefinitions) {
          if (Array.isArray(resolversDefinition)) {
            resolversDefinition = mergeResolvers(resolversDefinition);
          }
          if (typeof resolversDefinition === "object" && resolversDefinition) {
            resolvers.push(resolversDefinition);
          }
        }
        const result = (0, utils_1.mergeDeep)(resolvers, true);
        if (options == null ? void 0 : options.exclusions) {
          for (const exclusion of options.exclusions) {
            const [typeName, fieldName] = exclusion.split(".");
            if (!fieldName || fieldName === "*") {
              delete result[typeName];
            } else if (result[typeName]) {
              delete result[typeName][fieldName];
            }
          }
        }
        return result;
      }
      exports2.mergeResolvers = mergeResolvers;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js
  var require_arguments = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/arguments.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeArguments = void 0;
      var utils_1 = require_cjs();
      function mergeArguments(args1, args2, config2) {
        const result = deduplicateArguments([...args2, ...args1].filter(utils_1.isSome), config2);
        if (config2 && config2.sort) {
          result.sort(utils_1.compareNodes);
        }
        return result;
      }
      exports2.mergeArguments = mergeArguments;
      function deduplicateArguments(args, config2) {
        return args.reduce((acc, current) => {
          const dupIndex = acc.findIndex((arg) => arg.name.value === current.name.value);
          if (dupIndex === -1) {
            return acc.concat([current]);
          } else if (!(config2 == null ? void 0 : config2.reverseArguments)) {
            acc[dupIndex] = current;
          }
          return acc;
        }, []);
      }
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js
  var require_directives3 = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeDirective = exports2.mergeDirectives = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var utils_1 = require_cjs();
      function directiveAlreadyExists(directivesArr, otherDirective) {
        return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
      }
      function isRepeatableDirective(directive, directives) {
        var _a;
        return !!((_a = directives == null ? void 0 : directives[directive.name.value]) == null ? void 0 : _a.repeatable);
      }
      function nameAlreadyExists(name2, namesArr) {
        return namesArr.some(({ value }) => value === name2.value);
      }
      function mergeArguments(a1, a2) {
        const result = [...a2];
        for (const argument of a1) {
          const existingIndex = result.findIndex((a3) => a3.name.value === argument.name.value);
          if (existingIndex > -1) {
            const existingArg = result[existingIndex];
            if (existingArg.value.kind === "ListValue") {
              const source = existingArg.value.values;
              const target = argument.value.values;
              existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
                const value = targetVal.value;
                return !value || !source2.some((sourceVal) => sourceVal.value === value);
              });
            } else {
              existingArg.value = argument.value;
            }
          } else {
            result.push(argument);
          }
        }
        return result;
      }
      function deduplicateDirectives(directives, definitions) {
        return directives.map((directive, i2, all) => {
          const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
          if (firstAt !== i2 && !isRepeatableDirective(directive, definitions)) {
            const dup = all[firstAt];
            directive.arguments = mergeArguments(directive.arguments, dup.arguments);
            return null;
          }
          return directive;
        }).filter(utils_1.isSome);
      }
      function mergeDirectives(d1 = [], d2 = [], config2, directives) {
        const reverseOrder = config2 && config2.reverseDirectives;
        const asNext = reverseOrder ? d1 : d2;
        const asFirst = reverseOrder ? d2 : d1;
        const result = deduplicateDirectives([...asNext], directives);
        for (const directive of asFirst) {
          if (directiveAlreadyExists(result, directive) && !isRepeatableDirective(directive, directives)) {
            const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
            const existingDirective = result[existingDirectiveIndex];
            result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);
          } else {
            result.push(directive);
          }
        }
        return result;
      }
      exports2.mergeDirectives = mergeDirectives;
      function validateInputs(node, existingNode) {
        const printedNode = (0, graphql_1.print)(__spreadProps(__spreadValues({}, node), {
          description: void 0
        }));
        const printedExistingNode = (0, graphql_1.print)(__spreadProps(__spreadValues({}, existingNode), {
          description: void 0
        }));
        const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
        const sameArguments = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
        if (!sameArguments) {
          throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
        }
      }
      function mergeDirective(node, existingNode) {
        if (existingNode) {
          validateInputs(node, existingNode);
          return __spreadProps(__spreadValues({}, node), {
            locations: [
              ...existingNode.locations,
              ...node.locations.filter((name2) => !nameAlreadyExists(name2, existingNode.locations))
            ]
          });
        }
        return node;
      }
      exports2.mergeDirective = mergeDirective;
      function deduplicateLists(source, target, filterFn) {
        return source.concat(target.filter((val) => filterFn(val, source)));
      }
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js
  var require_enum_values = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum-values.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeEnumValues = void 0;
      var directives_js_1 = require_directives3();
      var utils_1 = require_cjs();
      function mergeEnumValues(first, second, config2, directives) {
        if (config2 == null ? void 0 : config2.consistentEnumMerge) {
          const reversed = [];
          if (first) {
            reversed.push(...first);
          }
          first = second;
          second = reversed;
        }
        const enumValueMap = /* @__PURE__ */ new Map();
        if (first) {
          for (const firstValue of first) {
            enumValueMap.set(firstValue.name.value, firstValue);
          }
        }
        if (second) {
          for (const secondValue of second) {
            const enumValue = secondValue.name.value;
            if (enumValueMap.has(enumValue)) {
              const firstValue = enumValueMap.get(enumValue);
              firstValue.description = secondValue.description || firstValue.description;
              firstValue.directives = (0, directives_js_1.mergeDirectives)(secondValue.directives, firstValue.directives, directives);
            } else {
              enumValueMap.set(enumValue, secondValue);
            }
          }
        }
        const result = [...enumValueMap.values()];
        if (config2 && config2.sort) {
          result.sort(utils_1.compareNodes);
        }
        return result;
      }
      exports2.mergeEnumValues = mergeEnumValues;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js
  var require_enum = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/enum.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeEnum = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var directives_js_1 = require_directives3();
      var enum_values_js_1 = require_enum_values();
      function mergeEnum(e1, e2, config2, directives) {
        if (e2) {
          return {
            name: e1.name,
            description: e1["description"] || e2["description"],
            kind: (config2 == null ? void 0 : config2.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
            loc: e1.loc,
            directives: (0, directives_js_1.mergeDirectives)(e1.directives, e2.directives, config2, directives),
            values: (0, enum_values_js_1.mergeEnumValues)(e1.values, e2.values, config2)
          };
        }
        return (config2 == null ? void 0 : config2.convertExtensions) ? __spreadProps(__spreadValues({}, e1), {
          kind: graphql_1.Kind.ENUM_TYPE_DEFINITION
        }) : e1;
      }
      exports2.mergeEnum = mergeEnum;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js
  var require_utils5 = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/utils.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defaultStringComparator = exports2.CompareVal = exports2.printTypeNode = exports2.isNonNullTypeNode = exports2.isListTypeNode = exports2.isWrappingTypeNode = exports2.extractType = exports2.isSourceTypes = exports2.isStringTypes = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      function isStringTypes(types) {
        return typeof types === "string";
      }
      exports2.isStringTypes = isStringTypes;
      function isSourceTypes(types) {
        return types instanceof graphql_1.Source;
      }
      exports2.isSourceTypes = isSourceTypes;
      function extractType(type) {
        let visitedType = type;
        while (visitedType.kind === graphql_1.Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
          visitedType = visitedType.type;
        }
        return visitedType;
      }
      exports2.extractType = extractType;
      function isWrappingTypeNode(type) {
        return type.kind !== graphql_1.Kind.NAMED_TYPE;
      }
      exports2.isWrappingTypeNode = isWrappingTypeNode;
      function isListTypeNode(type) {
        return type.kind === graphql_1.Kind.LIST_TYPE;
      }
      exports2.isListTypeNode = isListTypeNode;
      function isNonNullTypeNode(type) {
        return type.kind === graphql_1.Kind.NON_NULL_TYPE;
      }
      exports2.isNonNullTypeNode = isNonNullTypeNode;
      function printTypeNode(type) {
        if (isListTypeNode(type)) {
          return `[${printTypeNode(type.type)}]`;
        }
        if (isNonNullTypeNode(type)) {
          return `${printTypeNode(type.type)}!`;
        }
        return type.name.value;
      }
      exports2.printTypeNode = printTypeNode;
      var CompareVal;
      (function(CompareVal2) {
        CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
        CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
        CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
      })(CompareVal = exports2.CompareVal || (exports2.CompareVal = {}));
      function defaultStringComparator(a2, b) {
        if (a2 == null && b == null) {
          return CompareVal.A_EQUALS_B;
        }
        if (a2 == null) {
          return CompareVal.A_SMALLER_THAN_B;
        }
        if (b == null) {
          return CompareVal.A_GREATER_THAN_B;
        }
        if (a2 < b)
          return CompareVal.A_SMALLER_THAN_B;
        if (a2 > b)
          return CompareVal.A_GREATER_THAN_B;
        return CompareVal.A_EQUALS_B;
      }
      exports2.defaultStringComparator = defaultStringComparator;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js
  var require_fields2 = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeFields = void 0;
      var utils_js_1 = require_utils5();
      var directives_js_1 = require_directives3();
      var utils_1 = require_cjs();
      var arguments_js_1 = require_arguments();
      function fieldAlreadyExists(fieldsArr, otherField) {
        const resultIndex = fieldsArr.findIndex((field) => field.name.value === otherField.name.value);
        return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];
      }
      function mergeFields(type, f1, f2, config2, directives) {
        const result = [];
        if (f2 != null) {
          result.push(...f2);
        }
        if (f1 != null) {
          for (const field of f1) {
            const [existing, existingIndex] = fieldAlreadyExists(result, field);
            if (existing && !(config2 == null ? void 0 : config2.ignoreFieldConflicts)) {
              const newField = (config2 == null ? void 0 : config2.onFieldTypeConflict) && config2.onFieldTypeConflict(existing, field, type, config2 == null ? void 0 : config2.throwOnConflict) || preventConflicts(type, existing, field, config2 == null ? void 0 : config2.throwOnConflict);
              newField.arguments = (0, arguments_js_1.mergeArguments)(field["arguments"] || [], existing["arguments"] || [], config2);
              newField.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config2, directives);
              newField.description = field.description || existing.description;
              result[existingIndex] = newField;
            } else {
              result.push(field);
            }
          }
        }
        if (config2 && config2.sort) {
          result.sort(utils_1.compareNodes);
        }
        if (config2 && config2.exclusions) {
          const exclusions = config2.exclusions;
          return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
        }
        return result;
      }
      exports2.mergeFields = mergeFields;
      function preventConflicts(type, a2, b, ignoreNullability = false) {
        const aType = (0, utils_js_1.printTypeNode)(a2.type);
        const bType = (0, utils_js_1.printTypeNode)(b.type);
        if (aType !== bType) {
          const t1 = (0, utils_js_1.extractType)(a2.type);
          const t2 = (0, utils_js_1.extractType)(b.type);
          if (t1.name.value !== t2.name.value) {
            throw new Error(`Field "${b.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
          }
          if (!safeChangeForFieldType(a2.type, b.type, !ignoreNullability)) {
            throw new Error(`Field '${type.name.value}.${a2.name.value}' changed type from '${aType}' to '${bType}'`);
          }
        }
        if ((0, utils_js_1.isNonNullTypeNode)(b.type) && !(0, utils_js_1.isNonNullTypeNode)(a2.type)) {
          a2.type = b.type;
        }
        return a2;
      }
      function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
        if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {
          return oldType.toString() === newType.toString();
        }
        if ((0, utils_js_1.isNonNullTypeNode)(newType)) {
          const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;
          return safeChangeForFieldType(ofType, newType.type);
        }
        if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {
          return safeChangeForFieldType(newType, oldType, ignoreNullability);
        }
        if ((0, utils_js_1.isListTypeNode)(oldType)) {
          return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType["type"]);
        }
        return false;
      }
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js
  var require_input_type = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/input-type.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeInputType = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var fields_js_1 = require_fields2();
      var directives_js_1 = require_directives3();
      function mergeInputType(node, existingNode, config2, directives) {
        if (existingNode) {
          try {
            return {
              name: node.name,
              description: node["description"] || existingNode["description"],
              kind: (config2 == null ? void 0 : config2.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
              loc: node.loc,
              fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
              directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2, directives)
            };
          } catch (e2) {
            throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e2.message}`);
          }
        }
        return (config2 == null ? void 0 : config2.convertExtensions) ? __spreadProps(__spreadValues({}, node), {
          kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION
        }) : node;
      }
      exports2.mergeInputType = mergeInputType;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js
  var require_merge_named_type_array = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-named-type-array.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeNamedTypeArray = void 0;
      var utils_1 = require_cjs();
      function alreadyExists(arr, other) {
        return !!arr.find((i2) => i2.name.value === other.name.value);
      }
      function mergeNamedTypeArray(first = [], second = [], config2 = {}) {
        const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
        if (config2 && config2.sort) {
          result.sort(utils_1.compareNodes);
        }
        return result;
      }
      exports2.mergeNamedTypeArray = mergeNamedTypeArray;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js
  var require_interface = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/interface.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeInterface = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var fields_js_1 = require_fields2();
      var directives_js_1 = require_directives3();
      var merge_named_type_array_js_1 = require_merge_named_type_array();
      function mergeInterface(node, existingNode, config2, directives) {
        if (existingNode) {
          try {
            return {
              name: node.name,
              description: node["description"] || existingNode["description"],
              kind: (config2 == null ? void 0 : config2.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
              loc: node.loc,
              fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
              directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2, directives),
              interfaces: node["interfaces"] ? (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node["interfaces"], existingNode["interfaces"], config2) : void 0
            };
          } catch (e2) {
            throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e2.message}`);
          }
        }
        return (config2 == null ? void 0 : config2.convertExtensions) ? __spreadProps(__spreadValues({}, node), {
          kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION
        }) : node;
      }
      exports2.mergeInterface = mergeInterface;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js
  var require_type = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/type.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeType = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var fields_js_1 = require_fields2();
      var directives_js_1 = require_directives3();
      var merge_named_type_array_js_1 = require_merge_named_type_array();
      function mergeType(node, existingNode, config2, directives) {
        if (existingNode) {
          try {
            return {
              name: node.name,
              description: node["description"] || existingNode["description"],
              kind: (config2 == null ? void 0 : config2.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
              loc: node.loc,
              fields: (0, fields_js_1.mergeFields)(node, node.fields, existingNode.fields, config2),
              directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2, directives),
              interfaces: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(node.interfaces, existingNode.interfaces, config2)
            };
          } catch (e2) {
            throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e2.message}`);
          }
        }
        return (config2 == null ? void 0 : config2.convertExtensions) ? __spreadProps(__spreadValues({}, node), {
          kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION
        }) : node;
      }
      exports2.mergeType = mergeType;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js
  var require_scalar = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/scalar.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeScalar = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var directives_js_1 = require_directives3();
      function mergeScalar(node, existingNode, config2, directives) {
        if (existingNode) {
          return {
            name: node.name,
            description: node["description"] || existingNode["description"],
            kind: (config2 == null ? void 0 : config2.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
            loc: node.loc,
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2, directives)
          };
        }
        return (config2 == null ? void 0 : config2.convertExtensions) ? __spreadProps(__spreadValues({}, node), {
          kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION
        }) : node;
      }
      exports2.mergeScalar = mergeScalar;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js
  var require_union = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/union.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeUnion = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var directives_js_1 = require_directives3();
      var merge_named_type_array_js_1 = require_merge_named_type_array();
      function mergeUnion(first, second, config2, directives) {
        if (second) {
          return {
            name: first.name,
            description: first["description"] || second["description"],
            // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility
            directives: (0, directives_js_1.mergeDirectives)(first.directives, second.directives, config2, directives),
            kind: (config2 == null ? void 0 : config2.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? graphql_1.Kind.UNION_TYPE_DEFINITION : graphql_1.Kind.UNION_TYPE_EXTENSION,
            loc: first.loc,
            types: (0, merge_named_type_array_js_1.mergeNamedTypeArray)(first.types, second.types, config2)
          };
        }
        return (config2 == null ? void 0 : config2.convertExtensions) ? __spreadProps(__spreadValues({}, first), {
          kind: graphql_1.Kind.UNION_TYPE_DEFINITION
        }) : first;
      }
      exports2.mergeUnion = mergeUnion;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js
  var require_schema_def = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/schema-def.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeSchemaDefs = exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var directives_js_1 = require_directives3();
      exports2.DEFAULT_OPERATION_TYPE_NAME_MAP = {
        query: "Query",
        mutation: "Mutation",
        subscription: "Subscription"
      };
      function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
        const finalOpNodeList = [];
        for (const opNodeType in exports2.DEFAULT_OPERATION_TYPE_NAME_MAP) {
          const opNode = opNodeList.find((n2) => n2.operation === opNodeType) || existingOpNodeList.find((n2) => n2.operation === opNodeType);
          if (opNode) {
            finalOpNodeList.push(opNode);
          }
        }
        return finalOpNodeList;
      }
      function mergeSchemaDefs(node, existingNode, config2, directives) {
        if (existingNode) {
          return {
            kind: node.kind === graphql_1.Kind.SCHEMA_DEFINITION || existingNode.kind === graphql_1.Kind.SCHEMA_DEFINITION ? graphql_1.Kind.SCHEMA_DEFINITION : graphql_1.Kind.SCHEMA_EXTENSION,
            description: node["description"] || existingNode["description"],
            directives: (0, directives_js_1.mergeDirectives)(node.directives, existingNode.directives, config2, directives),
            operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
          };
        }
        return (config2 == null ? void 0 : config2.convertExtensions) ? __spreadProps(__spreadValues({}, node), {
          kind: graphql_1.Kind.SCHEMA_DEFINITION
        }) : node;
      }
      exports2.mergeSchemaDefs = mergeSchemaDefs;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js
  var require_merge_nodes = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-nodes.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeGraphQLNodes = exports2.isNamedDefinitionNode = exports2.schemaDefSymbol = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var type_js_1 = require_type();
      var enum_js_1 = require_enum();
      var scalar_js_1 = require_scalar();
      var union_js_1 = require_union();
      var input_type_js_1 = require_input_type();
      var interface_js_1 = require_interface();
      var directives_js_1 = require_directives3();
      var schema_def_js_1 = require_schema_def();
      var utils_1 = require_cjs();
      exports2.schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
      function isNamedDefinitionNode(definitionNode) {
        return "name" in definitionNode;
      }
      exports2.isNamedDefinitionNode = isNamedDefinitionNode;
      function mergeGraphQLNodes(nodes, config2, directives = {}) {
        var _a, _b, _c;
        const mergedResultMap = directives;
        for (const nodeDefinition of nodes) {
          if (isNamedDefinitionNode(nodeDefinition)) {
            const name2 = (_a = nodeDefinition.name) == null ? void 0 : _a.value;
            if (config2 == null ? void 0 : config2.commentDescriptions) {
              (0, utils_1.collectComment)(nodeDefinition);
            }
            if (name2 == null) {
              continue;
            }
            if (((_b = config2 == null ? void 0 : config2.exclusions) == null ? void 0 : _b.includes(name2 + ".*")) || ((_c = config2 == null ? void 0 : config2.exclusions) == null ? void 0 : _c.includes(name2))) {
              delete mergedResultMap[name2];
            } else {
              switch (nodeDefinition.kind) {
                case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
                case graphql_1.Kind.OBJECT_TYPE_EXTENSION:
                  mergedResultMap[name2] = (0, type_js_1.mergeType)(nodeDefinition, mergedResultMap[name2], config2, directives);
                  break;
                case graphql_1.Kind.ENUM_TYPE_DEFINITION:
                case graphql_1.Kind.ENUM_TYPE_EXTENSION:
                  mergedResultMap[name2] = (0, enum_js_1.mergeEnum)(nodeDefinition, mergedResultMap[name2], config2, directives);
                  break;
                case graphql_1.Kind.UNION_TYPE_DEFINITION:
                case graphql_1.Kind.UNION_TYPE_EXTENSION:
                  mergedResultMap[name2] = (0, union_js_1.mergeUnion)(nodeDefinition, mergedResultMap[name2], config2, directives);
                  break;
                case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
                case graphql_1.Kind.SCALAR_TYPE_EXTENSION:
                  mergedResultMap[name2] = (0, scalar_js_1.mergeScalar)(nodeDefinition, mergedResultMap[name2], config2, directives);
                  break;
                case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
                case graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION:
                  mergedResultMap[name2] = (0, input_type_js_1.mergeInputType)(nodeDefinition, mergedResultMap[name2], config2, directives);
                  break;
                case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
                case graphql_1.Kind.INTERFACE_TYPE_EXTENSION:
                  mergedResultMap[name2] = (0, interface_js_1.mergeInterface)(nodeDefinition, mergedResultMap[name2], config2, directives);
                  break;
                case graphql_1.Kind.DIRECTIVE_DEFINITION:
                  mergedResultMap[name2] = (0, directives_js_1.mergeDirective)(nodeDefinition, mergedResultMap[name2]);
                  break;
              }
            }
          } else if (nodeDefinition.kind === graphql_1.Kind.SCHEMA_DEFINITION || nodeDefinition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {
            mergedResultMap[exports2.schemaDefSymbol] = (0, schema_def_js_1.mergeSchemaDefs)(nodeDefinition, mergedResultMap[exports2.schemaDefSymbol], config2);
          }
        }
        return mergedResultMap;
      }
      exports2.mergeGraphQLNodes = mergeGraphQLNodes;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js
  var require_merge_typedefs = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.mergeGraphQLTypes = exports2.mergeTypeDefs = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var utils_js_1 = require_utils5();
      var merge_nodes_js_1 = require_merge_nodes();
      var utils_1 = require_cjs();
      var schema_def_js_1 = require_schema_def();
      function mergeTypeDefs(typeSource, config2) {
        (0, utils_1.resetComments)();
        const doc = {
          kind: graphql_1.Kind.DOCUMENT,
          definitions: mergeGraphQLTypes(typeSource, __spreadValues({
            useSchemaDefinition: true,
            forceSchemaDefinition: false,
            throwOnConflict: false,
            commentDescriptions: false
          }, config2))
        };
        let result;
        if (config2 == null ? void 0 : config2.commentDescriptions) {
          result = (0, utils_1.printWithComments)(doc);
        } else {
          result = doc;
        }
        (0, utils_1.resetComments)();
        return result;
      }
      exports2.mergeTypeDefs = mergeTypeDefs;
      function visitTypeSources(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
        if (typeSource && !visitedTypeSources.has(typeSource)) {
          visitedTypeSources.add(typeSource);
          if (typeof typeSource === "function") {
            visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);
          } else if (Array.isArray(typeSource)) {
            for (const type of typeSource) {
              visitTypeSources(type, options, allDirectives, allNodes, visitedTypeSources);
            }
          } else if ((0, graphql_1.isSchema)(typeSource)) {
            const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);
            visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
          } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {
            const documentNode = (0, graphql_1.parse)(typeSource, options);
            visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
          } else if (typeof typeSource === "object" && (0, graphql_1.isDefinitionNode)(typeSource)) {
            if (typeSource.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {
              allDirectives.push(typeSource);
            } else {
              allNodes.push(typeSource);
            }
          } else if ((0, utils_1.isDocumentNode)(typeSource)) {
            visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);
          } else {
            throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
          }
        }
        return { allDirectives, allNodes };
      }
      function mergeGraphQLTypes(typeSource, config2) {
        var _a, _b, _c;
        (0, utils_1.resetComments)();
        const { allDirectives, allNodes } = visitTypeSources(typeSource, config2);
        const mergedDirectives = (0, merge_nodes_js_1.mergeGraphQLNodes)(allDirectives, config2);
        const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config2, mergedDirectives);
        if (config2 == null ? void 0 : config2.useSchemaDefinition) {
          const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {
            kind: graphql_1.Kind.SCHEMA_DEFINITION,
            operationTypes: []
          };
          const operationTypes = schemaDef.operationTypes;
          for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {
            const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
            if (!opTypeDefNode) {
              const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
              const existingPossibleRootType = mergedNodes[possibleRootTypeName];
              if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
                operationTypes.push({
                  kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                  type: {
                    kind: graphql_1.Kind.NAMED_TYPE,
                    name: existingPossibleRootType.name
                  },
                  operation: opTypeDefNodeType
                });
              }
            }
          }
          if (((_a = schemaDef == null ? void 0 : schemaDef.operationTypes) == null ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {
            mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;
          }
        }
        if ((config2 == null ? void 0 : config2.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) == null ? void 0 : _b.operationTypes) == null ? void 0 : _c.length)) {
          mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {
            kind: graphql_1.Kind.SCHEMA_DEFINITION,
            operationTypes: [
              {
                kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,
                operation: "query",
                type: {
                  kind: graphql_1.Kind.NAMED_TYPE,
                  name: {
                    kind: graphql_1.Kind.NAME,
                    value: "Query"
                  }
                }
              }
            ]
          };
        }
        const mergedNodeDefinitions = Object.values(mergedNodes);
        if (config2 == null ? void 0 : config2.sort) {
          const sortFn = typeof config2.sort === "function" ? config2.sort : utils_js_1.defaultStringComparator;
          mergedNodeDefinitions.sort((a2, b) => {
            var _a2, _b2;
            return sortFn((_a2 = a2.name) == null ? void 0 : _a2.value, (_b2 = b.name) == null ? void 0 : _b2.value);
          });
        }
        return mergedNodeDefinitions;
      }
      exports2.mergeGraphQLTypes = mergeGraphQLTypes;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js
  var require_typedefs_mergers = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/index.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_arguments(), exports2);
      tslib_1.__exportStar(require_directives3(), exports2);
      tslib_1.__exportStar(require_enum_values(), exports2);
      tslib_1.__exportStar(require_enum(), exports2);
      tslib_1.__exportStar(require_fields2(), exports2);
      tslib_1.__exportStar(require_input_type(), exports2);
      tslib_1.__exportStar(require_interface(), exports2);
      tslib_1.__exportStar(require_merge_named_type_array(), exports2);
      tslib_1.__exportStar(require_merge_nodes(), exports2);
      tslib_1.__exportStar(require_merge_typedefs(), exports2);
      tslib_1.__exportStar(require_scalar(), exports2);
      tslib_1.__exportStar(require_type(), exports2);
      tslib_1.__exportStar(require_union(), exports2);
      tslib_1.__exportStar(require_utils5(), exports2);
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/extensions.js
  var require_extensions = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/extensions.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.applyExtensions = exports2.mergeExtensions = exports2.extractExtensionsFromSchema = void 0;
      var utils_1 = require_cjs();
      var utils_2 = require_cjs();
      Object.defineProperty(exports2, "extractExtensionsFromSchema", { enumerable: true, get: function() {
        return utils_2.extractExtensionsFromSchema;
      } });
      function mergeExtensions(extensions) {
        return (0, utils_1.mergeDeep)(extensions);
      }
      exports2.mergeExtensions = mergeExtensions;
      function applyExtensionObject(obj, extensions) {
        if (!obj) {
          return;
        }
        obj.extensions = (0, utils_1.mergeDeep)([obj.extensions || {}, extensions || {}]);
      }
      function applyExtensions(schema, extensions) {
        applyExtensionObject(schema, extensions.schemaExtensions);
        for (const [typeName, data] of Object.entries(extensions.types || {})) {
          const type = schema.getType(typeName);
          if (type) {
            applyExtensionObject(type, data.extensions);
            if (data.type === "object" || data.type === "interface") {
              for (const [fieldName, fieldData] of Object.entries(data.fields)) {
                const field = type.getFields()[fieldName];
                if (field) {
                  applyExtensionObject(field, fieldData.extensions);
                  for (const [arg, argData] of Object.entries(fieldData.arguments)) {
                    applyExtensionObject(field.args.find((a2) => a2.name === arg), argData);
                  }
                }
              }
            } else if (data.type === "input") {
              for (const [fieldName, fieldData] of Object.entries(data.fields)) {
                const field = type.getFields()[fieldName];
                applyExtensionObject(field, fieldData.extensions);
              }
            } else if (data.type === "enum") {
              for (const [valueName, valueData] of Object.entries(data.values)) {
                const value = type.getValue(valueName);
                applyExtensionObject(value, valueData);
              }
            }
          }
        }
        return schema;
      }
      exports2.applyExtensions = applyExtensions;
    }
  });

  // ../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/index.js
  var require_cjs2 = __commonJS({
    "../../node_modules/.pnpm/@graphql-tools+merge@9.0.0_graphql@16.7.1/node_modules/@graphql-tools/merge/cjs/index.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_merge_resolvers(), exports2);
      tslib_1.__exportStar(require_typedefs_mergers(), exports2);
      tslib_1.__exportStar(require_extensions(), exports2);
    }
  });

  // ../../composition/dist/normalization/normalization-factory.js
  var require_normalization_factory = __commonJS({
    "../../composition/dist/normalization/normalization-factory.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NormalizationFactory = exports2.normalizeSubgraph = exports2.normalizeSubgraphFromString = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var utils_1 = require_utils3();
      var utils_2 = require_utils4();
      var constants_1 = require_constants();
      var type_merging_1 = require_type_merging();
      var utils_3 = require_utils();
      var errors_1 = require_errors();
      var string_constants_1 = require_string_constants();
      var buildASTSchema_1 = require_buildASTSchema();
      var merge_1 = require_cjs2();
      var ast_1 = require_ast();
      function normalizeSubgraphFromString(subgraph) {
        let document;
        try {
          document = (0, graphql_1.parse)(subgraph);
        } catch (err) {
          return { errors: [(0, errors_1.subgraphInvalidSyntaxError)(err)] };
        }
        const normalizationFactory = new NormalizationFactory();
        return normalizationFactory.normalize(document);
      }
      exports2.normalizeSubgraphFromString = normalizeSubgraphFromString;
      function normalizeSubgraph(document) {
        const normalizationFactory = new NormalizationFactory();
        return normalizationFactory.normalize(document);
      }
      exports2.normalizeSubgraph = normalizeSubgraph;
      var NormalizationFactory = class {
        constructor() {
          __publicField(this, "abstractToConcreteTypeNames", /* @__PURE__ */ new Map());
          __publicField(this, "allDirectiveDefinitions", /* @__PURE__ */ new Map());
          __publicField(this, "customDirectiveDefinitions", /* @__PURE__ */ new Map());
          __publicField(this, "errors", []);
          __publicField(this, "entityMap", /* @__PURE__ */ new Map());
          __publicField(this, "keyFieldsByParentTypeName", /* @__PURE__ */ new Map());
          __publicField(this, "operationTypeNames", /* @__PURE__ */ new Map());
          __publicField(this, "parents", /* @__PURE__ */ new Map());
          __publicField(this, "parentTypeName", "");
          __publicField(this, "parentsWithChildArguments", /* @__PURE__ */ new Set());
          __publicField(this, "extensions", /* @__PURE__ */ new Map());
          __publicField(this, "isChild", false);
          __publicField(this, "isCurrentParentExtension", false);
          __publicField(this, "isSubgraphVersionTwo", false);
          __publicField(this, "schemaDefinition");
          __publicField(this, "referencedDirectives", /* @__PURE__ */ new Set());
          __publicField(this, "referencedTypeNames", /* @__PURE__ */ new Set());
          for (const baseDirectiveDefinition of constants_1.BASE_DIRECTIVE_DEFINITIONS) {
            this.allDirectiveDefinitions.set(baseDirectiveDefinition.name.value, baseDirectiveDefinition);
          }
          this.schemaDefinition = {
            directives: /* @__PURE__ */ new Map(),
            kind: graphql_1.Kind.SCHEMA_DEFINITION,
            name: (0, utils_1.stringToNameNode)(string_constants_1.SCHEMA),
            operationTypes: /* @__PURE__ */ new Map()
          };
        }
        validateInputNamedType(namedType) {
          if (constants_1.BASE_SCALARS.has(namedType)) {
            return { hasUnhandledError: false, typeString: "" };
          }
          const parentContainer = this.parents.get(namedType);
          if (!parentContainer) {
            this.errors.push((0, errors_1.undefinedTypeError)(namedType));
            return { hasUnhandledError: false, typeString: "" };
          }
          switch (parentContainer.kind) {
            case graphql_1.Kind.ENUM_TYPE_DEFINITION:
            case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
            case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
              return { hasUnhandledError: false, typeString: "" };
            default:
              return { hasUnhandledError: true, typeString: (0, utils_3.kindToTypeString)(parentContainer.kind) };
          }
        }
        extractArguments(node, argumentByName, fieldPath) {
          if (!node.arguments) {
            return argumentByName;
          }
          this.parentsWithChildArguments.add(this.parentTypeName);
          const duplicatedArguments = /* @__PURE__ */ new Set();
          for (const argumentNode of node.arguments) {
            const argumentName = argumentNode.name.value;
            if (argumentByName.has(argumentName)) {
              duplicatedArguments.add(argumentName);
              continue;
            }
            argumentByName.set(argumentName, (0, ast_1.inputValueDefinitionNodeToMutable)(argumentNode, this.parentTypeName));
          }
          if (duplicatedArguments.size > 0) {
            this.errors.push((0, errors_1.duplicateArgumentsError)(fieldPath, [...duplicatedArguments]));
          }
          return argumentByName;
        }
        validateArguments(fieldContainer, fieldPath) {
          const invalidArguments = [];
          for (const [argumentName, argumentNode] of fieldContainer.arguments) {
            const namedType = (0, type_merging_1.getNamedTypeForChild)(fieldPath + `(${argumentName}...)`, argumentNode.type);
            const { hasUnhandledError, typeString } = this.validateInputNamedType(namedType);
            if (hasUnhandledError) {
              invalidArguments.push({ argumentName, namedType, typeString, typeName: (0, merge_1.printTypeNode)(argumentNode.type) });
            }
          }
          if (invalidArguments.length > 0) {
            this.errors.push((0, errors_1.invalidArgumentsError)(fieldPath, invalidArguments));
          }
        }
        extractDirectives(node, map) {
          if (!node.directives) {
            return map;
          }
          for (const directive of node.directives) {
            const directiveName = directive.name.value;
            if (directiveName === string_constants_1.EXTENDS) {
              continue;
            }
            const existingDirectives = map.get(directiveName);
            if (existingDirectives) {
              existingDirectives.push(directive);
              continue;
            }
            map.set(directiveName, [directive]);
          }
          return map;
        }
        extractUniqueUnionMembers(members, map) {
          for (const member of members) {
            const name2 = member.name.value;
            if (map.has(name2)) {
              this.errors.push(new Error(`Member "${name2} can only be defined on union "${this.parentTypeName}" once.`));
              continue;
            }
            if (!constants_1.BASE_SCALARS.has(name2)) {
              this.referencedTypeNames.add(name2);
            }
            map.set(name2, member);
          }
          return map;
        }
        mergeUniqueInterfaces(extensionInterfaces, interfaces, typeName) {
          for (const interfaceName of extensionInterfaces) {
            if (!interfaces.has(interfaceName)) {
              interfaces.add(interfaceName);
              continue;
            }
            this.errors.push((0, errors_1.duplicateInterfaceExtensionError)(interfaceName, typeName));
          }
        }
        mergeUniqueUnionMembers(baseUnion, extensionUnion) {
          if (!extensionUnion) {
            return;
          }
          const extensionMembers = extensionUnion.types;
          const members = baseUnion.types;
          const typeName = baseUnion.name.value;
          for (const [memberName, namedTypeNode] of extensionMembers) {
            if (!members.has(memberName)) {
              members.set(memberName, namedTypeNode);
              continue;
            }
            this.errors.push((0, errors_1.duplicateUnionMemberError)(memberName, typeName));
          }
        }
        mergeDirectives(baseTypeDirectives, extension) {
          if (!extension) {
            return;
          }
          for (const [directiveName, directives] of extension.directives) {
            const existingDirectives = baseTypeDirectives.get(directiveName);
            if (existingDirectives) {
              existingDirectives.push(...directives);
              continue;
            }
            baseTypeDirectives.set(directiveName, [...directives]);
          }
        }
        getValidatedAndNormalizedParentDirectives(parent) {
          const parentTypeName = parent.name.value;
          const normalizedDirectives = [];
          for (const [directiveName, directives] of parent.directives) {
            const definition = this.allDirectiveDefinitions.get(directiveName);
            if (!definition) {
              this.errors.push((0, errors_1.undefinedDirectiveError)(directiveName, parentTypeName));
              continue;
            }
            const allArguments = /* @__PURE__ */ new Set();
            const requiredArguments = /* @__PURE__ */ new Set();
            (0, utils_2.getDirectiveDefinitionArgumentSets)(definition.arguments || [], allArguments, requiredArguments);
            const entityKeys = /* @__PURE__ */ new Set();
            const errorMessages = [];
            for (const directive of directives) {
              if (!(0, utils_2.areNodeKindAndDirectiveLocationCompatible)(parent.kind, definition)) {
                errorMessages.push((0, errors_1.invalidDirectiveLocationErrorMessage)(parentTypeName, parent.kind, directiveName));
              }
              if (!definition.repeatable && directives.length > 1) {
                errorMessages.push((0, errors_1.invalidRepeatedDirectiveErrorMessage)(directiveName, parentTypeName));
              }
              if (!definition.arguments || definition.arguments.length < 1) {
                if (directive.arguments && directive.arguments.length > 0) {
                  errorMessages.push((0, errors_1.unexpectedDirectiveArgumentsErrorMessage)(directive, parentTypeName));
                } else {
                  normalizedDirectives.push(directive);
                }
                continue;
              }
              if (!directive.arguments || directive.arguments.length < 1) {
                if (requiredArguments.size > 0) {
                  errorMessages.push((0, errors_1.undefinedRequiredArgumentsErrorMessage)(directiveName, parentTypeName, [...requiredArguments]));
                } else {
                  normalizedDirectives.push(directive);
                }
                continue;
              }
              const definedArguments = (0, utils_2.getDefinedArgumentsForDirective)(directive.arguments, allArguments, directiveName, parentTypeName, errorMessages);
              const missingRequiredArguments = (0, utils_3.getEntriesNotInHashSet)(requiredArguments, definedArguments);
              if (missingRequiredArguments.length > 0) {
                errorMessages.push((0, errors_1.undefinedRequiredArgumentsErrorMessage)(directiveName, parentTypeName, [...requiredArguments], missingRequiredArguments));
              }
              if (directiveName === string_constants_1.KEY) {
                const directiveKind = directive.arguments[0].value.kind;
                if (directiveKind !== graphql_1.Kind.STRING) {
                  errorMessages.push((0, errors_1.invalidKeyDirectiveArgumentErrorMessage)(directiveKind));
                  continue;
                }
                const entityKey = directive.arguments[0].value.value;
                if (entityKeys.has(entityKey)) {
                  continue;
                }
                entityKeys.add(entityKey);
              }
              normalizedDirectives.push(directive);
            }
            if (errorMessages.length > 0) {
              this.errors.push((0, errors_1.invalidDirectiveError)(directiveName, parentTypeName, errorMessages));
            }
          }
          return normalizedDirectives;
        }
        convertKindForExtension(node) {
          switch (node.kind) {
            case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              return graphql_1.Kind.INTERFACE_TYPE_EXTENSION;
            case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
              return graphql_1.Kind.OBJECT_TYPE_EXTENSION;
            default:
              return node.kind;
          }
        }
        handleObjectLikeExtension(node) {
          this.isCurrentParentExtension = true;
          const extension = this.extensions.get(this.parentTypeName);
          const convertedKind = this.convertKindForExtension(node);
          if (extension) {
            if (extension.kind !== convertedKind) {
              this.errors.push((0, errors_1.incompatibleExtensionKindsError)(node, extension.kind));
              return false;
            }
            this.extractDirectives(node, extension.directives);
            (0, utils_1.extractInterfaces)(node, extension.interfaces, this.errors);
            return;
          }
          const isEntity = (0, utils_1.isObjectLikeNodeEntity)(node);
          const interfaces = /* @__PURE__ */ new Set();
          this.extensions.set(this.parentTypeName, {
            directives: this.extractDirectives(node, /* @__PURE__ */ new Map()),
            fields: /* @__PURE__ */ new Map(),
            interfaces: (0, utils_1.extractInterfaces)(node, interfaces, this.errors),
            isEntity,
            kind: convertedKind,
            name: node.name
          });
          if (node.kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION || node.kind === graphql_1.Kind.INTERFACE_TYPE_EXTENSION || !isEntity) {
            return;
          }
          const existingEntityKeyMap = this.entityMap.get(this.parentTypeName);
          const { entityKeyMap, errors } = (0, utils_1.getEntityKeyExtractionResults)(node, existingEntityKeyMap || /* @__PURE__ */ new Map());
          if (errors.length > 0) {
            this.errors.push(...errors);
          }
          if (!existingEntityKeyMap) {
            this.entityMap.set(this.parentTypeName, entityKeyMap);
          }
        }
        validateChildDirectives(child, hostPath) {
          const childKind = child.node.kind;
          for (const [directiveName, directives] of child.directives) {
            const definition = this.allDirectiveDefinitions.get(directiveName);
            if (!definition) {
              this.errors.push((0, errors_1.undefinedDirectiveError)(directiveName, hostPath));
              continue;
            }
            const allArguments = /* @__PURE__ */ new Set();
            const requiredArguments = /* @__PURE__ */ new Set();
            (0, utils_2.getDirectiveDefinitionArgumentSets)(definition.arguments || [], allArguments, requiredArguments);
            const errorMessages = [];
            for (const directive of directives) {
              if (!(0, utils_2.areNodeKindAndDirectiveLocationCompatible)(childKind, definition)) {
                errorMessages.push((0, errors_1.invalidDirectiveLocationErrorMessage)(hostPath, childKind, directiveName));
              }
              if (!definition.repeatable && directives.length > 1) {
                errorMessages.push((0, errors_1.invalidRepeatedDirectiveErrorMessage)(directiveName, hostPath));
              }
              if (!definition.arguments || definition.arguments.length < 1) {
                if (directive.arguments && directive.arguments.length > 0) {
                  errorMessages.push((0, errors_1.unexpectedDirectiveArgumentsErrorMessage)(directive, hostPath));
                }
                continue;
              }
              if (!directive.arguments || directive.arguments.length < 1) {
                if (requiredArguments.size > 0) {
                  errorMessages.push((0, errors_1.undefinedRequiredArgumentsErrorMessage)(directiveName, hostPath, [...requiredArguments]));
                }
                continue;
              }
              const definedArguments = (0, utils_2.getDefinedArgumentsForDirective)(directive.arguments, allArguments, directiveName, hostPath, errorMessages);
              const missingRequiredArguments = (0, utils_3.getEntriesNotInHashSet)(requiredArguments, definedArguments);
              if (missingRequiredArguments.length > 0) {
                errorMessages.push((0, errors_1.undefinedRequiredArgumentsErrorMessage)(directiveName, hostPath, [...requiredArguments], missingRequiredArguments));
              }
            }
            if (errorMessages.length > 0) {
              this.errors.push((0, errors_1.invalidDirectiveError)(directiveName, hostPath, errorMessages));
            }
          }
        }
        isTypeValidImplementation(originalType, implementationType) {
          if (originalType.kind === graphql_1.Kind.NON_NULL_TYPE) {
            if (implementationType.kind !== graphql_1.Kind.NON_NULL_TYPE) {
              return false;
            }
            return this.isTypeValidImplementation(originalType.type, implementationType.type);
          }
          if (implementationType.kind === graphql_1.Kind.NON_NULL_TYPE) {
            return this.isTypeValidImplementation(originalType, implementationType.type);
          }
          switch (originalType.kind) {
            case graphql_1.Kind.NAMED_TYPE:
              if (implementationType.kind === graphql_1.Kind.NAMED_TYPE) {
                const originalTypeName = originalType.name.value;
                const implementationTypeName = implementationType.name.value;
                if (originalTypeName === implementationTypeName) {
                  return true;
                }
                const concreteTypes = this.abstractToConcreteTypeNames.get(originalTypeName);
                if (!concreteTypes) {
                  return false;
                }
                return concreteTypes.has(implementationTypeName);
              }
              return false;
            default:
              if (implementationType.kind === graphql_1.Kind.LIST_TYPE) {
                return this.isTypeValidImplementation(originalType.type, implementationType.type);
              }
              return false;
          }
        }
        validateInterfaceImplementations(container) {
          if (container.interfaces.size < 1) {
            return;
          }
          const implementationErrorsMap = /* @__PURE__ */ new Map();
          for (const interfaceName of container.interfaces) {
            const interfaceContainer = (0, utils_3.getOrThrowError)(this.parents, interfaceName, string_constants_1.PARENTS);
            if (interfaceContainer.kind !== graphql_1.Kind.INTERFACE_TYPE_DEFINITION) {
              throw (0, errors_1.incompatibleParentKindFatalError)(interfaceName, graphql_1.Kind.INTERFACE_TYPE_DEFINITION, interfaceContainer.kind);
            }
            const implementationErrors = {
              invalidFieldImplementations: /* @__PURE__ */ new Map(),
              unimplementedFields: []
            };
            let hasErrors = false;
            for (const [fieldName, interfaceField] of interfaceContainer.fields) {
              let hasNestedErrors = false;
              const containerField = container.fields.get(fieldName);
              if (!containerField) {
                hasErrors = true;
                implementationErrors.unimplementedFields.push(fieldName);
                continue;
              }
              const invalidFieldImplementation = {
                invalidAdditionalArguments: /* @__PURE__ */ new Set(),
                invalidImplementedArguments: [],
                originalResponseType: (0, merge_1.printTypeNode)(interfaceField.node.type),
                unimplementedArguments: /* @__PURE__ */ new Set()
              };
              if (!this.isTypeValidImplementation(interfaceField.node.type, containerField.node.type)) {
                hasErrors = true;
                hasNestedErrors = true;
                invalidFieldImplementation.implementedResponseType = (0, merge_1.printTypeNode)(containerField.node.type);
              }
              const handledArguments = /* @__PURE__ */ new Set();
              for (const [argumentName, interfaceArgument] of interfaceField.arguments) {
                handledArguments.add(argumentName);
                const containerArgument = containerField.arguments.get(argumentName);
                if (!containerArgument) {
                  hasErrors = true;
                  hasNestedErrors = true;
                  invalidFieldImplementation.unimplementedArguments.add(argumentName);
                  continue;
                }
                const actualType = (0, merge_1.printTypeNode)(containerArgument.type);
                const expectedType = (0, merge_1.printTypeNode)(interfaceArgument.type);
                if (expectedType !== actualType) {
                  hasErrors = true;
                  hasNestedErrors = true;
                  invalidFieldImplementation.invalidImplementedArguments.push({ actualType, argumentName, expectedType });
                }
              }
              for (const [argumentName, argumentNode] of containerField.arguments) {
                if (handledArguments.has(argumentName)) {
                  continue;
                }
                if (argumentNode.type.kind !== graphql_1.Kind.NON_NULL_TYPE) {
                  continue;
                }
                hasErrors = true;
                hasNestedErrors = true;
                invalidFieldImplementation.invalidAdditionalArguments.add(argumentName);
              }
              if (hasNestedErrors) {
                implementationErrors.invalidFieldImplementations.set(fieldName, invalidFieldImplementation);
              }
            }
            if (hasErrors) {
              implementationErrorsMap.set(interfaceName, implementationErrors);
            }
          }
          if (implementationErrorsMap.size) {
            this.errors.push((0, errors_1.unimplementedInterfaceFieldsError)(container.name.value, (0, utils_3.kindToTypeString)(container.kind), implementationErrorsMap));
          }
        }
        normalize(document) {
          const factory = this;
          const definedDirectives = /* @__PURE__ */ new Set();
          let isCurrentParentRootType = false;
          (0, graphql_1.visit)(document, {
            DirectiveDefinition: {
              enter(node) {
                const name2 = node.name.value;
                if (definedDirectives.has(name2)) {
                  factory.errors.push((0, errors_1.duplicateDirectiveDefinitionError)(name2));
                  return false;
                } else {
                  definedDirectives.add(name2);
                }
                if (constants_1.VERSION_TWO_DIRECTIVES.has(name2)) {
                  factory.isSubgraphVersionTwo = true;
                  return false;
                }
                if (constants_1.VERSION_ONE_DIRECTIVES.has(name2)) {
                  return false;
                }
                factory.allDirectiveDefinitions.set(name2, node);
                factory.customDirectiveDefinitions.set(name2, node);
                return false;
              }
            },
            Directive: {
              enter(node) {
                const name2 = node.name.value;
                if (constants_1.VERSION_TWO_DIRECTIVES.has(name2)) {
                  factory.isSubgraphVersionTwo = true;
                  return false;
                }
                if (constants_1.VERSION_ONE_DIRECTIVES.has(name2)) {
                  return false;
                }
                factory.referencedDirectives.add(name2);
              }
            },
            EnumTypeDefinition: {
              enter(node) {
                const name2 = node.name.value;
                if (factory.parents.has(name2)) {
                  factory.errors.push((0, errors_1.duplicateTypeDefinitionError)((0, utils_3.kindToTypeString)(node.kind), name2));
                  return false;
                }
                factory.parentTypeName = name2;
                factory.parents.set(name2, {
                  description: (0, utils_1.formatDescription)(node.description),
                  directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                  kind: node.kind,
                  name: node.name,
                  values: /* @__PURE__ */ new Map()
                });
              },
              leave() {
                factory.parentTypeName = "";
              }
            },
            EnumTypeExtension: {
              enter(node) {
                const name2 = node.name.value;
                factory.parentTypeName = name2;
                factory.isCurrentParentExtension = true;
                const extension = factory.extensions.get(factory.parentTypeName);
                if (extension) {
                  if (extension.kind !== graphql_1.Kind.ENUM_TYPE_EXTENSION) {
                    factory.errors.push((0, errors_1.incompatibleExtensionKindsError)(node, extension.kind));
                    return false;
                  }
                  factory.extractDirectives(node, extension.directives);
                  return;
                }
                factory.extensions.set(name2, {
                  directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                  kind: node.kind,
                  name: node.name,
                  values: /* @__PURE__ */ new Map()
                });
              },
              leave() {
                factory.isCurrentParentExtension = false;
                factory.parentTypeName = "";
              }
            },
            EnumValueDefinition: {
              enter(node) {
                const name2 = node.name.value;
                const parent = factory.isCurrentParentExtension ? (0, utils_3.getOrThrowError)(factory.extensions, factory.parentTypeName, string_constants_1.EXTENSIONS) : (0, utils_3.getOrThrowError)(factory.parents, factory.parentTypeName, string_constants_1.PARENTS);
                if (parent.kind !== graphql_1.Kind.ENUM_TYPE_DEFINITION && parent.kind !== graphql_1.Kind.ENUM_TYPE_EXTENSION) {
                  throw (0, errors_1.unexpectedKindFatalError)(name2);
                }
                if (parent.values.has(name2)) {
                  const error = factory.isCurrentParentExtension ? (0, errors_1.duplicateValueExtensionError)("enum", factory.parentTypeName, name2) : (0, errors_1.duplicateEnumValueDefinitionError)(name2, factory.parentTypeName);
                  factory.errors.push(error);
                  return;
                }
                parent.values.set(name2, {
                  directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                  name: name2,
                  node: __spreadProps(__spreadValues({}, node), { description: (0, utils_1.formatDescription)(node.description) })
                });
              }
            },
            FieldDefinition: {
              enter(node) {
                var _a;
                const name2 = node.name.value;
                if (isCurrentParentRootType && (name2 === string_constants_1.SERVICE_FIELD || name2 === string_constants_1.ENTITIES_FIELD)) {
                  return false;
                }
                const fieldPath = `${factory.parentTypeName}.${name2}`;
                factory.isChild = true;
                const fieldRootType = (0, type_merging_1.getNamedTypeForChild)(fieldPath, node.type);
                if (!constants_1.BASE_SCALARS.has(fieldRootType)) {
                  factory.referencedTypeNames.add(fieldRootType);
                }
                const parent = factory.isCurrentParentExtension ? (0, utils_3.getOrThrowError)(factory.extensions, factory.parentTypeName, string_constants_1.EXTENSIONS) : (0, utils_3.getOrThrowError)(factory.parents, factory.parentTypeName, string_constants_1.PARENTS);
                if (parent.kind !== graphql_1.Kind.OBJECT_TYPE_DEFINITION && parent.kind !== graphql_1.Kind.OBJECT_TYPE_EXTENSION && parent.kind !== graphql_1.Kind.INTERFACE_TYPE_DEFINITION && parent.kind !== graphql_1.Kind.INTERFACE_TYPE_EXTENSION) {
                  throw (0, errors_1.unexpectedKindFatalError)(factory.parentTypeName);
                }
                if (parent.fields.has(name2)) {
                  const error = factory.isCurrentParentExtension ? (0, errors_1.duplicateFieldExtensionError)(factory.parentTypeName, name2) : (0, errors_1.duplicateFieldDefinitionError)(name2, factory.parentTypeName);
                  factory.errors.push(error);
                  return;
                }
                parent.fields.set(name2, {
                  arguments: factory.extractArguments(node, /* @__PURE__ */ new Map(), fieldPath),
                  directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                  name: name2,
                  node: __spreadProps(__spreadValues({}, node), {
                    arguments: (_a = node.arguments) == null ? void 0 : _a.map((arg) => __spreadProps(__spreadValues({}, arg), {
                      description: (0, utils_1.formatDescription)(arg.description)
                    }))
                  })
                });
              },
              leave() {
                factory.isChild = false;
              }
            },
            InputObjectTypeDefinition: {
              enter(node) {
                const name2 = node.name.value;
                if (factory.parents.has(name2)) {
                  factory.errors.push((0, errors_1.duplicateTypeDefinitionError)((0, utils_3.kindToTypeString)(node.kind), name2));
                  return false;
                }
                factory.parentTypeName = name2;
                factory.parents.set(name2, {
                  description: (0, utils_1.formatDescription)(node.description),
                  directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                  fields: /* @__PURE__ */ new Map(),
                  kind: node.kind,
                  name: node.name
                });
              },
              leave() {
                factory.parentTypeName = "";
              }
            },
            InputObjectTypeExtension: {
              enter(node) {
                const name2 = node.name.value;
                factory.parentTypeName = name2;
                factory.isCurrentParentExtension = true;
                const extension = factory.extensions.get(factory.parentTypeName);
                if (extension) {
                  if (extension.kind !== graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION) {
                    factory.errors.push((0, errors_1.incompatibleExtensionKindsError)(node, extension.kind));
                    return false;
                  }
                  factory.extractDirectives(node, extension.directives);
                  return;
                }
                factory.extensions.set(name2, {
                  directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                  fields: /* @__PURE__ */ new Map(),
                  kind: node.kind,
                  name: node.name
                });
              },
              leave() {
                factory.isCurrentParentExtension = false;
                factory.parentTypeName = "";
              }
            },
            InputValueDefinition: {
              enter(node) {
                if (!factory.parentTypeName || factory.isChild) {
                  return;
                }
                const name2 = node.name.value;
                const valueRootTypeName = (0, type_merging_1.getNamedTypeForChild)(`${factory.parentTypeName}.${name2}`, node.type);
                if (!constants_1.BASE_SCALARS.has(valueRootTypeName)) {
                  factory.referencedTypeNames.add(valueRootTypeName);
                }
                const parent = factory.isCurrentParentExtension ? (0, utils_3.getOrThrowError)(factory.extensions, factory.parentTypeName, string_constants_1.EXTENSIONS) : (0, utils_3.getOrThrowError)(factory.parents, factory.parentTypeName, string_constants_1.PARENTS);
                if (parent.kind !== graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION && parent.kind !== graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION) {
                  throw (0, errors_1.unexpectedKindFatalError)(factory.parentTypeName);
                }
                if (parent.fields.has(name2)) {
                  factory.errors.push((0, errors_1.duplicateValueExtensionError)("input", factory.parentTypeName, name2));
                  return;
                }
                parent.fields.set(name2, {
                  directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                  name: name2,
                  node: __spreadProps(__spreadValues({}, node), { description: (0, utils_1.formatDescription)(node.description) })
                });
              }
            },
            InterfaceTypeDefinition: {
              enter(node) {
                const name2 = node.name.value;
                factory.parentTypeName = name2;
                if ((0, utils_1.isNodeExtension)(node)) {
                  return factory.handleObjectLikeExtension(node);
                }
                if (factory.parents.has(name2)) {
                  factory.errors.push((0, errors_1.duplicateTypeDefinitionError)((0, utils_3.kindToTypeString)(node.kind), name2));
                  return false;
                }
                factory.parents.set(name2, {
                  description: (0, utils_1.formatDescription)(node.description),
                  directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                  fields: /* @__PURE__ */ new Map(),
                  interfaces: (0, utils_1.extractInterfaces)(node, /* @__PURE__ */ new Set(), factory.errors),
                  kind: node.kind,
                  name: node.name
                });
              },
              leave() {
                factory.isCurrentParentExtension = false;
                factory.parentTypeName = "";
              }
            },
            InterfaceTypeExtension: {
              enter(node) {
                factory.parentTypeName = node.name.value;
                return factory.handleObjectLikeExtension(node);
              },
              leave() {
                factory.isCurrentParentExtension = false;
                factory.parentTypeName = "";
              }
            },
            ObjectTypeDefinition: {
              enter(node) {
                const name2 = node.name.value;
                if (name2 === string_constants_1.SERVICE_OBJECT) {
                  return false;
                }
                isCurrentParentRootType = string_constants_1.ROOT_TYPES.has(name2);
                factory.parentTypeName = name2;
                (0, utils_1.addConcreteTypesForImplementedInterfaces)(node, factory.abstractToConcreteTypeNames);
                if ((0, utils_1.isNodeExtension)(node)) {
                  return factory.handleObjectLikeExtension(node);
                }
                if (factory.parents.has(name2)) {
                  factory.errors.push((0, errors_1.duplicateTypeDefinitionError)((0, utils_3.kindToTypeString)(node.kind), name2));
                  return false;
                }
                const isEntity = (0, utils_1.isObjectLikeNodeEntity)(node);
                factory.parents.set(name2, {
                  description: (0, utils_1.formatDescription)(node.description),
                  directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                  fields: /* @__PURE__ */ new Map(),
                  interfaces: (0, utils_1.extractInterfaces)(node, /* @__PURE__ */ new Set(), factory.errors),
                  isEntity,
                  kind: node.kind,
                  name: node.name
                });
                if (!isEntity) {
                  return;
                }
                const existingEntityKeyMap = factory.entityMap.get(name2);
                const { entityKeyMap, errors } = (0, utils_1.getEntityKeyExtractionResults)(node, existingEntityKeyMap || /* @__PURE__ */ new Map());
                if (errors.length > 0) {
                  factory.errors.push(...errors);
                }
                if (!existingEntityKeyMap) {
                  factory.entityMap.set(name2, entityKeyMap);
                }
              },
              leave() {
                factory.isCurrentParentExtension = false;
                isCurrentParentRootType = false;
                factory.parentTypeName = "";
              }
            },
            ObjectTypeExtension: {
              enter(node) {
                const name2 = node.name.value;
                if (name2 === string_constants_1.SERVICE_OBJECT) {
                  return false;
                }
                isCurrentParentRootType = string_constants_1.ROOT_TYPES.has(name2);
                factory.parentTypeName = name2;
                (0, utils_1.addConcreteTypesForImplementedInterfaces)(node, factory.abstractToConcreteTypeNames);
                return factory.handleObjectLikeExtension(node);
              },
              leave() {
                factory.isCurrentParentExtension = false;
                isCurrentParentRootType = false;
                factory.parentTypeName = "";
              }
            },
            OperationTypeDefinition: {
              enter(node) {
                const operationType = node.operation;
                const operationPath = `${factory.parentTypeName}.${operationType}`;
                const definitionNode = factory.schemaDefinition.operationTypes.get(operationType);
                const newTypeName = (0, type_merging_1.getNamedTypeForChild)(operationPath, node.type);
                if (definitionNode) {
                  (0, errors_1.duplicateOperationTypeDefinitionError)(operationType, newTypeName, (0, type_merging_1.getNamedTypeForChild)(operationPath, definitionNode.type));
                  return false;
                }
                const existingOperationType = factory.operationTypeNames.get(newTypeName);
                if (existingOperationType) {
                  factory.errors.push((0, errors_1.invalidOperationTypeDefinitionError)(existingOperationType, newTypeName, operationType));
                } else {
                  factory.operationTypeNames.set(newTypeName, operationType);
                  factory.schemaDefinition.operationTypes.set(operationType, node);
                }
                return false;
              }
            },
            ScalarTypeDefinition: {
              enter(node) {
                const name2 = node.name.value;
                if (name2 === string_constants_1.ANY_SCALAR) {
                  return false;
                }
                const parent = factory.parents.get(name2);
                if (parent) {
                  factory.errors.push((0, errors_1.duplicateTypeDefinitionError)((0, utils_3.kindToTypeString)(node.kind), name2));
                  return false;
                }
                factory.parents.set(name2, {
                  description: (0, utils_1.formatDescription)(node.description),
                  directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                  kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
                  name: node.name
                });
              }
            },
            ScalarTypeExtension: {
              enter(node) {
                const name2 = node.name.value;
                if (name2 === string_constants_1.ANY_SCALAR) {
                  return false;
                }
                const extension = factory.extensions.get(name2);
                if (extension) {
                  if (extension.kind !== graphql_1.Kind.SCALAR_TYPE_EXTENSION) {
                    factory.errors.push((0, errors_1.incompatibleExtensionKindsError)(node, extension.kind));
                    return false;
                  }
                  factory.extractDirectives(node, extension.directives);
                } else {
                  factory.extensions.set(name2, {
                    directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                    kind: node.kind,
                    name: node.name
                  });
                }
                return false;
              }
            },
            SchemaDefinition: {
              enter(node) {
                factory.extractDirectives(node, factory.schemaDefinition.directives);
                factory.schemaDefinition.description = node.description;
              }
            },
            SchemaExtension: {
              enter(node) {
                factory.extractDirectives(node, factory.schemaDefinition.directives);
              }
            },
            UnionTypeDefinition: {
              enter(node) {
                const name2 = node.name.value;
                if (name2 === string_constants_1.ENTITY_UNION) {
                  return false;
                }
                factory.parentTypeName = name2;
                const parent = factory.parents.get(name2);
                if (parent) {
                  factory.errors.push((0, errors_1.duplicateTypeDefinitionError)((0, utils_3.kindToTypeString)(node.kind), name2));
                  return false;
                }
                if (!node.types) {
                  factory.errors.push((0, errors_1.noDefinedUnionMembersError)(name2));
                  return false;
                }
                (0, utils_1.addConcreteTypesForUnion)(node, factory.abstractToConcreteTypeNames);
                factory.parents.set(name2, {
                  description: (0, utils_1.formatDescription)(node.description),
                  directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                  kind: node.kind,
                  name: node.name,
                  types: factory.extractUniqueUnionMembers([...node.types], /* @__PURE__ */ new Map())
                });
              },
              leave() {
                factory.parentTypeName = "";
              }
            },
            UnionTypeExtension: {
              enter(node) {
                const name2 = node.name.value;
                if (name2 === string_constants_1.ENTITY_UNION) {
                  return false;
                }
                const extension = factory.extensions.get(name2);
                if (!node.types) {
                  factory.errors.push();
                  return false;
                }
                (0, utils_1.addConcreteTypesForUnion)(node, factory.abstractToConcreteTypeNames);
                if (extension) {
                  if (extension.kind !== graphql_1.Kind.UNION_TYPE_EXTENSION) {
                    factory.errors.push((0, errors_1.incompatibleExtensionKindsError)(node, extension.kind));
                    return false;
                  }
                  factory.extractDirectives(node, extension.directives);
                } else {
                  factory.extensions.set(name2, {
                    directives: factory.extractDirectives(node, /* @__PURE__ */ new Map()),
                    kind: node.kind,
                    name: node.name,
                    types: factory.extractUniqueUnionMembers([...node.types], /* @__PURE__ */ new Map())
                  });
                }
                return false;
              }
            }
          });
          const definitions = [];
          for (const directiveDefinition of constants_1.BASE_DIRECTIVE_DEFINITIONS) {
            definitions.push(directiveDefinition);
          }
          if (factory.isSubgraphVersionTwo) {
            for (const directiveDefinition of constants_1.VERSION_TWO_DIRECTIVE_DEFINITIONS) {
              definitions.push(directiveDefinition);
              this.allDirectiveDefinitions.set(directiveDefinition.name.value, directiveDefinition);
            }
          }
          for (const directiveDefinition of this.customDirectiveDefinitions.values()) {
            definitions.push(directiveDefinition);
          }
          if (this.schemaDefinition.operationTypes.size > 0) {
            definitions.push((0, utils_2.schemaContainerToNode)(this, this.schemaDefinition));
          }
          const configurationDataMap = /* @__PURE__ */ new Map();
          const validExtensionOrphans = /* @__PURE__ */ new Set();
          const parentsToIgnore = /* @__PURE__ */ new Set();
          for (const [extensionTypeName, extensionContainer] of this.extensions) {
            const entity = this.entityMap.get(extensionTypeName);
            const configurationData = {
              fieldNames: /* @__PURE__ */ new Set(),
              isRootNode: !!entity,
              typeName: extensionTypeName
            };
            if (entity) {
              configurationData.keys = [...entity.keys()].map((selectionSet) => ({
                fieldName: "",
                selectionSet
              }));
            }
            if (extensionContainer.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION) {
              if (this.operationTypeNames.has(extensionTypeName)) {
                extensionContainer.fields.delete(string_constants_1.SERVICE_FIELD);
                extensionContainer.fields.delete(string_constants_1.ENTITIES_FIELD);
              }
              (0, utils_3.addIterableValuesToSet)(extensionContainer.fields.keys(), configurationData.fieldNames);
              configurationDataMap.set(extensionTypeName, configurationData);
            }
            const baseType = this.parents.get(extensionTypeName);
            if (!baseType) {
              if (extensionContainer.kind !== graphql_1.Kind.OBJECT_TYPE_EXTENSION) {
                this.errors.push((0, errors_1.noBaseTypeExtensionError)(extensionTypeName));
              } else {
                (0, utils_2.validateEntityKeys)(this, extensionTypeName, true);
                this.validateInterfaceImplementations(extensionContainer);
                validExtensionOrphans.add(extensionTypeName);
                definitions.push((0, utils_2.objectLikeContainerToNode)(this, extensionContainer));
              }
              continue;
            }
            if (!(0, utils_1.areBaseAndExtensionKindsCompatible)(baseType.kind, extensionContainer.kind, extensionTypeName)) {
              this.errors.push((0, errors_1.incompatibleExtensionError)(extensionTypeName, baseType.kind, extensionContainer.kind));
              continue;
            }
            switch (baseType.kind) {
              case graphql_1.Kind.ENUM_TYPE_DEFINITION:
                const enumExtension = extensionContainer;
                for (const [valueName, enumValueDefinitionNode] of enumExtension.values) {
                  if (!baseType.values.has(valueName)) {
                    baseType.values.set(valueName, enumValueDefinitionNode);
                    continue;
                  }
                  this.errors.push((0, errors_1.duplicateEnumValueDefinitionError)(valueName, extensionTypeName));
                }
                definitions.push((0, utils_2.enumContainerToNode)(this, baseType, enumExtension));
                break;
              case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
                const inputExtension = extensionContainer;
                for (const [fieldName, inputValueDefinitionNode] of inputExtension.fields) {
                  if (!baseType.fields.has(fieldName)) {
                    baseType.fields.set(fieldName, inputValueDefinitionNode);
                    continue;
                  }
                  this.errors.push((0, errors_1.duplicateFieldDefinitionError)(fieldName, extensionTypeName));
                }
                definitions.push((0, utils_2.inputObjectContainerToNode)(this, baseType, inputExtension));
                break;
              case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
                const objectLikeExtension = extensionContainer;
                if (this.operationTypeNames.has(extensionTypeName)) {
                  objectLikeExtension.fields.delete(string_constants_1.SERVICE_FIELD);
                  objectLikeExtension.fields.delete(string_constants_1.ENTITIES_FIELD);
                }
                for (const [fieldName, fieldContainer] of objectLikeExtension.fields) {
                  if (fieldContainer.arguments.size > 0) {
                    this.validateArguments(fieldContainer, `${extensionTypeName}.${fieldName}`);
                  }
                  if (baseType.fields.has(fieldName)) {
                    this.errors.push((0, errors_1.duplicateFieldDefinitionError)(fieldName, extensionTypeName));
                    continue;
                  }
                  baseType.fields.set(fieldName, fieldContainer);
                  configurationData.fieldNames.add(fieldName);
                }
                (0, utils_2.validateEntityKeys)(this, extensionTypeName);
                this.mergeUniqueInterfaces(objectLikeExtension.interfaces, baseType.interfaces, extensionTypeName);
                this.validateInterfaceImplementations(baseType);
                configurationDataMap.set(extensionTypeName, configurationData);
                definitions.push((0, utils_2.objectLikeContainerToNode)(this, baseType, objectLikeExtension));
                break;
              case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
                definitions.push((0, utils_2.scalarContainerToNode)(this, baseType, extensionContainer));
                break;
              case graphql_1.Kind.UNION_TYPE_DEFINITION:
                const unionExtension = extensionContainer;
                definitions.push((0, utils_2.unionContainerToNode)(this, baseType, unionExtension));
                break;
              default:
                throw (0, errors_1.unexpectedKindFatalError)(extensionTypeName);
            }
            parentsToIgnore.add(extensionTypeName);
          }
          for (const [parentTypeName, parentContainer] of this.parents) {
            if (parentsToIgnore.has(parentTypeName)) {
              continue;
            }
            switch (parentContainer.kind) {
              case graphql_1.Kind.ENUM_TYPE_DEFINITION:
                definitions.push((0, utils_2.enumContainerToNode)(this, parentContainer));
                break;
              case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
                definitions.push((0, utils_2.inputObjectContainerToNode)(this, parentContainer));
                break;
              case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
                const entity = this.entityMap.get(parentTypeName);
                if (this.operationTypeNames.has(parentTypeName)) {
                  parentContainer.fields.delete(string_constants_1.SERVICE_FIELD);
                  parentContainer.fields.delete(string_constants_1.ENTITIES_FIELD);
                }
                if (this.parentsWithChildArguments.has(parentTypeName)) {
                  const parentContainer2 = (0, utils_3.getOrThrowError)(this.parents, parentTypeName, string_constants_1.PARENTS);
                  if (parentContainer2.kind !== graphql_1.Kind.OBJECT_TYPE_DEFINITION && parentContainer2.kind !== graphql_1.Kind.INTERFACE_TYPE_DEFINITION) {
                    continue;
                  }
                  for (const [fieldName, fieldContainer] of parentContainer2.fields) {
                    this.validateArguments(fieldContainer, `${parentTypeName}.${fieldName}`);
                  }
                }
                const configurationData = {
                  fieldNames: /* @__PURE__ */ new Set(),
                  isRootNode: !!entity,
                  typeName: parentTypeName
                };
                if (entity) {
                  configurationData.keys = [...entity.keys()].map((selectionSet) => ({
                    fieldName: "",
                    selectionSet
                  }));
                }
                (0, utils_3.addIterableValuesToSet)(parentContainer.fields.keys(), configurationData.fieldNames);
                (0, utils_2.validateEntityKeys)(this, parentTypeName);
                this.validateInterfaceImplementations(parentContainer);
                configurationDataMap.set(parentTypeName, configurationData);
                definitions.push((0, utils_2.objectLikeContainerToNode)(this, parentContainer));
                break;
              case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
                definitions.push((0, utils_2.scalarContainerToNode)(this, parentContainer));
                break;
              case graphql_1.Kind.UNION_TYPE_DEFINITION:
                definitions.push((0, utils_2.unionContainerToNode)(this, parentContainer));
                break;
              default:
                throw (0, errors_1.unexpectedKindFatalError)(parentTypeName);
            }
          }
          for (const operationType of Object.values(graphql_1.OperationTypeNode)) {
            const node = this.schemaDefinition.operationTypes.get(operationType);
            const defaultTypeName = (0, utils_3.getOrThrowError)(utils_1.operationTypeNodeToDefaultType, operationType, string_constants_1.OPERATION_TO_DEFAULT);
            const operationTypeName = node ? (0, type_merging_1.getNamedTypeForChild)(`schema.${operationType}`, node.type) : defaultTypeName;
            if (operationTypeName !== defaultTypeName && (this.parents.has(defaultTypeName) || this.extensions.has(defaultTypeName))) {
              this.errors.push((0, errors_1.invalidRootTypeDefinitionError)(operationType, operationTypeName, defaultTypeName));
              continue;
            }
            const object = this.parents.get(operationTypeName);
            const extension = this.extensions.get(operationTypeName);
            if (node) {
              if (!object && !extension) {
                this.errors.push((0, errors_1.undefinedTypeError)(operationTypeName));
                continue;
              }
              this.operationTypeNames.set(operationTypeName, operationType);
            }
            if (!object && !extension) {
              continue;
            }
            const rootNode = configurationDataMap.get(operationTypeName);
            if (rootNode) {
              rootNode.isRootNode = true;
              rootNode.typeName = defaultTypeName;
            }
            const containers = [object, extension];
            for (const container of containers) {
              if (!container) {
                continue;
              }
              if (container.kind !== graphql_1.Kind.OBJECT_TYPE_DEFINITION && container.kind !== graphql_1.Kind.OBJECT_TYPE_EXTENSION) {
                this.errors.push((0, errors_1.operationDefinitionError)(operationTypeName, operationType, container.kind));
                continue;
              }
              for (const fieldContainer of container.fields.values()) {
                const fieldName = fieldContainer.name;
                const fieldPath = `${operationTypeName}.${fieldName}`;
                const fieldTypeName = (0, type_merging_1.getNamedTypeForChild)(fieldPath, fieldContainer.node.type);
                if (!constants_1.BASE_SCALARS.has(fieldTypeName) && !this.parents.has(fieldTypeName) && !validExtensionOrphans.has(fieldTypeName)) {
                  this.errors.push((0, errors_1.undefinedTypeError)(fieldTypeName));
                }
              }
            }
          }
          for (const referencedTypeName of this.referencedTypeNames) {
            if (this.parents.has(referencedTypeName) || this.entityMap.has(referencedTypeName)) {
              continue;
            }
            const extension = this.extensions.get(referencedTypeName);
            if (!extension || extension.kind !== graphql_1.Kind.OBJECT_TYPE_EXTENSION) {
              this.errors.push((0, errors_1.undefinedTypeError)(referencedTypeName));
            }
          }
          if (this.errors.length > 0) {
            return { errors: this.errors };
          }
          const newAST = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions
          };
          return {
            normalizationResult: {
              configurationDataMap,
              isVersionTwo: this.isSubgraphVersionTwo,
              keyFieldsByParentTypeName: this.keyFieldsByParentTypeName,
              operationTypes: this.operationTypeNames,
              subgraphAST: newAST,
              subgraphString: (0, graphql_1.print)(newAST),
              schema: (0, buildASTSchema_1.buildASTSchema)(newAST, { assumeValid: true })
            }
          };
        }
      };
      exports2.NormalizationFactory = NormalizationFactory;
    }
  });

  // ../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js
  function o() {
    o.init.call(this);
  }
  function u(e2) {
    if ("function" != typeof e2)
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
  }
  function f(e2) {
    return void 0 === e2._maxListeners ? o.defaultMaxListeners : e2._maxListeners;
  }
  function v(e2, t2, n2, r2) {
    var i2, o2, s2, v2;
    if (u(n2), void 0 === (o2 = e2._events) ? (o2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== o2.newListener && (e2.emit("newListener", t2, n2.listener ? n2.listener : n2), o2 = e2._events), s2 = o2[t2]), void 0 === s2)
      s2 = o2[t2] = n2, ++e2._eventsCount;
    else if ("function" == typeof s2 ? s2 = o2[t2] = r2 ? [n2, s2] : [s2, n2] : r2 ? s2.unshift(n2) : s2.push(n2), (i2 = f(e2)) > 0 && s2.length > i2 && !s2.warned) {
      s2.warned = true;
      var a2 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a2.name = "MaxListenersExceededWarning", a2.emitter = e2, a2.type = t2, a2.count = s2.length, v2 = a2, console && console.warn && console.warn(v2);
    }
    return e2;
  }
  function a() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function l(e2, t2, n2) {
    var r2 = { fired: false, wrapFn: void 0, target: e2, type: t2, listener: n2 }, i2 = a.bind(r2);
    return i2.listener = n2, r2.wrapFn = i2, i2;
  }
  function h(e2, t2, n2) {
    var r2 = e2._events;
    if (void 0 === r2)
      return [];
    var i2 = r2[t2];
    return void 0 === i2 ? [] : "function" == typeof i2 ? n2 ? [i2.listener || i2] : [i2] : n2 ? function(e3) {
      for (var t3 = new Array(e3.length), n3 = 0; n3 < t3.length; ++n3)
        t3[n3] = e3[n3].listener || e3[n3];
      return t3;
    }(i2) : c(i2, i2.length);
  }
  function p(e2) {
    var t2 = this._events;
    if (void 0 !== t2) {
      var n2 = t2[e2];
      if ("function" == typeof n2)
        return 1;
      if (void 0 !== n2)
        return n2.length;
    }
    return 0;
  }
  function c(e2, t2) {
    for (var n2 = new Array(t2), r2 = 0; r2 < t2; ++r2)
      n2[r2] = e2[r2];
    return n2;
  }
  var e, t, n, r, i, s, y;
  var init_chunk_4bd36a8f = __esm({
    "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      n = "object" == typeof Reflect ? Reflect : null;
      r = n && "function" == typeof n.apply ? n.apply : function(e2, t2, n2) {
        return Function.prototype.apply.call(e2, t2, n2);
      };
      t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
        return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
      } : function(e2) {
        return Object.getOwnPropertyNames(e2);
      };
      i = Number.isNaN || function(e2) {
        return e2 != e2;
      };
      e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
      s = 10;
      Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
        return s;
      }, set: function(e2) {
        if ("number" != typeof e2 || e2 < 0 || i(e2))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
        s = e2;
      } }), o.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, o.prototype.setMaxListeners = function(e2) {
        if ("number" != typeof e2 || e2 < 0 || i(e2))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
        return this._maxListeners = e2, this;
      }, o.prototype.getMaxListeners = function() {
        return f(this);
      }, o.prototype.emit = function(e2) {
        for (var t2 = [], n2 = 1; n2 < arguments.length; n2++)
          t2.push(arguments[n2]);
        var i2 = "error" === e2, o2 = this._events;
        if (void 0 !== o2)
          i2 = i2 && void 0 === o2.error;
        else if (!i2)
          return false;
        if (i2) {
          var s2;
          if (t2.length > 0 && (s2 = t2[0]), s2 instanceof Error)
            throw s2;
          var u2 = new Error("Unhandled error." + (s2 ? " (" + s2.message + ")" : ""));
          throw u2.context = s2, u2;
        }
        var f2 = o2[e2];
        if (void 0 === f2)
          return false;
        if ("function" == typeof f2)
          r(f2, this, t2);
        else {
          var v2 = f2.length, a2 = c(f2, v2);
          for (n2 = 0; n2 < v2; ++n2)
            r(a2[n2], this, t2);
        }
        return true;
      }, o.prototype.addListener = function(e2, t2) {
        return v(this, e2, t2, false);
      }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e2, t2) {
        return v(this, e2, t2, true);
      }, o.prototype.once = function(e2, t2) {
        return u(t2), this.on(e2, l(this, e2, t2)), this;
      }, o.prototype.prependOnceListener = function(e2, t2) {
        return u(t2), this.prependListener(e2, l(this, e2, t2)), this;
      }, o.prototype.removeListener = function(e2, t2) {
        var n2, r2, i2, o2, s2;
        if (u(t2), void 0 === (r2 = this._events))
          return this;
        if (void 0 === (n2 = r2[e2]))
          return this;
        if (n2 === t2 || n2.listener === t2)
          0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r2[e2], r2.removeListener && this.emit("removeListener", e2, n2.listener || t2));
        else if ("function" != typeof n2) {
          for (i2 = -1, o2 = n2.length - 1; o2 >= 0; o2--)
            if (n2[o2] === t2 || n2[o2].listener === t2) {
              s2 = n2[o2].listener, i2 = o2;
              break;
            }
          if (i2 < 0)
            return this;
          0 === i2 ? n2.shift() : !function(e3, t3) {
            for (; t3 + 1 < e3.length; t3++)
              e3[t3] = e3[t3 + 1];
            e3.pop();
          }(n2, i2), 1 === n2.length && (r2[e2] = n2[0]), void 0 !== r2.removeListener && this.emit("removeListener", e2, s2 || t2);
        }
        return this;
      }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e2) {
        var t2, n2, r2;
        if (void 0 === (n2 = this._events))
          return this;
        if (void 0 === n2.removeListener)
          return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n2[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n2[e2]), this;
        if (0 === arguments.length) {
          var i2, o2 = Object.keys(n2);
          for (r2 = 0; r2 < o2.length; ++r2)
            "removeListener" !== (i2 = o2[r2]) && this.removeAllListeners(i2);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (t2 = n2[e2]))
          this.removeListener(e2, t2);
        else if (void 0 !== t2)
          for (r2 = t2.length - 1; r2 >= 0; r2--)
            this.removeListener(e2, t2[r2]);
        return this;
      }, o.prototype.listeners = function(e2) {
        return h(this, e2, true);
      }, o.prototype.rawListeners = function(e2) {
        return h(this, e2, false);
      }, o.listenerCount = function(e2, t2) {
        return "function" == typeof e2.listenerCount ? e2.listenerCount(t2) : p.call(e2, t2);
      }, o.prototype.listenerCount = p, o.prototype.eventNames = function() {
        return this._eventsCount > 0 ? t(this._events) : [];
      };
      y = e;
      y.EventEmitter;
      y.defaultMaxListeners;
      y.init;
      y.listenerCount;
      y.EventEmitter;
      y.defaultMaxListeners;
      y.init;
      y.listenerCount;
    }
  });

  // ../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/events.js
  var EventEmitter, defaultMaxListeners, init, listenerCount, on2, once2;
  var init_events = __esm({
    "../../node_modules/.pnpm/@jspm+core@2.0.1/node_modules/@jspm/core/nodelibs/browser/events.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_4bd36a8f();
      init_chunk_4bd36a8f();
      y.once = function(emitter, event) {
        return new Promise((resolve, reject) => {
          function eventListener(...args) {
            if (errorListener !== void 0) {
              emitter.removeListener("error", errorListener);
            }
            resolve(args);
          }
          let errorListener;
          if (event !== "error") {
            errorListener = (err) => {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          emitter.once(event, eventListener);
        });
      };
      y.on = function(emitter, event) {
        const unconsumedEventValues = [];
        const unconsumedPromises = [];
        let error = null;
        let finished = false;
        const iterator = {
          next() {
            return __async(this, null, function* () {
              const value = unconsumedEventValues.shift();
              if (value) {
                return createIterResult(value, false);
              }
              if (error) {
                const p2 = Promise.reject(error);
                error = null;
                return p2;
              }
              if (finished) {
                return createIterResult(void 0, true);
              }
              return new Promise((resolve, reject) => unconsumedPromises.push({ resolve, reject }));
            });
          },
          return() {
            return __async(this, null, function* () {
              emitter.removeListener(event, eventHandler);
              emitter.removeListener("error", errorHandler);
              finished = true;
              for (const promise of unconsumedPromises) {
                promise.resolve(createIterResult(void 0, true));
              }
              return createIterResult(void 0, true);
            });
          },
          throw(err) {
            error = err;
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
        emitter.on(event, eventHandler);
        emitter.on("error", errorHandler);
        return iterator;
        function eventHandler(...args) {
          const promise = unconsumedPromises.shift();
          if (promise) {
            promise.resolve(createIterResult(args, false));
          } else {
            unconsumedEventValues.push(args);
          }
        }
        function errorHandler(err) {
          finished = true;
          const toError2 = unconsumedPromises.shift();
          if (toError2) {
            toError2.reject(err);
          } else {
            error = err;
          }
          iterator.return();
        }
      };
      ({
        EventEmitter,
        defaultMaxListeners,
        init,
        listenerCount,
        on: on2,
        once: once2
      } = y);
    }
  });

  // ../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/iterator.js
  var require_iterator = __commonJS({
    "../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/iterator.js"(exports2, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      function Iterator2(next) {
        if (typeof next !== "function")
          throw new Error("obliterator/iterator: expecting a function!");
        this.next = next;
      }
      if (typeof Symbol !== "undefined")
        Iterator2.prototype[Symbol.iterator] = function() {
          return this;
        };
      Iterator2.of = function() {
        var args = arguments, l2 = args.length, i2 = 0;
        return new Iterator2(function() {
          if (i2 >= l2)
            return { done: true };
          return { done: false, value: args[i2++] };
        });
      };
      Iterator2.empty = function() {
        var iterator = new Iterator2(function() {
          return { done: true };
        });
        return iterator;
      };
      Iterator2.fromSequence = function(sequence) {
        var i2 = 0, l2 = sequence.length;
        return new Iterator2(function() {
          if (i2 >= l2)
            return { done: true };
          return { done: false, value: sequence[i2++] };
        });
      };
      Iterator2.is = function(value) {
        if (value instanceof Iterator2)
          return true;
        return typeof value === "object" && value !== null && typeof value.next === "function";
      };
      module.exports = Iterator2;
    }
  });

  // ../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/support.js
  var require_support = __commonJS({
    "../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/support.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      exports2.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== "undefined";
      exports2.SYMBOL_SUPPORT = typeof Symbol !== "undefined";
    }
  });

  // ../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/iter.js
  var require_iter = __commonJS({
    "../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/iter.js"(exports2, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var Iterator2 = require_iterator();
      var support = require_support();
      var ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;
      var SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;
      function iterOrNull(target) {
        if (typeof target === "string" || Array.isArray(target) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(target))
          return Iterator2.fromSequence(target);
        if (typeof target !== "object" || target === null)
          return null;
        if (SYMBOL_SUPPORT && typeof target[Symbol.iterator] === "function")
          return target[Symbol.iterator]();
        if (typeof target.next === "function")
          return target;
        return null;
      }
      module.exports = function iter(target) {
        var iterator = iterOrNull(target);
        if (!iterator)
          throw new Error(
            "obliterator: target is not iterable nor a valid iterator."
          );
        return iterator;
      };
    }
  });

  // ../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/take.js
  var require_take = __commonJS({
    "../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/take.js"(exports2, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var iter = require_iter();
      module.exports = function take2(iterable, n2) {
        var l2 = arguments.length > 1 ? n2 : Infinity, array = l2 !== Infinity ? new Array(l2) : [], step, i2 = 0;
        var iterator = iter(iterable);
        while (true) {
          if (i2 === l2)
            return array;
          step = iterator.next();
          if (step.done) {
            if (i2 !== n2)
              array.length = i2;
            return array;
          }
          array[i2++] = step.value;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/chain.js
  var require_chain = __commonJS({
    "../../node_modules/.pnpm/obliterator@2.0.4/node_modules/obliterator/chain.js"(exports2, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var Iterator2 = require_iterator();
      var iter = require_iter();
      module.exports = function chain2() {
        var iterables = arguments;
        var current = null;
        var i2 = -1;
        return new Iterator2(function next() {
          var step = null;
          do {
            if (current === null) {
              i2++;
              if (i2 >= iterables.length)
                return { done: true };
              current = iter(iterables[i2]);
            }
            step = current.next();
            if (step.done === true) {
              current = null;
              continue;
            }
            break;
          } while (true);
          return step;
        });
      };
    }
  });

  // ../../node_modules/.pnpm/graphology@0.25.1_graphology-types@0.24.7/node_modules/graphology/dist/graphology.esm.js
  var graphology_esm_exports = {};
  __export(graphology_esm_exports, {
    DirectedGraph: () => DirectedGraph,
    Graph: () => Graph,
    InvalidArgumentsGraphError: () => InvalidArgumentsGraphError,
    MultiDirectedGraph: () => MultiDirectedGraph,
    MultiGraph: () => MultiGraph,
    MultiUndirectedGraph: () => MultiUndirectedGraph,
    NotFoundGraphError: () => NotFoundGraphError,
    UndirectedGraph: () => UndirectedGraph,
    UsageGraphError: () => UsageGraphError,
    default: () => Graph
  });
  function assignPolyfill() {
    const target = arguments[0];
    for (let i2 = 1, l2 = arguments.length; i2 < l2; i2++) {
      if (!arguments[i2])
        continue;
      for (const k in arguments[i2])
        target[k] = arguments[i2][k];
    }
    return target;
  }
  function getMatchingEdge(graph, source, target, type) {
    const sourceData = graph._nodes.get(source);
    let edge = null;
    if (!sourceData)
      return edge;
    if (type === "mixed") {
      edge = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target];
    } else if (type === "directed") {
      edge = sourceData.out && sourceData.out[target];
    } else {
      edge = sourceData.undirected && sourceData.undirected[target];
    }
    return edge;
  }
  function isPlainObject(value) {
    return typeof value === "object" && value !== null && value.constructor === Object;
  }
  function isEmpty(o2) {
    let k;
    for (k in o2)
      return false;
    return true;
  }
  function privateProperty(target, name2, value) {
    Object.defineProperty(target, name2, {
      enumerable: false,
      configurable: false,
      writable: true,
      value
    });
  }
  function readOnlyProperty(target, name2, value) {
    const descriptor = {
      enumerable: true,
      configurable: true
    };
    if (typeof value === "function") {
      descriptor.get = value;
    } else {
      descriptor.value = value;
      descriptor.writable = false;
    }
    Object.defineProperty(target, name2, descriptor);
  }
  function validateHints(hints) {
    if (!isPlainObject(hints))
      return false;
    if (hints.attributes && !Array.isArray(hints.attributes))
      return false;
    return true;
  }
  function incrementalIdStartingFromRandomByte() {
    let i2 = Math.floor(Math.random() * 256) & 255;
    return () => {
      return i2++;
    };
  }
  function MixedNodeData(key, attributes) {
    this.key = key;
    this.attributes = attributes;
    this.clear();
  }
  function DirectedNodeData(key, attributes) {
    this.key = key;
    this.attributes = attributes;
    this.clear();
  }
  function UndirectedNodeData(key, attributes) {
    this.key = key;
    this.attributes = attributes;
    this.clear();
  }
  function EdgeData(undirected, key, source, target, attributes) {
    this.key = key;
    this.attributes = attributes;
    this.undirected = undirected;
    this.source = source;
    this.target = target;
  }
  function findRelevantNodeData(graph, method, mode, nodeOrEdge, nameOrEdge, add1, add2) {
    let nodeData, edgeData, arg1, arg2;
    nodeOrEdge = "" + nodeOrEdge;
    if (mode === NODE) {
      nodeData = graph._nodes.get(nodeOrEdge);
      if (!nodeData)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${nodeOrEdge}" node in the graph.`
        );
      arg1 = nameOrEdge;
      arg2 = add1;
    } else if (mode === OPPOSITE) {
      nameOrEdge = "" + nameOrEdge;
      edgeData = graph._edges.get(nameOrEdge);
      if (!edgeData)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${nameOrEdge}" edge in the graph.`
        );
      const source = edgeData.source.key;
      const target = edgeData.target.key;
      if (nodeOrEdge === source) {
        nodeData = edgeData.target;
      } else if (nodeOrEdge === target) {
        nodeData = edgeData.source;
      } else {
        throw new NotFoundGraphError(
          `Graph.${method}: the "${nodeOrEdge}" node is not attached to the "${nameOrEdge}" edge (${source}, ${target}).`
        );
      }
      arg1 = add1;
      arg2 = add2;
    } else {
      edgeData = graph._edges.get(nodeOrEdge);
      if (!edgeData)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${nodeOrEdge}" edge in the graph.`
        );
      if (mode === SOURCE) {
        nodeData = edgeData.source;
      } else {
        nodeData = edgeData.target;
      }
      arg1 = nameOrEdge;
      arg2 = add1;
    }
    return [nodeData, arg1, arg2];
  }
  function attachNodeAttributeGetter(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, name2] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      return data.attributes[name2];
    };
  }
  function attachNodeAttributesGetter(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge) {
      const [data] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge
      );
      return data.attributes;
    };
  }
  function attachNodeAttributeChecker(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, name2] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      return data.attributes.hasOwnProperty(name2);
    };
  }
  function attachNodeAttributeSetter(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1, add2) {
      const [data, name2, value] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1,
        add2
      );
      data.attributes[name2] = value;
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "set",
        attributes: data.attributes,
        name: name2
      });
      return this;
    };
  }
  function attachNodeAttributeUpdater(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1, add2) {
      const [data, name2, updater] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1,
        add2
      );
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: updater should be a function.`
        );
      const attributes = data.attributes;
      const value = updater(attributes[name2]);
      attributes[name2] = value;
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "set",
        attributes: data.attributes,
        name: name2
      });
      return this;
    };
  }
  function attachNodeAttributeRemover(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, name2] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      delete data.attributes[name2];
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "remove",
        attributes: data.attributes,
        name: name2
      });
      return this;
    };
  }
  function attachNodeAttributesReplacer(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, attributes] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      if (!isPlainObject(attributes))
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided attributes are not a plain object.`
        );
      data.attributes = attributes;
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "replace",
        attributes: data.attributes
      });
      return this;
    };
  }
  function attachNodeAttributesMerger(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, attributes] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      if (!isPlainObject(attributes))
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided attributes are not a plain object.`
        );
      assign(data.attributes, attributes);
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "merge",
        attributes: data.attributes,
        data: attributes
      });
      return this;
    };
  }
  function attachNodeAttributesUpdater(Class, method, mode) {
    Class.prototype[method] = function(nodeOrEdge, nameOrEdge, add1) {
      const [data, updater] = findRelevantNodeData(
        this,
        method,
        mode,
        nodeOrEdge,
        nameOrEdge,
        add1
      );
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided updater is not a function.`
        );
      data.attributes = updater(data.attributes);
      this.emit("nodeAttributesUpdated", {
        key: data.key,
        type: "update",
        attributes: data.attributes
      });
      return this;
    };
  }
  function attachNodeAttributesMethods(Graph2) {
    NODE_ATTRIBUTES_METHODS.forEach(function({ name: name2, attacher }) {
      attacher(Graph2, name2("Node"), NODE);
      attacher(Graph2, name2("Source"), SOURCE);
      attacher(Graph2, name2("Target"), TARGET);
      attacher(Graph2, name2("Opposite"), OPPOSITE);
    });
  }
  function attachEdgeAttributeGetter(Class, method, type) {
    Class.prototype[method] = function(element, name2) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element;
        const target = "" + name2;
        name2 = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      return data.attributes[name2];
    };
  }
  function attachEdgeAttributesGetter(Class, method, type) {
    Class.prototype[method] = function(element) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 1) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element, target = "" + arguments[1];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      return data.attributes;
    };
  }
  function attachEdgeAttributeChecker(Class, method, type) {
    Class.prototype[method] = function(element, name2) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element;
        const target = "" + name2;
        name2 = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      return data.attributes.hasOwnProperty(name2);
    };
  }
  function attachEdgeAttributeSetter(Class, method, type) {
    Class.prototype[method] = function(element, name2, value) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 3) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element;
        const target = "" + name2;
        name2 = arguments[2];
        value = arguments[3];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      data.attributes[name2] = value;
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "set",
        attributes: data.attributes,
        name: name2
      });
      return this;
    };
  }
  function attachEdgeAttributeUpdater(Class, method, type) {
    Class.prototype[method] = function(element, name2, updater) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 3) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element;
        const target = "" + name2;
        name2 = arguments[2];
        updater = arguments[3];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: updater should be a function.`
        );
      data.attributes[name2] = updater(data.attributes[name2]);
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "set",
        attributes: data.attributes,
        name: name2
      });
      return this;
    };
  }
  function attachEdgeAttributeRemover(Class, method, type) {
    Class.prototype[method] = function(element, name2) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element;
        const target = "" + name2;
        name2 = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      delete data.attributes[name2];
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "remove",
        attributes: data.attributes,
        name: name2
      });
      return this;
    };
  }
  function attachEdgeAttributesReplacer(Class, method, type) {
    Class.prototype[method] = function(element, attributes) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element, target = "" + attributes;
        attributes = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      if (!isPlainObject(attributes))
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided attributes are not a plain object.`
        );
      data.attributes = attributes;
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "replace",
        attributes: data.attributes
      });
      return this;
    };
  }
  function attachEdgeAttributesMerger(Class, method, type) {
    Class.prototype[method] = function(element, attributes) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element, target = "" + attributes;
        attributes = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      if (!isPlainObject(attributes))
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided attributes are not a plain object.`
        );
      assign(data.attributes, attributes);
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "merge",
        attributes: data.attributes,
        data: attributes
      });
      return this;
    };
  }
  function attachEdgeAttributesUpdater(Class, method, type) {
    Class.prototype[method] = function(element, updater) {
      let data;
      if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
        throw new UsageGraphError(
          `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
        );
      if (arguments.length > 2) {
        if (this.multi)
          throw new UsageGraphError(
            `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
          );
        const source = "" + element, target = "" + updater;
        updater = arguments[2];
        data = getMatchingEdge(this, source, target, type);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
          );
      } else {
        if (type !== "mixed")
          throw new UsageGraphError(
            `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
          );
        element = "" + element;
        data = this._edges.get(element);
        if (!data)
          throw new NotFoundGraphError(
            `Graph.${method}: could not find the "${element}" edge in the graph.`
          );
      }
      if (typeof updater !== "function")
        throw new InvalidArgumentsGraphError(
          `Graph.${method}: provided updater is not a function.`
        );
      data.attributes = updater(data.attributes);
      this.emit("edgeAttributesUpdated", {
        key: data.key,
        type: "update",
        attributes: data.attributes
      });
      return this;
    };
  }
  function attachEdgeAttributesMethods(Graph2) {
    EDGE_ATTRIBUTES_METHODS.forEach(function({ name: name2, attacher }) {
      attacher(Graph2, name2("Edge"), "mixed");
      attacher(Graph2, name2("DirectedEdge"), "directed");
      attacher(Graph2, name2("UndirectedEdge"), "undirected");
    });
  }
  function forEachSimple(breakable, object, callback, avoid) {
    let shouldBreak = false;
    for (const k in object) {
      if (k === avoid)
        continue;
      const edgeData = object[k];
      shouldBreak = callback(
        edgeData.key,
        edgeData.attributes,
        edgeData.source.key,
        edgeData.target.key,
        edgeData.source.attributes,
        edgeData.target.attributes,
        edgeData.undirected
      );
      if (breakable && shouldBreak)
        return edgeData.key;
    }
    return;
  }
  function forEachMulti(breakable, object, callback, avoid) {
    let edgeData, source, target;
    let shouldBreak = false;
    for (const k in object) {
      if (k === avoid)
        continue;
      edgeData = object[k];
      do {
        source = edgeData.source;
        target = edgeData.target;
        shouldBreak = callback(
          edgeData.key,
          edgeData.attributes,
          source.key,
          target.key,
          source.attributes,
          target.attributes,
          edgeData.undirected
        );
        if (breakable && shouldBreak)
          return edgeData.key;
        edgeData = edgeData.next;
      } while (edgeData !== void 0);
    }
    return;
  }
  function createIterator(object, avoid) {
    const keys = Object.keys(object);
    const l2 = keys.length;
    let edgeData;
    let i2 = 0;
    return new import_iterator.default(function next() {
      do {
        if (!edgeData) {
          if (i2 >= l2)
            return { done: true };
          const k = keys[i2++];
          if (k === avoid) {
            edgeData = void 0;
            continue;
          }
          edgeData = object[k];
        } else {
          edgeData = edgeData.next;
        }
      } while (!edgeData);
      return {
        done: false,
        value: {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        }
      };
    });
  }
  function forEachForKeySimple(breakable, object, k, callback) {
    const edgeData = object[k];
    if (!edgeData)
      return;
    const sourceData = edgeData.source;
    const targetData = edgeData.target;
    if (callback(
      edgeData.key,
      edgeData.attributes,
      sourceData.key,
      targetData.key,
      sourceData.attributes,
      targetData.attributes,
      edgeData.undirected
    ) && breakable)
      return edgeData.key;
  }
  function forEachForKeyMulti(breakable, object, k, callback) {
    let edgeData = object[k];
    if (!edgeData)
      return;
    let shouldBreak = false;
    do {
      shouldBreak = callback(
        edgeData.key,
        edgeData.attributes,
        edgeData.source.key,
        edgeData.target.key,
        edgeData.source.attributes,
        edgeData.target.attributes,
        edgeData.undirected
      );
      if (breakable && shouldBreak)
        return edgeData.key;
      edgeData = edgeData.next;
    } while (edgeData !== void 0);
    return;
  }
  function createIteratorForKey(object, k) {
    let edgeData = object[k];
    if (edgeData.next !== void 0) {
      return new import_iterator.default(function() {
        if (!edgeData)
          return { done: true };
        const value = {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        };
        edgeData = edgeData.next;
        return {
          done: false,
          value
        };
      });
    }
    return import_iterator.default.of({
      edge: edgeData.key,
      attributes: edgeData.attributes,
      source: edgeData.source.key,
      target: edgeData.target.key,
      sourceAttributes: edgeData.source.attributes,
      targetAttributes: edgeData.target.attributes,
      undirected: edgeData.undirected
    });
  }
  function createEdgeArray(graph, type) {
    if (graph.size === 0)
      return [];
    if (type === "mixed" || type === graph.type) {
      if (typeof Array.from === "function")
        return Array.from(graph._edges.keys());
      return (0, import_take.default)(graph._edges.keys(), graph._edges.size);
    }
    const size = type === "undirected" ? graph.undirectedSize : graph.directedSize;
    const list = new Array(size), mask = type === "undirected";
    const iterator = graph._edges.values();
    let i2 = 0;
    let step, data;
    while (step = iterator.next(), step.done !== true) {
      data = step.value;
      if (data.undirected === mask)
        list[i2++] = data.key;
    }
    return list;
  }
  function forEachEdge(breakable, graph, type, callback) {
    if (graph.size === 0)
      return;
    const shouldFilter = type !== "mixed" && type !== graph.type;
    const mask = type === "undirected";
    let step, data;
    let shouldBreak = false;
    const iterator = graph._edges.values();
    while (step = iterator.next(), step.done !== true) {
      data = step.value;
      if (shouldFilter && data.undirected !== mask)
        continue;
      const { key, attributes, source, target } = data;
      shouldBreak = callback(
        key,
        attributes,
        source.key,
        target.key,
        source.attributes,
        target.attributes,
        data.undirected
      );
      if (breakable && shouldBreak)
        return key;
    }
    return;
  }
  function createEdgeIterator(graph, type) {
    if (graph.size === 0)
      return import_iterator.default.empty();
    const shouldFilter = type !== "mixed" && type !== graph.type;
    const mask = type === "undirected";
    const iterator = graph._edges.values();
    return new import_iterator.default(function next() {
      let step, data;
      while (true) {
        step = iterator.next();
        if (step.done)
          return step;
        data = step.value;
        if (shouldFilter && data.undirected !== mask)
          continue;
        break;
      }
      const value = {
        edge: data.key,
        attributes: data.attributes,
        source: data.source.key,
        target: data.target.key,
        sourceAttributes: data.source.attributes,
        targetAttributes: data.target.attributes,
        undirected: data.undirected
      };
      return { value, done: false };
    });
  }
  function forEachEdgeForNode(breakable, multi, type, direction, nodeData, callback) {
    const fn = multi ? forEachMulti : forEachSimple;
    let found;
    if (type !== "undirected") {
      if (direction !== "out") {
        found = fn(breakable, nodeData.in, callback);
        if (breakable && found)
          return found;
      }
      if (direction !== "in") {
        found = fn(
          breakable,
          nodeData.out,
          callback,
          !direction ? nodeData.key : void 0
        );
        if (breakable && found)
          return found;
      }
    }
    if (type !== "directed") {
      found = fn(breakable, nodeData.undirected, callback);
      if (breakable && found)
        return found;
    }
    return;
  }
  function createEdgeArrayForNode(multi, type, direction, nodeData) {
    const edges = [];
    forEachEdgeForNode(false, multi, type, direction, nodeData, function(key) {
      edges.push(key);
    });
    return edges;
  }
  function createEdgeIteratorForNode(type, direction, nodeData) {
    let iterator = import_iterator.default.empty();
    if (type !== "undirected") {
      if (direction !== "out" && typeof nodeData.in !== "undefined")
        iterator = (0, import_chain.default)(iterator, createIterator(nodeData.in));
      if (direction !== "in" && typeof nodeData.out !== "undefined")
        iterator = (0, import_chain.default)(
          iterator,
          createIterator(nodeData.out, !direction ? nodeData.key : void 0)
        );
    }
    if (type !== "directed" && typeof nodeData.undirected !== "undefined") {
      iterator = (0, import_chain.default)(iterator, createIterator(nodeData.undirected));
    }
    return iterator;
  }
  function forEachEdgeForPath(breakable, type, multi, direction, sourceData, target, callback) {
    const fn = multi ? forEachForKeyMulti : forEachForKeySimple;
    let found;
    if (type !== "undirected") {
      if (typeof sourceData.in !== "undefined" && direction !== "out") {
        found = fn(breakable, sourceData.in, target, callback);
        if (breakable && found)
          return found;
      }
      if (typeof sourceData.out !== "undefined" && direction !== "in" && (direction || sourceData.key !== target)) {
        found = fn(breakable, sourceData.out, target, callback);
        if (breakable && found)
          return found;
      }
    }
    if (type !== "directed") {
      if (typeof sourceData.undirected !== "undefined") {
        found = fn(breakable, sourceData.undirected, target, callback);
        if (breakable && found)
          return found;
      }
    }
    return;
  }
  function createEdgeArrayForPath(type, multi, direction, sourceData, target) {
    const edges = [];
    forEachEdgeForPath(
      false,
      type,
      multi,
      direction,
      sourceData,
      target,
      function(key) {
        edges.push(key);
      }
    );
    return edges;
  }
  function createEdgeIteratorForPath(type, direction, sourceData, target) {
    let iterator = import_iterator.default.empty();
    if (type !== "undirected") {
      if (typeof sourceData.in !== "undefined" && direction !== "out" && target in sourceData.in)
        iterator = (0, import_chain.default)(iterator, createIteratorForKey(sourceData.in, target));
      if (typeof sourceData.out !== "undefined" && direction !== "in" && target in sourceData.out && (direction || sourceData.key !== target))
        iterator = (0, import_chain.default)(iterator, createIteratorForKey(sourceData.out, target));
    }
    if (type !== "directed") {
      if (typeof sourceData.undirected !== "undefined" && target in sourceData.undirected)
        iterator = (0, import_chain.default)(
          iterator,
          createIteratorForKey(sourceData.undirected, target)
        );
    }
    return iterator;
  }
  function attachEdgeArrayCreator(Class, description) {
    const { name: name2, type, direction } = description;
    Class.prototype[name2] = function(source, target) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return [];
      if (!arguments.length)
        return createEdgeArray(this, type);
      if (arguments.length === 1) {
        source = "" + source;
        const nodeData = this._nodes.get(source);
        if (typeof nodeData === "undefined")
          throw new NotFoundGraphError(
            `Graph.${name2}: could not find the "${source}" node in the graph.`
          );
        return createEdgeArrayForNode(
          this.multi,
          type === "mixed" ? this.type : type,
          direction,
          nodeData
        );
      }
      if (arguments.length === 2) {
        source = "" + source;
        target = "" + target;
        const sourceData = this._nodes.get(source);
        if (!sourceData)
          throw new NotFoundGraphError(
            `Graph.${name2}:  could not find the "${source}" source node in the graph.`
          );
        if (!this._nodes.has(target))
          throw new NotFoundGraphError(
            `Graph.${name2}:  could not find the "${target}" target node in the graph.`
          );
        return createEdgeArrayForPath(
          type,
          this.multi,
          direction,
          sourceData,
          target
        );
      }
      throw new InvalidArgumentsGraphError(
        `Graph.${name2}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`
      );
    };
  }
  function attachForEachEdge(Class, description) {
    const { name: name2, type, direction } = description;
    const forEachName = "forEach" + name2[0].toUpperCase() + name2.slice(1, -1);
    Class.prototype[forEachName] = function(source, target, callback) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return;
      if (arguments.length === 1) {
        callback = source;
        return forEachEdge(false, this, type, callback);
      }
      if (arguments.length === 2) {
        source = "" + source;
        callback = target;
        const nodeData = this._nodes.get(source);
        if (typeof nodeData === "undefined")
          throw new NotFoundGraphError(
            `Graph.${forEachName}: could not find the "${source}" node in the graph.`
          );
        return forEachEdgeForNode(
          false,
          this.multi,
          type === "mixed" ? this.type : type,
          direction,
          nodeData,
          callback
        );
      }
      if (arguments.length === 3) {
        source = "" + source;
        target = "" + target;
        const sourceData = this._nodes.get(source);
        if (!sourceData)
          throw new NotFoundGraphError(
            `Graph.${forEachName}:  could not find the "${source}" source node in the graph.`
          );
        if (!this._nodes.has(target))
          throw new NotFoundGraphError(
            `Graph.${forEachName}:  could not find the "${target}" target node in the graph.`
          );
        return forEachEdgeForPath(
          false,
          type,
          this.multi,
          direction,
          sourceData,
          target,
          callback
        );
      }
      throw new InvalidArgumentsGraphError(
        `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`
      );
    };
    const mapName = "map" + name2[0].toUpperCase() + name2.slice(1);
    Class.prototype[mapName] = function() {
      const args = Array.prototype.slice.call(arguments);
      const callback = args.pop();
      let result;
      if (args.length === 0) {
        let length = 0;
        if (type !== "directed")
          length += this.undirectedSize;
        if (type !== "undirected")
          length += this.directedSize;
        result = new Array(length);
        let i2 = 0;
        args.push((e2, ea, s2, t2, sa, ta, u2) => {
          result[i2++] = callback(e2, ea, s2, t2, sa, ta, u2);
        });
      } else {
        result = [];
        args.push((e2, ea, s2, t2, sa, ta, u2) => {
          result.push(callback(e2, ea, s2, t2, sa, ta, u2));
        });
      }
      this[forEachName].apply(this, args);
      return result;
    };
    const filterName = "filter" + name2[0].toUpperCase() + name2.slice(1);
    Class.prototype[filterName] = function() {
      const args = Array.prototype.slice.call(arguments);
      const callback = args.pop();
      const result = [];
      args.push((e2, ea, s2, t2, sa, ta, u2) => {
        if (callback(e2, ea, s2, t2, sa, ta, u2))
          result.push(e2);
      });
      this[forEachName].apply(this, args);
      return result;
    };
    const reduceName = "reduce" + name2[0].toUpperCase() + name2.slice(1);
    Class.prototype[reduceName] = function() {
      let args = Array.prototype.slice.call(arguments);
      if (args.length < 2 || args.length > 4) {
        throw new InvalidArgumentsGraphError(
          `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`
        );
      }
      if (typeof args[args.length - 1] === "function" && typeof args[args.length - 2] !== "function") {
        throw new InvalidArgumentsGraphError(
          `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`
        );
      }
      let callback;
      let initialValue;
      if (args.length === 2) {
        callback = args[0];
        initialValue = args[1];
        args = [];
      } else if (args.length === 3) {
        callback = args[1];
        initialValue = args[2];
        args = [args[0]];
      } else if (args.length === 4) {
        callback = args[2];
        initialValue = args[3];
        args = [args[0], args[1]];
      }
      let accumulator = initialValue;
      args.push((e2, ea, s2, t2, sa, ta, u2) => {
        accumulator = callback(accumulator, e2, ea, s2, t2, sa, ta, u2);
      });
      this[forEachName].apply(this, args);
      return accumulator;
    };
  }
  function attachFindEdge(Class, description) {
    const { name: name2, type, direction } = description;
    const findEdgeName = "find" + name2[0].toUpperCase() + name2.slice(1, -1);
    Class.prototype[findEdgeName] = function(source, target, callback) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return false;
      if (arguments.length === 1) {
        callback = source;
        return forEachEdge(true, this, type, callback);
      }
      if (arguments.length === 2) {
        source = "" + source;
        callback = target;
        const nodeData = this._nodes.get(source);
        if (typeof nodeData === "undefined")
          throw new NotFoundGraphError(
            `Graph.${findEdgeName}: could not find the "${source}" node in the graph.`
          );
        return forEachEdgeForNode(
          true,
          this.multi,
          type === "mixed" ? this.type : type,
          direction,
          nodeData,
          callback
        );
      }
      if (arguments.length === 3) {
        source = "" + source;
        target = "" + target;
        const sourceData = this._nodes.get(source);
        if (!sourceData)
          throw new NotFoundGraphError(
            `Graph.${findEdgeName}:  could not find the "${source}" source node in the graph.`
          );
        if (!this._nodes.has(target))
          throw new NotFoundGraphError(
            `Graph.${findEdgeName}:  could not find the "${target}" target node in the graph.`
          );
        return forEachEdgeForPath(
          true,
          type,
          this.multi,
          direction,
          sourceData,
          target,
          callback
        );
      }
      throw new InvalidArgumentsGraphError(
        `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`
      );
    };
    const someName = "some" + name2[0].toUpperCase() + name2.slice(1, -1);
    Class.prototype[someName] = function() {
      const args = Array.prototype.slice.call(arguments);
      const callback = args.pop();
      args.push((e2, ea, s2, t2, sa, ta, u2) => {
        return callback(e2, ea, s2, t2, sa, ta, u2);
      });
      const found = this[findEdgeName].apply(this, args);
      if (found)
        return true;
      return false;
    };
    const everyName = "every" + name2[0].toUpperCase() + name2.slice(1, -1);
    Class.prototype[everyName] = function() {
      const args = Array.prototype.slice.call(arguments);
      const callback = args.pop();
      args.push((e2, ea, s2, t2, sa, ta, u2) => {
        return !callback(e2, ea, s2, t2, sa, ta, u2);
      });
      const found = this[findEdgeName].apply(this, args);
      if (found)
        return false;
      return true;
    };
  }
  function attachEdgeIteratorCreator(Class, description) {
    const { name: originalName, type, direction } = description;
    const name2 = originalName.slice(0, -1) + "Entries";
    Class.prototype[name2] = function(source, target) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return import_iterator.default.empty();
      if (!arguments.length)
        return createEdgeIterator(this, type);
      if (arguments.length === 1) {
        source = "" + source;
        const sourceData = this._nodes.get(source);
        if (!sourceData)
          throw new NotFoundGraphError(
            `Graph.${name2}: could not find the "${source}" node in the graph.`
          );
        return createEdgeIteratorForNode(type, direction, sourceData);
      }
      if (arguments.length === 2) {
        source = "" + source;
        target = "" + target;
        const sourceData = this._nodes.get(source);
        if (!sourceData)
          throw new NotFoundGraphError(
            `Graph.${name2}:  could not find the "${source}" source node in the graph.`
          );
        if (!this._nodes.has(target))
          throw new NotFoundGraphError(
            `Graph.${name2}:  could not find the "${target}" target node in the graph.`
          );
        return createEdgeIteratorForPath(type, direction, sourceData, target);
      }
      throw new InvalidArgumentsGraphError(
        `Graph.${name2}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`
      );
    };
  }
  function attachEdgeIterationMethods(Graph2) {
    EDGES_ITERATION.forEach((description) => {
      attachEdgeArrayCreator(Graph2, description);
      attachForEachEdge(Graph2, description);
      attachFindEdge(Graph2, description);
      attachEdgeIteratorCreator(Graph2, description);
    });
  }
  function CompositeSetWrapper() {
    this.A = null;
    this.B = null;
  }
  function forEachInObjectOnce(breakable, visited, nodeData, object, callback) {
    for (const k in object) {
      const edgeData = object[k];
      const sourceData = edgeData.source;
      const targetData = edgeData.target;
      const neighborData = sourceData === nodeData ? targetData : sourceData;
      if (visited && visited.has(neighborData.key))
        continue;
      const shouldBreak = callback(neighborData.key, neighborData.attributes);
      if (breakable && shouldBreak)
        return neighborData.key;
    }
    return;
  }
  function forEachNeighbor(breakable, type, direction, nodeData, callback) {
    if (type !== "mixed") {
      if (type === "undirected")
        return forEachInObjectOnce(
          breakable,
          null,
          nodeData,
          nodeData.undirected,
          callback
        );
      if (typeof direction === "string")
        return forEachInObjectOnce(
          breakable,
          null,
          nodeData,
          nodeData[direction],
          callback
        );
    }
    const visited = new CompositeSetWrapper();
    let found;
    if (type !== "undirected") {
      if (direction !== "out") {
        found = forEachInObjectOnce(
          breakable,
          null,
          nodeData,
          nodeData.in,
          callback
        );
        if (breakable && found)
          return found;
        visited.wrap(nodeData.in);
      }
      if (direction !== "in") {
        found = forEachInObjectOnce(
          breakable,
          visited,
          nodeData,
          nodeData.out,
          callback
        );
        if (breakable && found)
          return found;
        visited.wrap(nodeData.out);
      }
    }
    if (type !== "directed") {
      found = forEachInObjectOnce(
        breakable,
        visited,
        nodeData,
        nodeData.undirected,
        callback
      );
      if (breakable && found)
        return found;
    }
    return;
  }
  function createNeighborArrayForNode(type, direction, nodeData) {
    if (type !== "mixed") {
      if (type === "undirected")
        return Object.keys(nodeData.undirected);
      if (typeof direction === "string")
        return Object.keys(nodeData[direction]);
    }
    const neighbors = [];
    forEachNeighbor(false, type, direction, nodeData, function(key) {
      neighbors.push(key);
    });
    return neighbors;
  }
  function createDedupedObjectIterator(visited, nodeData, object) {
    const keys = Object.keys(object);
    const l2 = keys.length;
    let i2 = 0;
    return new import_iterator.default(function next() {
      let neighborData = null;
      do {
        if (i2 >= l2) {
          if (visited)
            visited.wrap(object);
          return { done: true };
        }
        const edgeData = object[keys[i2++]];
        const sourceData = edgeData.source;
        const targetData = edgeData.target;
        neighborData = sourceData === nodeData ? targetData : sourceData;
        if (visited && visited.has(neighborData.key)) {
          neighborData = null;
          continue;
        }
      } while (neighborData === null);
      return {
        done: false,
        value: { neighbor: neighborData.key, attributes: neighborData.attributes }
      };
    });
  }
  function createNeighborIterator(type, direction, nodeData) {
    if (type !== "mixed") {
      if (type === "undirected")
        return createDedupedObjectIterator(null, nodeData, nodeData.undirected);
      if (typeof direction === "string")
        return createDedupedObjectIterator(null, nodeData, nodeData[direction]);
    }
    let iterator = import_iterator.default.empty();
    const visited = new CompositeSetWrapper();
    if (type !== "undirected") {
      if (direction !== "out") {
        iterator = (0, import_chain.default)(
          iterator,
          createDedupedObjectIterator(visited, nodeData, nodeData.in)
        );
      }
      if (direction !== "in") {
        iterator = (0, import_chain.default)(
          iterator,
          createDedupedObjectIterator(visited, nodeData, nodeData.out)
        );
      }
    }
    if (type !== "directed") {
      iterator = (0, import_chain.default)(
        iterator,
        createDedupedObjectIterator(visited, nodeData, nodeData.undirected)
      );
    }
    return iterator;
  }
  function attachNeighborArrayCreator(Class, description) {
    const { name: name2, type, direction } = description;
    Class.prototype[name2] = function(node) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return [];
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(
          `Graph.${name2}: could not find the "${node}" node in the graph.`
        );
      return createNeighborArrayForNode(
        type === "mixed" ? this.type : type,
        direction,
        nodeData
      );
    };
  }
  function attachForEachNeighbor(Class, description) {
    const { name: name2, type, direction } = description;
    const forEachName = "forEach" + name2[0].toUpperCase() + name2.slice(1, -1);
    Class.prototype[forEachName] = function(node, callback) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return;
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(
          `Graph.${forEachName}: could not find the "${node}" node in the graph.`
        );
      forEachNeighbor(
        false,
        type === "mixed" ? this.type : type,
        direction,
        nodeData,
        callback
      );
    };
    const mapName = "map" + name2[0].toUpperCase() + name2.slice(1);
    Class.prototype[mapName] = function(node, callback) {
      const result = [];
      this[forEachName](node, (n2, a2) => {
        result.push(callback(n2, a2));
      });
      return result;
    };
    const filterName = "filter" + name2[0].toUpperCase() + name2.slice(1);
    Class.prototype[filterName] = function(node, callback) {
      const result = [];
      this[forEachName](node, (n2, a2) => {
        if (callback(n2, a2))
          result.push(n2);
      });
      return result;
    };
    const reduceName = "reduce" + name2[0].toUpperCase() + name2.slice(1);
    Class.prototype[reduceName] = function(node, callback, initialValue) {
      if (arguments.length < 3)
        throw new InvalidArgumentsGraphError(
          `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`
        );
      let accumulator = initialValue;
      this[forEachName](node, (n2, a2) => {
        accumulator = callback(accumulator, n2, a2);
      });
      return accumulator;
    };
  }
  function attachFindNeighbor(Class, description) {
    const { name: name2, type, direction } = description;
    const capitalizedSingular = name2[0].toUpperCase() + name2.slice(1, -1);
    const findName = "find" + capitalizedSingular;
    Class.prototype[findName] = function(node, callback) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return;
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(
          `Graph.${findName}: could not find the "${node}" node in the graph.`
        );
      return forEachNeighbor(
        true,
        type === "mixed" ? this.type : type,
        direction,
        nodeData,
        callback
      );
    };
    const someName = "some" + capitalizedSingular;
    Class.prototype[someName] = function(node, callback) {
      const found = this[findName](node, callback);
      if (found)
        return true;
      return false;
    };
    const everyName = "every" + capitalizedSingular;
    Class.prototype[everyName] = function(node, callback) {
      const found = this[findName](node, (n2, a2) => {
        return !callback(n2, a2);
      });
      if (found)
        return false;
      return true;
    };
  }
  function attachNeighborIteratorCreator(Class, description) {
    const { name: name2, type, direction } = description;
    const iteratorName = name2.slice(0, -1) + "Entries";
    Class.prototype[iteratorName] = function(node) {
      if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
        return import_iterator.default.empty();
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(
          `Graph.${iteratorName}: could not find the "${node}" node in the graph.`
        );
      return createNeighborIterator(
        type === "mixed" ? this.type : type,
        direction,
        nodeData
      );
    };
  }
  function attachNeighborIterationMethods(Graph2) {
    NEIGHBORS_ITERATION.forEach((description) => {
      attachNeighborArrayCreator(Graph2, description);
      attachForEachNeighbor(Graph2, description);
      attachFindNeighbor(Graph2, description);
      attachNeighborIteratorCreator(Graph2, description);
    });
  }
  function forEachAdjacency(breakable, assymetric, disconnectedNodes, graph, callback) {
    const iterator = graph._nodes.values();
    const type = graph.type;
    let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;
    while (step = iterator.next(), step.done !== true) {
      let hasEdges = false;
      sourceData = step.value;
      if (type !== "undirected") {
        adj = sourceData.out;
        for (neighbor in adj) {
          edgeData = adj[neighbor];
          do {
            targetData = edgeData.target;
            hasEdges = true;
            shouldBreak = callback(
              sourceData.key,
              targetData.key,
              sourceData.attributes,
              targetData.attributes,
              edgeData.key,
              edgeData.attributes,
              edgeData.undirected
            );
            if (breakable && shouldBreak)
              return edgeData;
            edgeData = edgeData.next;
          } while (edgeData);
        }
      }
      if (type !== "directed") {
        adj = sourceData.undirected;
        for (neighbor in adj) {
          if (assymetric && sourceData.key > neighbor)
            continue;
          edgeData = adj[neighbor];
          do {
            targetData = edgeData.target;
            if (targetData.key !== neighbor)
              targetData = edgeData.source;
            hasEdges = true;
            shouldBreak = callback(
              sourceData.key,
              targetData.key,
              sourceData.attributes,
              targetData.attributes,
              edgeData.key,
              edgeData.attributes,
              edgeData.undirected
            );
            if (breakable && shouldBreak)
              return edgeData;
            edgeData = edgeData.next;
          } while (edgeData);
        }
      }
      if (disconnectedNodes && !hasEdges) {
        shouldBreak = callback(
          sourceData.key,
          null,
          sourceData.attributes,
          null,
          null,
          null,
          null
        );
        if (breakable && shouldBreak)
          return null;
      }
    }
    return;
  }
  function serializeNode(key, data) {
    const serialized = { key };
    if (!isEmpty(data.attributes))
      serialized.attributes = assign({}, data.attributes);
    return serialized;
  }
  function serializeEdge(type, key, data) {
    const serialized = {
      key,
      source: data.source.key,
      target: data.target.key
    };
    if (!isEmpty(data.attributes))
      serialized.attributes = assign({}, data.attributes);
    if (type === "mixed" && data.undirected)
      serialized.undirected = true;
    return serialized;
  }
  function validateSerializedNode(value) {
    if (!isPlainObject(value))
      throw new InvalidArgumentsGraphError(
        'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.'
      );
    if (!("key" in value))
      throw new InvalidArgumentsGraphError(
        "Graph.import: serialized node is missing its key."
      );
    if ("attributes" in value && (!isPlainObject(value.attributes) || value.attributes === null))
      throw new InvalidArgumentsGraphError(
        "Graph.import: invalid attributes. Attributes should be a plain object, null or omitted."
      );
  }
  function validateSerializedEdge(value) {
    if (!isPlainObject(value))
      throw new InvalidArgumentsGraphError(
        'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.'
      );
    if (!("source" in value))
      throw new InvalidArgumentsGraphError(
        "Graph.import: serialized edge is missing its source."
      );
    if (!("target" in value))
      throw new InvalidArgumentsGraphError(
        "Graph.import: serialized edge is missing its target."
      );
    if ("attributes" in value && (!isPlainObject(value.attributes) || value.attributes === null))
      throw new InvalidArgumentsGraphError(
        "Graph.import: invalid attributes. Attributes should be a plain object, null or omitted."
      );
    if ("undirected" in value && typeof value.undirected !== "boolean")
      throw new InvalidArgumentsGraphError(
        "Graph.import: invalid undirectedness information. Undirected should be boolean or omitted."
      );
  }
  function addNode(graph, node, attributes) {
    if (attributes && !isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.addNode: invalid attributes. Expecting an object but got "${attributes}"`
      );
    node = "" + node;
    attributes = attributes || {};
    if (graph._nodes.has(node))
      throw new UsageGraphError(
        `Graph.addNode: the "${node}" node already exist in the graph.`
      );
    const data = new graph.NodeDataClass(node, attributes);
    graph._nodes.set(node, data);
    graph.emit("nodeAdded", {
      key: node,
      attributes
    });
    return data;
  }
  function unsafeAddNode(graph, node, attributes) {
    const data = new graph.NodeDataClass(node, attributes);
    graph._nodes.set(node, data);
    graph.emit("nodeAdded", {
      key: node,
      attributes
    });
    return data;
  }
  function addEdge(graph, name2, mustGenerateKey, undirected, edge, source, target, attributes) {
    if (!undirected && graph.type === "undirected")
      throw new UsageGraphError(
        `Graph.${name2}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`
      );
    if (undirected && graph.type === "directed")
      throw new UsageGraphError(
        `Graph.${name2}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`
      );
    if (attributes && !isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.${name2}: invalid attributes. Expecting an object but got "${attributes}"`
      );
    source = "" + source;
    target = "" + target;
    attributes = attributes || {};
    if (!graph.allowSelfLoops && source === target)
      throw new UsageGraphError(
        `Graph.${name2}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`
      );
    const sourceData = graph._nodes.get(source), targetData = graph._nodes.get(target);
    if (!sourceData)
      throw new NotFoundGraphError(
        `Graph.${name2}: source node "${source}" not found.`
      );
    if (!targetData)
      throw new NotFoundGraphError(
        `Graph.${name2}: target node "${target}" not found.`
      );
    const eventData = {
      key: null,
      undirected,
      source,
      target,
      attributes
    };
    if (mustGenerateKey) {
      edge = graph._edgeKeyGenerator();
    } else {
      edge = "" + edge;
      if (graph._edges.has(edge))
        throw new UsageGraphError(
          `Graph.${name2}: the "${edge}" edge already exists in the graph.`
        );
    }
    if (!graph.multi && (undirected ? typeof sourceData.undirected[target] !== "undefined" : typeof sourceData.out[target] !== "undefined")) {
      throw new UsageGraphError(
        `Graph.${name2}: an edge linking "${source}" to "${target}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`
      );
    }
    const edgeData = new EdgeData(
      undirected,
      edge,
      sourceData,
      targetData,
      attributes
    );
    graph._edges.set(edge, edgeData);
    const isSelfLoop = source === target;
    if (undirected) {
      sourceData.undirectedDegree++;
      targetData.undirectedDegree++;
      if (isSelfLoop) {
        sourceData.undirectedLoops++;
        graph._undirectedSelfLoopCount++;
      }
    } else {
      sourceData.outDegree++;
      targetData.inDegree++;
      if (isSelfLoop) {
        sourceData.directedLoops++;
        graph._directedSelfLoopCount++;
      }
    }
    if (graph.multi)
      edgeData.attachMulti();
    else
      edgeData.attach();
    if (undirected)
      graph._undirectedSize++;
    else
      graph._directedSize++;
    eventData.key = edge;
    graph.emit("edgeAdded", eventData);
    return edge;
  }
  function mergeEdge(graph, name2, mustGenerateKey, undirected, edge, source, target, attributes, asUpdater) {
    if (!undirected && graph.type === "undirected")
      throw new UsageGraphError(
        `Graph.${name2}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`
      );
    if (undirected && graph.type === "directed")
      throw new UsageGraphError(
        `Graph.${name2}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`
      );
    if (attributes) {
      if (asUpdater) {
        if (typeof attributes !== "function")
          throw new InvalidArgumentsGraphError(
            `Graph.${name2}: invalid updater function. Expecting a function but got "${attributes}"`
          );
      } else {
        if (!isPlainObject(attributes))
          throw new InvalidArgumentsGraphError(
            `Graph.${name2}: invalid attributes. Expecting an object but got "${attributes}"`
          );
      }
    }
    source = "" + source;
    target = "" + target;
    let updater;
    if (asUpdater) {
      updater = attributes;
      attributes = void 0;
    }
    if (!graph.allowSelfLoops && source === target)
      throw new UsageGraphError(
        `Graph.${name2}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`
      );
    let sourceData = graph._nodes.get(source);
    let targetData = graph._nodes.get(target);
    let edgeData;
    let alreadyExistingEdgeData;
    if (!mustGenerateKey) {
      edgeData = graph._edges.get(edge);
      if (edgeData) {
        if (edgeData.source.key !== source || edgeData.target.key !== target) {
          if (!undirected || edgeData.source.key !== target || edgeData.target.key !== source) {
            throw new UsageGraphError(
              `Graph.${name2}: inconsistency detected when attempting to merge the "${edge}" edge with "${source}" source & "${target}" target vs. ("${edgeData.source.key}", "${edgeData.target.key}").`
            );
          }
        }
        alreadyExistingEdgeData = edgeData;
      }
    }
    if (!alreadyExistingEdgeData && !graph.multi && sourceData) {
      alreadyExistingEdgeData = undirected ? sourceData.undirected[target] : sourceData.out[target];
    }
    if (alreadyExistingEdgeData) {
      const info = [alreadyExistingEdgeData.key, false, false, false];
      if (asUpdater ? !updater : !attributes)
        return info;
      if (asUpdater) {
        const oldAttributes = alreadyExistingEdgeData.attributes;
        alreadyExistingEdgeData.attributes = updater(oldAttributes);
        graph.emit("edgeAttributesUpdated", {
          type: "replace",
          key: alreadyExistingEdgeData.key,
          attributes: alreadyExistingEdgeData.attributes
        });
      } else {
        assign(alreadyExistingEdgeData.attributes, attributes);
        graph.emit("edgeAttributesUpdated", {
          type: "merge",
          key: alreadyExistingEdgeData.key,
          attributes: alreadyExistingEdgeData.attributes,
          data: attributes
        });
      }
      return info;
    }
    attributes = attributes || {};
    if (asUpdater && updater)
      attributes = updater(attributes);
    const eventData = {
      key: null,
      undirected,
      source,
      target,
      attributes
    };
    if (mustGenerateKey) {
      edge = graph._edgeKeyGenerator();
    } else {
      edge = "" + edge;
      if (graph._edges.has(edge))
        throw new UsageGraphError(
          `Graph.${name2}: the "${edge}" edge already exists in the graph.`
        );
    }
    let sourceWasAdded = false;
    let targetWasAdded = false;
    if (!sourceData) {
      sourceData = unsafeAddNode(graph, source, {});
      sourceWasAdded = true;
      if (source === target) {
        targetData = sourceData;
        targetWasAdded = true;
      }
    }
    if (!targetData) {
      targetData = unsafeAddNode(graph, target, {});
      targetWasAdded = true;
    }
    edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);
    graph._edges.set(edge, edgeData);
    const isSelfLoop = source === target;
    if (undirected) {
      sourceData.undirectedDegree++;
      targetData.undirectedDegree++;
      if (isSelfLoop) {
        sourceData.undirectedLoops++;
        graph._undirectedSelfLoopCount++;
      }
    } else {
      sourceData.outDegree++;
      targetData.inDegree++;
      if (isSelfLoop) {
        sourceData.directedLoops++;
        graph._directedSelfLoopCount++;
      }
    }
    if (graph.multi)
      edgeData.attachMulti();
    else
      edgeData.attach();
    if (undirected)
      graph._undirectedSize++;
    else
      graph._directedSize++;
    eventData.key = edge;
    graph.emit("edgeAdded", eventData);
    return [edge, true, sourceWasAdded, targetWasAdded];
  }
  function dropEdgeFromData(graph, edgeData) {
    graph._edges.delete(edgeData.key);
    const { source: sourceData, target: targetData, attributes } = edgeData;
    const undirected = edgeData.undirected;
    const isSelfLoop = sourceData === targetData;
    if (undirected) {
      sourceData.undirectedDegree--;
      targetData.undirectedDegree--;
      if (isSelfLoop) {
        sourceData.undirectedLoops--;
        graph._undirectedSelfLoopCount--;
      }
    } else {
      sourceData.outDegree--;
      targetData.inDegree--;
      if (isSelfLoop) {
        sourceData.directedLoops--;
        graph._directedSelfLoopCount--;
      }
    }
    if (graph.multi)
      edgeData.detachMulti();
    else
      edgeData.detach();
    if (undirected)
      graph._undirectedSize--;
    else
      graph._directedSize--;
    graph.emit("edgeDropped", {
      key: edgeData.key,
      attributes,
      source: sourceData.key,
      target: targetData.key,
      undirected
    });
  }
  function attachStaticFromMethod(Class) {
    Class.from = function(data, options) {
      const finalOptions = assign({}, data.options, options);
      const instance = new Class(finalOptions);
      instance.import(data);
      return instance;
    };
  }
  var import_iterator, import_take, import_chain, assign, GraphError, InvalidArgumentsGraphError, NotFoundGraphError, UsageGraphError, NODE, SOURCE, TARGET, OPPOSITE, NODE_ATTRIBUTES_METHODS, EDGE_ATTRIBUTES_METHODS, EDGES_ITERATION, NEIGHBORS_ITERATION, INSTANCE_ID, TYPES, EMITTER_PROPS, EDGE_ADD_METHODS, DEFAULTS, Graph, DirectedGraph, UndirectedGraph, MultiGraph, MultiDirectedGraph, MultiUndirectedGraph;
  var init_graphology_esm = __esm({
    "../../node_modules/.pnpm/graphology@0.25.1_graphology-types@0.24.7/node_modules/graphology/dist/graphology.esm.js"() {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      init_events();
      import_iterator = __toESM(require_iterator());
      import_take = __toESM(require_take());
      import_chain = __toESM(require_chain());
      assign = assignPolyfill;
      if (typeof Object.assign === "function")
        assign = Object.assign;
      GraphError = class extends Error {
        constructor(message) {
          super();
          this.name = "GraphError";
          this.message = message;
        }
      };
      InvalidArgumentsGraphError = class _InvalidArgumentsGraphError extends GraphError {
        constructor(message) {
          super(message);
          this.name = "InvalidArgumentsGraphError";
          if (typeof Error.captureStackTrace === "function")
            Error.captureStackTrace(
              this,
              _InvalidArgumentsGraphError.prototype.constructor
            );
        }
      };
      NotFoundGraphError = class _NotFoundGraphError extends GraphError {
        constructor(message) {
          super(message);
          this.name = "NotFoundGraphError";
          if (typeof Error.captureStackTrace === "function")
            Error.captureStackTrace(this, _NotFoundGraphError.prototype.constructor);
        }
      };
      UsageGraphError = class _UsageGraphError extends GraphError {
        constructor(message) {
          super(message);
          this.name = "UsageGraphError";
          if (typeof Error.captureStackTrace === "function")
            Error.captureStackTrace(this, _UsageGraphError.prototype.constructor);
        }
      };
      MixedNodeData.prototype.clear = function() {
        this.inDegree = 0;
        this.outDegree = 0;
        this.undirectedDegree = 0;
        this.undirectedLoops = 0;
        this.directedLoops = 0;
        this.in = {};
        this.out = {};
        this.undirected = {};
      };
      DirectedNodeData.prototype.clear = function() {
        this.inDegree = 0;
        this.outDegree = 0;
        this.directedLoops = 0;
        this.in = {};
        this.out = {};
      };
      UndirectedNodeData.prototype.clear = function() {
        this.undirectedDegree = 0;
        this.undirectedLoops = 0;
        this.undirected = {};
      };
      EdgeData.prototype.attach = function() {
        let outKey = "out";
        let inKey = "in";
        if (this.undirected)
          outKey = inKey = "undirected";
        const source = this.source.key;
        const target = this.target.key;
        this.source[outKey][target] = this;
        if (this.undirected && source === target)
          return;
        this.target[inKey][source] = this;
      };
      EdgeData.prototype.attachMulti = function() {
        let outKey = "out";
        let inKey = "in";
        const source = this.source.key;
        const target = this.target.key;
        if (this.undirected)
          outKey = inKey = "undirected";
        const adj = this.source[outKey];
        const head = adj[target];
        if (typeof head === "undefined") {
          adj[target] = this;
          if (!(this.undirected && source === target)) {
            this.target[inKey][source] = this;
          }
          return;
        }
        head.previous = this;
        this.next = head;
        adj[target] = this;
        this.target[inKey][source] = this;
      };
      EdgeData.prototype.detach = function() {
        const source = this.source.key;
        const target = this.target.key;
        let outKey = "out";
        let inKey = "in";
        if (this.undirected)
          outKey = inKey = "undirected";
        delete this.source[outKey][target];
        delete this.target[inKey][source];
      };
      EdgeData.prototype.detachMulti = function() {
        const source = this.source.key;
        const target = this.target.key;
        let outKey = "out";
        let inKey = "in";
        if (this.undirected)
          outKey = inKey = "undirected";
        if (this.previous === void 0) {
          if (this.next === void 0) {
            delete this.source[outKey][target];
            delete this.target[inKey][source];
          } else {
            this.next.previous = void 0;
            this.source[outKey][target] = this.next;
            this.target[inKey][source] = this.next;
          }
        } else {
          this.previous.next = this.next;
          if (this.next !== void 0) {
            this.next.previous = this.previous;
          }
        }
      };
      NODE = 0;
      SOURCE = 1;
      TARGET = 2;
      OPPOSITE = 3;
      NODE_ATTRIBUTES_METHODS = [
        {
          name: (element) => `get${element}Attribute`,
          attacher: attachNodeAttributeGetter
        },
        {
          name: (element) => `get${element}Attributes`,
          attacher: attachNodeAttributesGetter
        },
        {
          name: (element) => `has${element}Attribute`,
          attacher: attachNodeAttributeChecker
        },
        {
          name: (element) => `set${element}Attribute`,
          attacher: attachNodeAttributeSetter
        },
        {
          name: (element) => `update${element}Attribute`,
          attacher: attachNodeAttributeUpdater
        },
        {
          name: (element) => `remove${element}Attribute`,
          attacher: attachNodeAttributeRemover
        },
        {
          name: (element) => `replace${element}Attributes`,
          attacher: attachNodeAttributesReplacer
        },
        {
          name: (element) => `merge${element}Attributes`,
          attacher: attachNodeAttributesMerger
        },
        {
          name: (element) => `update${element}Attributes`,
          attacher: attachNodeAttributesUpdater
        }
      ];
      EDGE_ATTRIBUTES_METHODS = [
        {
          name: (element) => `get${element}Attribute`,
          attacher: attachEdgeAttributeGetter
        },
        {
          name: (element) => `get${element}Attributes`,
          attacher: attachEdgeAttributesGetter
        },
        {
          name: (element) => `has${element}Attribute`,
          attacher: attachEdgeAttributeChecker
        },
        {
          name: (element) => `set${element}Attribute`,
          attacher: attachEdgeAttributeSetter
        },
        {
          name: (element) => `update${element}Attribute`,
          attacher: attachEdgeAttributeUpdater
        },
        {
          name: (element) => `remove${element}Attribute`,
          attacher: attachEdgeAttributeRemover
        },
        {
          name: (element) => `replace${element}Attributes`,
          attacher: attachEdgeAttributesReplacer
        },
        {
          name: (element) => `merge${element}Attributes`,
          attacher: attachEdgeAttributesMerger
        },
        {
          name: (element) => `update${element}Attributes`,
          attacher: attachEdgeAttributesUpdater
        }
      ];
      EDGES_ITERATION = [
        {
          name: "edges",
          type: "mixed"
        },
        {
          name: "inEdges",
          type: "directed",
          direction: "in"
        },
        {
          name: "outEdges",
          type: "directed",
          direction: "out"
        },
        {
          name: "inboundEdges",
          type: "mixed",
          direction: "in"
        },
        {
          name: "outboundEdges",
          type: "mixed",
          direction: "out"
        },
        {
          name: "directedEdges",
          type: "directed"
        },
        {
          name: "undirectedEdges",
          type: "undirected"
        }
      ];
      NEIGHBORS_ITERATION = [
        {
          name: "neighbors",
          type: "mixed"
        },
        {
          name: "inNeighbors",
          type: "directed",
          direction: "in"
        },
        {
          name: "outNeighbors",
          type: "directed",
          direction: "out"
        },
        {
          name: "inboundNeighbors",
          type: "mixed",
          direction: "in"
        },
        {
          name: "outboundNeighbors",
          type: "mixed",
          direction: "out"
        },
        {
          name: "directedNeighbors",
          type: "directed"
        },
        {
          name: "undirectedNeighbors",
          type: "undirected"
        }
      ];
      CompositeSetWrapper.prototype.wrap = function(set) {
        if (this.A === null)
          this.A = set;
        else if (this.B === null)
          this.B = set;
      };
      CompositeSetWrapper.prototype.has = function(key) {
        if (this.A !== null && key in this.A)
          return true;
        if (this.B !== null && key in this.B)
          return true;
        return false;
      };
      INSTANCE_ID = incrementalIdStartingFromRandomByte();
      TYPES = /* @__PURE__ */ new Set(["directed", "undirected", "mixed"]);
      EMITTER_PROPS = /* @__PURE__ */ new Set([
        "domain",
        "_events",
        "_eventsCount",
        "_maxListeners"
      ]);
      EDGE_ADD_METHODS = [
        {
          name: (verb) => `${verb}Edge`,
          generateKey: true
        },
        {
          name: (verb) => `${verb}DirectedEdge`,
          generateKey: true,
          type: "directed"
        },
        {
          name: (verb) => `${verb}UndirectedEdge`,
          generateKey: true,
          type: "undirected"
        },
        {
          name: (verb) => `${verb}EdgeWithKey`
        },
        {
          name: (verb) => `${verb}DirectedEdgeWithKey`,
          type: "directed"
        },
        {
          name: (verb) => `${verb}UndirectedEdgeWithKey`,
          type: "undirected"
        }
      ];
      DEFAULTS = {
        allowSelfLoops: true,
        multi: false,
        type: "mixed"
      };
      Graph = class _Graph extends EventEmitter {
        constructor(options) {
          super();
          options = assign({}, DEFAULTS, options);
          if (typeof options.multi !== "boolean")
            throw new InvalidArgumentsGraphError(
              `Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${options.multi}".`
            );
          if (!TYPES.has(options.type))
            throw new InvalidArgumentsGraphError(
              `Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${options.type}".`
            );
          if (typeof options.allowSelfLoops !== "boolean")
            throw new InvalidArgumentsGraphError(
              `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${options.allowSelfLoops}".`
            );
          const NodeDataClass = options.type === "mixed" ? MixedNodeData : options.type === "directed" ? DirectedNodeData : UndirectedNodeData;
          privateProperty(this, "NodeDataClass", NodeDataClass);
          const instancePrefix = "geid_" + INSTANCE_ID() + "_";
          let edgeId = 0;
          const edgeKeyGenerator = () => {
            let availableEdgeKey;
            do {
              availableEdgeKey = instancePrefix + edgeId++;
            } while (this._edges.has(availableEdgeKey));
            return availableEdgeKey;
          };
          privateProperty(this, "_attributes", {});
          privateProperty(this, "_nodes", /* @__PURE__ */ new Map());
          privateProperty(this, "_edges", /* @__PURE__ */ new Map());
          privateProperty(this, "_directedSize", 0);
          privateProperty(this, "_undirectedSize", 0);
          privateProperty(this, "_directedSelfLoopCount", 0);
          privateProperty(this, "_undirectedSelfLoopCount", 0);
          privateProperty(this, "_edgeKeyGenerator", edgeKeyGenerator);
          privateProperty(this, "_options", options);
          EMITTER_PROPS.forEach((prop) => privateProperty(this, prop, this[prop]));
          readOnlyProperty(this, "order", () => this._nodes.size);
          readOnlyProperty(this, "size", () => this._edges.size);
          readOnlyProperty(this, "directedSize", () => this._directedSize);
          readOnlyProperty(this, "undirectedSize", () => this._undirectedSize);
          readOnlyProperty(
            this,
            "selfLoopCount",
            () => this._directedSelfLoopCount + this._undirectedSelfLoopCount
          );
          readOnlyProperty(
            this,
            "directedSelfLoopCount",
            () => this._directedSelfLoopCount
          );
          readOnlyProperty(
            this,
            "undirectedSelfLoopCount",
            () => this._undirectedSelfLoopCount
          );
          readOnlyProperty(this, "multi", this._options.multi);
          readOnlyProperty(this, "type", this._options.type);
          readOnlyProperty(this, "allowSelfLoops", this._options.allowSelfLoops);
          readOnlyProperty(this, "implementation", () => "graphology");
        }
        _resetInstanceCounters() {
          this._directedSize = 0;
          this._undirectedSize = 0;
          this._directedSelfLoopCount = 0;
          this._undirectedSelfLoopCount = 0;
        }
        /**---------------------------------------------------------------------------
         * Read
         **---------------------------------------------------------------------------
         */
        /**
         * Method returning whether the given node is found in the graph.
         *
         * @param  {any}     node - The node.
         * @return {boolean}
         */
        hasNode(node) {
          return this._nodes.has("" + node);
        }
        /**
         * Method returning whether the given directed edge is found in the graph.
         *
         * Arity 1:
         * @param  {any}     edge - The edge's key.
         *
         * Arity 2:
         * @param  {any}     source - The edge's source.
         * @param  {any}     target - The edge's target.
         *
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the arguments are invalid.
         */
        hasDirectedEdge(source, target) {
          if (this.type === "undirected")
            return false;
          if (arguments.length === 1) {
            const edge = "" + source;
            const edgeData = this._edges.get(edge);
            return !!edgeData && !edgeData.undirected;
          } else if (arguments.length === 2) {
            source = "" + source;
            target = "" + target;
            const nodeData = this._nodes.get(source);
            if (!nodeData)
              return false;
            return nodeData.out.hasOwnProperty(target);
          }
          throw new InvalidArgumentsGraphError(
            `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
          );
        }
        /**
         * Method returning whether the given undirected edge is found in the graph.
         *
         * Arity 1:
         * @param  {any}     edge - The edge's key.
         *
         * Arity 2:
         * @param  {any}     source - The edge's source.
         * @param  {any}     target - The edge's target.
         *
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the arguments are invalid.
         */
        hasUndirectedEdge(source, target) {
          if (this.type === "directed")
            return false;
          if (arguments.length === 1) {
            const edge = "" + source;
            const edgeData = this._edges.get(edge);
            return !!edgeData && edgeData.undirected;
          } else if (arguments.length === 2) {
            source = "" + source;
            target = "" + target;
            const nodeData = this._nodes.get(source);
            if (!nodeData)
              return false;
            return nodeData.undirected.hasOwnProperty(target);
          }
          throw new InvalidArgumentsGraphError(
            `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
          );
        }
        /**
         * Method returning whether the given edge is found in the graph.
         *
         * Arity 1:
         * @param  {any}     edge - The edge's key.
         *
         * Arity 2:
         * @param  {any}     source - The edge's source.
         * @param  {any}     target - The edge's target.
         *
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the arguments are invalid.
         */
        hasEdge(source, target) {
          if (arguments.length === 1) {
            const edge = "" + source;
            return this._edges.has(edge);
          } else if (arguments.length === 2) {
            source = "" + source;
            target = "" + target;
            const nodeData = this._nodes.get(source);
            if (!nodeData)
              return false;
            return typeof nodeData.out !== "undefined" && nodeData.out.hasOwnProperty(target) || typeof nodeData.undirected !== "undefined" && nodeData.undirected.hasOwnProperty(target);
          }
          throw new InvalidArgumentsGraphError(
            `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
          );
        }
        /**
         * Method returning the edge matching source & target in a directed fashion.
         *
         * @param  {any} source - The edge's source.
         * @param  {any} target - The edge's target.
         *
         * @return {any|undefined}
         *
         * @throws {Error} - Will throw if the graph is multi.
         * @throws {Error} - Will throw if source or target doesn't exist.
         */
        directedEdge(source, target) {
          if (this.type === "undirected")
            return;
          source = "" + source;
          target = "" + target;
          if (this.multi)
            throw new UsageGraphError(
              "Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead."
            );
          const sourceData = this._nodes.get(source);
          if (!sourceData)
            throw new NotFoundGraphError(
              `Graph.directedEdge: could not find the "${source}" source node in the graph.`
            );
          if (!this._nodes.has(target))
            throw new NotFoundGraphError(
              `Graph.directedEdge: could not find the "${target}" target node in the graph.`
            );
          const edgeData = sourceData.out && sourceData.out[target] || void 0;
          if (edgeData)
            return edgeData.key;
        }
        /**
         * Method returning the edge matching source & target in a undirected fashion.
         *
         * @param  {any} source - The edge's source.
         * @param  {any} target - The edge's target.
         *
         * @return {any|undefined}
         *
         * @throws {Error} - Will throw if the graph is multi.
         * @throws {Error} - Will throw if source or target doesn't exist.
         */
        undirectedEdge(source, target) {
          if (this.type === "directed")
            return;
          source = "" + source;
          target = "" + target;
          if (this.multi)
            throw new UsageGraphError(
              "Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead."
            );
          const sourceData = this._nodes.get(source);
          if (!sourceData)
            throw new NotFoundGraphError(
              `Graph.undirectedEdge: could not find the "${source}" source node in the graph.`
            );
          if (!this._nodes.has(target))
            throw new NotFoundGraphError(
              `Graph.undirectedEdge: could not find the "${target}" target node in the graph.`
            );
          const edgeData = sourceData.undirected && sourceData.undirected[target] || void 0;
          if (edgeData)
            return edgeData.key;
        }
        /**
         * Method returning the edge matching source & target in a mixed fashion.
         *
         * @param  {any} source - The edge's source.
         * @param  {any} target - The edge's target.
         *
         * @return {any|undefined}
         *
         * @throws {Error} - Will throw if the graph is multi.
         * @throws {Error} - Will throw if source or target doesn't exist.
         */
        edge(source, target) {
          if (this.multi)
            throw new UsageGraphError(
              "Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead."
            );
          source = "" + source;
          target = "" + target;
          const sourceData = this._nodes.get(source);
          if (!sourceData)
            throw new NotFoundGraphError(
              `Graph.edge: could not find the "${source}" source node in the graph.`
            );
          if (!this._nodes.has(target))
            throw new NotFoundGraphError(
              `Graph.edge: could not find the "${target}" target node in the graph.`
            );
          const edgeData = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target] || void 0;
          if (edgeData)
            return edgeData.key;
        }
        /**
         * Method returning whether two nodes are directed neighbors.
         *
         * @param  {any}     node     - The node's key.
         * @param  {any}     neighbor - The neighbor's key.
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        areDirectedNeighbors(node, neighbor) {
          node = "" + node;
          neighbor = "" + neighbor;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.areDirectedNeighbors: could not find the "${node}" node in the graph.`
            );
          if (this.type === "undirected")
            return false;
          return neighbor in nodeData.in || neighbor in nodeData.out;
        }
        /**
         * Method returning whether two nodes are out neighbors.
         *
         * @param  {any}     node     - The node's key.
         * @param  {any}     neighbor - The neighbor's key.
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        areOutNeighbors(node, neighbor) {
          node = "" + node;
          neighbor = "" + neighbor;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.areOutNeighbors: could not find the "${node}" node in the graph.`
            );
          if (this.type === "undirected")
            return false;
          return neighbor in nodeData.out;
        }
        /**
         * Method returning whether two nodes are in neighbors.
         *
         * @param  {any}     node     - The node's key.
         * @param  {any}     neighbor - The neighbor's key.
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        areInNeighbors(node, neighbor) {
          node = "" + node;
          neighbor = "" + neighbor;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.areInNeighbors: could not find the "${node}" node in the graph.`
            );
          if (this.type === "undirected")
            return false;
          return neighbor in nodeData.in;
        }
        /**
         * Method returning whether two nodes are undirected neighbors.
         *
         * @param  {any}     node     - The node's key.
         * @param  {any}     neighbor - The neighbor's key.
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        areUndirectedNeighbors(node, neighbor) {
          node = "" + node;
          neighbor = "" + neighbor;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.areUndirectedNeighbors: could not find the "${node}" node in the graph.`
            );
          if (this.type === "directed")
            return false;
          return neighbor in nodeData.undirected;
        }
        /**
         * Method returning whether two nodes are neighbors.
         *
         * @param  {any}     node     - The node's key.
         * @param  {any}     neighbor - The neighbor's key.
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        areNeighbors(node, neighbor) {
          node = "" + node;
          neighbor = "" + neighbor;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.areNeighbors: could not find the "${node}" node in the graph.`
            );
          if (this.type !== "undirected") {
            if (neighbor in nodeData.in || neighbor in nodeData.out)
              return true;
          }
          if (this.type !== "directed") {
            if (neighbor in nodeData.undirected)
              return true;
          }
          return false;
        }
        /**
         * Method returning whether two nodes are inbound neighbors.
         *
         * @param  {any}     node     - The node's key.
         * @param  {any}     neighbor - The neighbor's key.
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        areInboundNeighbors(node, neighbor) {
          node = "" + node;
          neighbor = "" + neighbor;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.areInboundNeighbors: could not find the "${node}" node in the graph.`
            );
          if (this.type !== "undirected") {
            if (neighbor in nodeData.in)
              return true;
          }
          if (this.type !== "directed") {
            if (neighbor in nodeData.undirected)
              return true;
          }
          return false;
        }
        /**
         * Method returning whether two nodes are outbound neighbors.
         *
         * @param  {any}     node     - The node's key.
         * @param  {any}     neighbor - The neighbor's key.
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        areOutboundNeighbors(node, neighbor) {
          node = "" + node;
          neighbor = "" + neighbor;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.areOutboundNeighbors: could not find the "${node}" node in the graph.`
            );
          if (this.type !== "undirected") {
            if (neighbor in nodeData.out)
              return true;
          }
          if (this.type !== "directed") {
            if (neighbor in nodeData.undirected)
              return true;
          }
          return false;
        }
        /**
         * Method returning the given node's in degree.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's in degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        inDegree(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.inDegree: could not find the "${node}" node in the graph.`
            );
          if (this.type === "undirected")
            return 0;
          return nodeData.inDegree;
        }
        /**
         * Method returning the given node's out degree.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's in degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        outDegree(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.outDegree: could not find the "${node}" node in the graph.`
            );
          if (this.type === "undirected")
            return 0;
          return nodeData.outDegree;
        }
        /**
         * Method returning the given node's directed degree.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's in degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        directedDegree(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.directedDegree: could not find the "${node}" node in the graph.`
            );
          if (this.type === "undirected")
            return 0;
          return nodeData.inDegree + nodeData.outDegree;
        }
        /**
         * Method returning the given node's undirected degree.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's in degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        undirectedDegree(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.undirectedDegree: could not find the "${node}" node in the graph.`
            );
          if (this.type === "directed")
            return 0;
          return nodeData.undirectedDegree;
        }
        /**
         * Method returning the given node's inbound degree.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's inbound degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        inboundDegree(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.inboundDegree: could not find the "${node}" node in the graph.`
            );
          let degree = 0;
          if (this.type !== "directed") {
            degree += nodeData.undirectedDegree;
          }
          if (this.type !== "undirected") {
            degree += nodeData.inDegree;
          }
          return degree;
        }
        /**
         * Method returning the given node's outbound degree.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's outbound degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        outboundDegree(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.outboundDegree: could not find the "${node}" node in the graph.`
            );
          let degree = 0;
          if (this.type !== "directed") {
            degree += nodeData.undirectedDegree;
          }
          if (this.type !== "undirected") {
            degree += nodeData.outDegree;
          }
          return degree;
        }
        /**
         * Method returning the given node's directed degree.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        degree(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.degree: could not find the "${node}" node in the graph.`
            );
          let degree = 0;
          if (this.type !== "directed") {
            degree += nodeData.undirectedDegree;
          }
          if (this.type !== "undirected") {
            degree += nodeData.inDegree + nodeData.outDegree;
          }
          return degree;
        }
        /**
         * Method returning the given node's in degree without considering self loops.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's in degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        inDegreeWithoutSelfLoops(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.inDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
            );
          if (this.type === "undirected")
            return 0;
          return nodeData.inDegree - nodeData.directedLoops;
        }
        /**
         * Method returning the given node's out degree without considering self loops.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's in degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        outDegreeWithoutSelfLoops(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.outDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
            );
          if (this.type === "undirected")
            return 0;
          return nodeData.outDegree - nodeData.directedLoops;
        }
        /**
         * Method returning the given node's directed degree without considering self loops.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's in degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        directedDegreeWithoutSelfLoops(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.directedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
            );
          if (this.type === "undirected")
            return 0;
          return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;
        }
        /**
         * Method returning the given node's undirected degree without considering self loops.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's in degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        undirectedDegreeWithoutSelfLoops(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.undirectedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
            );
          if (this.type === "directed")
            return 0;
          return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;
        }
        /**
         * Method returning the given node's inbound degree without considering self loops.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's inbound degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        inboundDegreeWithoutSelfLoops(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.inboundDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
            );
          let degree = 0;
          let loops = 0;
          if (this.type !== "directed") {
            degree += nodeData.undirectedDegree;
            loops += nodeData.undirectedLoops * 2;
          }
          if (this.type !== "undirected") {
            degree += nodeData.inDegree;
            loops += nodeData.directedLoops;
          }
          return degree - loops;
        }
        /**
         * Method returning the given node's outbound degree without considering self loops.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's outbound degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        outboundDegreeWithoutSelfLoops(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.outboundDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
            );
          let degree = 0;
          let loops = 0;
          if (this.type !== "directed") {
            degree += nodeData.undirectedDegree;
            loops += nodeData.undirectedLoops * 2;
          }
          if (this.type !== "undirected") {
            degree += nodeData.outDegree;
            loops += nodeData.directedLoops;
          }
          return degree - loops;
        }
        /**
         * Method returning the given node's directed degree without considering self loops.
         *
         * @param  {any}     node - The node's key.
         * @return {number}       - The node's degree.
         *
         * @throws {Error} - Will throw if the node isn't in the graph.
         */
        degreeWithoutSelfLoops(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.degreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
            );
          let degree = 0;
          let loops = 0;
          if (this.type !== "directed") {
            degree += nodeData.undirectedDegree;
            loops += nodeData.undirectedLoops * 2;
          }
          if (this.type !== "undirected") {
            degree += nodeData.inDegree + nodeData.outDegree;
            loops += nodeData.directedLoops * 2;
          }
          return degree - loops;
        }
        /**
         * Method returning the given edge's source.
         *
         * @param  {any} edge - The edge's key.
         * @return {any}      - The edge's source.
         *
         * @throws {Error} - Will throw if the edge isn't in the graph.
         */
        source(edge) {
          edge = "" + edge;
          const data = this._edges.get(edge);
          if (!data)
            throw new NotFoundGraphError(
              `Graph.source: could not find the "${edge}" edge in the graph.`
            );
          return data.source.key;
        }
        /**
         * Method returning the given edge's target.
         *
         * @param  {any} edge - The edge's key.
         * @return {any}      - The edge's target.
         *
         * @throws {Error} - Will throw if the edge isn't in the graph.
         */
        target(edge) {
          edge = "" + edge;
          const data = this._edges.get(edge);
          if (!data)
            throw new NotFoundGraphError(
              `Graph.target: could not find the "${edge}" edge in the graph.`
            );
          return data.target.key;
        }
        /**
         * Method returning the given edge's extremities.
         *
         * @param  {any}   edge - The edge's key.
         * @return {array}      - The edge's extremities.
         *
         * @throws {Error} - Will throw if the edge isn't in the graph.
         */
        extremities(edge) {
          edge = "" + edge;
          const edgeData = this._edges.get(edge);
          if (!edgeData)
            throw new NotFoundGraphError(
              `Graph.extremities: could not find the "${edge}" edge in the graph.`
            );
          return [edgeData.source.key, edgeData.target.key];
        }
        /**
         * Given a node & an edge, returns the other extremity of the edge.
         *
         * @param  {any}   node - The node's key.
         * @param  {any}   edge - The edge's key.
         * @return {any}        - The related node.
         *
         * @throws {Error} - Will throw if the edge isn't in the graph or if the
         *                   edge & node are not related.
         */
        opposite(node, edge) {
          node = "" + node;
          edge = "" + edge;
          const data = this._edges.get(edge);
          if (!data)
            throw new NotFoundGraphError(
              `Graph.opposite: could not find the "${edge}" edge in the graph.`
            );
          const source = data.source.key;
          const target = data.target.key;
          if (node === source)
            return target;
          if (node === target)
            return source;
          throw new NotFoundGraphError(
            `Graph.opposite: the "${node}" node is not attached to the "${edge}" edge (${source}, ${target}).`
          );
        }
        /**
         * Returns whether the given edge has the given node as extremity.
         *
         * @param  {any}     edge - The edge's key.
         * @param  {any}     node - The node's key.
         * @return {boolean}      - The related node.
         *
         * @throws {Error} - Will throw if either the node or the edge isn't in the graph.
         */
        hasExtremity(edge, node) {
          edge = "" + edge;
          node = "" + node;
          const data = this._edges.get(edge);
          if (!data)
            throw new NotFoundGraphError(
              `Graph.hasExtremity: could not find the "${edge}" edge in the graph.`
            );
          return data.source.key === node || data.target.key === node;
        }
        /**
         * Method returning whether the given edge is undirected.
         *
         * @param  {any}     edge - The edge's key.
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the edge isn't in the graph.
         */
        isUndirected(edge) {
          edge = "" + edge;
          const data = this._edges.get(edge);
          if (!data)
            throw new NotFoundGraphError(
              `Graph.isUndirected: could not find the "${edge}" edge in the graph.`
            );
          return data.undirected;
        }
        /**
         * Method returning whether the given edge is directed.
         *
         * @param  {any}     edge - The edge's key.
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the edge isn't in the graph.
         */
        isDirected(edge) {
          edge = "" + edge;
          const data = this._edges.get(edge);
          if (!data)
            throw new NotFoundGraphError(
              `Graph.isDirected: could not find the "${edge}" edge in the graph.`
            );
          return !data.undirected;
        }
        /**
         * Method returning whether the given edge is a self loop.
         *
         * @param  {any}     edge - The edge's key.
         * @return {boolean}
         *
         * @throws {Error} - Will throw if the edge isn't in the graph.
         */
        isSelfLoop(edge) {
          edge = "" + edge;
          const data = this._edges.get(edge);
          if (!data)
            throw new NotFoundGraphError(
              `Graph.isSelfLoop: could not find the "${edge}" edge in the graph.`
            );
          return data.source === data.target;
        }
        /**---------------------------------------------------------------------------
         * Mutation
         **---------------------------------------------------------------------------
         */
        /**
         * Method used to add a node to the graph.
         *
         * @param  {any}    node         - The node.
         * @param  {object} [attributes] - Optional attributes.
         * @return {any}                 - The node.
         *
         * @throws {Error} - Will throw if the given node already exist.
         * @throws {Error} - Will throw if the given attributes are not an object.
         */
        addNode(node, attributes) {
          const nodeData = addNode(this, node, attributes);
          return nodeData.key;
        }
        /**
         * Method used to merge a node into the graph.
         *
         * @param  {any}    node         - The node.
         * @param  {object} [attributes] - Optional attributes.
         * @return {any}                 - The node.
         */
        mergeNode(node, attributes) {
          if (attributes && !isPlainObject(attributes))
            throw new InvalidArgumentsGraphError(
              `Graph.mergeNode: invalid attributes. Expecting an object but got "${attributes}"`
            );
          node = "" + node;
          attributes = attributes || {};
          let data = this._nodes.get(node);
          if (data) {
            if (attributes) {
              assign(data.attributes, attributes);
              this.emit("nodeAttributesUpdated", {
                type: "merge",
                key: node,
                attributes: data.attributes,
                data: attributes
              });
            }
            return [node, false];
          }
          data = new this.NodeDataClass(node, attributes);
          this._nodes.set(node, data);
          this.emit("nodeAdded", {
            key: node,
            attributes
          });
          return [node, true];
        }
        /**
         * Method used to add a node if it does not exist in the graph or else to
         * update its attributes using a function.
         *
         * @param  {any}      node      - The node.
         * @param  {function} [updater] - Optional updater function.
         * @return {any}                - The node.
         */
        updateNode(node, updater) {
          if (updater && typeof updater !== "function")
            throw new InvalidArgumentsGraphError(
              `Graph.updateNode: invalid updater function. Expecting a function but got "${updater}"`
            );
          node = "" + node;
          let data = this._nodes.get(node);
          if (data) {
            if (updater) {
              const oldAttributes = data.attributes;
              data.attributes = updater(oldAttributes);
              this.emit("nodeAttributesUpdated", {
                type: "replace",
                key: node,
                attributes: data.attributes
              });
            }
            return [node, false];
          }
          const attributes = updater ? updater({}) : {};
          data = new this.NodeDataClass(node, attributes);
          this._nodes.set(node, data);
          this.emit("nodeAdded", {
            key: node,
            attributes
          });
          return [node, true];
        }
        /**
         * Method used to drop a single node & all its attached edges from the graph.
         *
         * @param  {any}    node - The node.
         * @return {Graph}
         *
         * @throws {Error} - Will throw if the node doesn't exist.
         */
        dropNode(node) {
          node = "" + node;
          const nodeData = this._nodes.get(node);
          if (!nodeData)
            throw new NotFoundGraphError(
              `Graph.dropNode: could not find the "${node}" node in the graph.`
            );
          let edgeData;
          if (this.type !== "undirected") {
            for (const neighbor in nodeData.out) {
              edgeData = nodeData.out[neighbor];
              do {
                dropEdgeFromData(this, edgeData);
                edgeData = edgeData.next;
              } while (edgeData);
            }
            for (const neighbor in nodeData.in) {
              edgeData = nodeData.in[neighbor];
              do {
                dropEdgeFromData(this, edgeData);
                edgeData = edgeData.next;
              } while (edgeData);
            }
          }
          if (this.type !== "directed") {
            for (const neighbor in nodeData.undirected) {
              edgeData = nodeData.undirected[neighbor];
              do {
                dropEdgeFromData(this, edgeData);
                edgeData = edgeData.next;
              } while (edgeData);
            }
          }
          this._nodes.delete(node);
          this.emit("nodeDropped", {
            key: node,
            attributes: nodeData.attributes
          });
        }
        /**
         * Method used to drop a single edge from the graph.
         *
         * Arity 1:
         * @param  {any}    edge - The edge.
         *
         * Arity 2:
         * @param  {any}    source - Source node.
         * @param  {any}    target - Target node.
         *
         * @return {Graph}
         *
         * @throws {Error} - Will throw if the edge doesn't exist.
         */
        dropEdge(edge) {
          let edgeData;
          if (arguments.length > 1) {
            const source = "" + arguments[0];
            const target = "" + arguments[1];
            edgeData = getMatchingEdge(this, source, target, this.type);
            if (!edgeData)
              throw new NotFoundGraphError(
                `Graph.dropEdge: could not find the "${source}" -> "${target}" edge in the graph.`
              );
          } else {
            edge = "" + edge;
            edgeData = this._edges.get(edge);
            if (!edgeData)
              throw new NotFoundGraphError(
                `Graph.dropEdge: could not find the "${edge}" edge in the graph.`
              );
          }
          dropEdgeFromData(this, edgeData);
          return this;
        }
        /**
         * Method used to drop a single directed edge from the graph.
         *
         * @param  {any}    source - Source node.
         * @param  {any}    target - Target node.
         *
         * @return {Graph}
         *
         * @throws {Error} - Will throw if the edge doesn't exist.
         */
        dropDirectedEdge(source, target) {
          if (arguments.length < 2)
            throw new UsageGraphError(
              "Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead."
            );
          if (this.multi)
            throw new UsageGraphError(
              "Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones."
            );
          source = "" + source;
          target = "" + target;
          const edgeData = getMatchingEdge(this, source, target, "directed");
          if (!edgeData)
            throw new NotFoundGraphError(
              `Graph.dropDirectedEdge: could not find a "${source}" -> "${target}" edge in the graph.`
            );
          dropEdgeFromData(this, edgeData);
          return this;
        }
        /**
         * Method used to drop a single undirected edge from the graph.
         *
         * @param  {any}    source - Source node.
         * @param  {any}    target - Target node.
         *
         * @return {Graph}
         *
         * @throws {Error} - Will throw if the edge doesn't exist.
         */
        dropUndirectedEdge(source, target) {
          if (arguments.length < 2)
            throw new UsageGraphError(
              "Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead."
            );
          if (this.multi)
            throw new UsageGraphError(
              "Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones."
            );
          const edgeData = getMatchingEdge(this, source, target, "undirected");
          if (!edgeData)
            throw new NotFoundGraphError(
              `Graph.dropUndirectedEdge: could not find a "${source}" -> "${target}" edge in the graph.`
            );
          dropEdgeFromData(this, edgeData);
          return this;
        }
        /**
         * Method used to remove every edge & every node from the graph.
         *
         * @return {Graph}
         */
        clear() {
          this._edges.clear();
          this._nodes.clear();
          this._resetInstanceCounters();
          this.emit("cleared");
        }
        /**
         * Method used to remove every edge from the graph.
         *
         * @return {Graph}
         */
        clearEdges() {
          const iterator = this._nodes.values();
          let step;
          while (step = iterator.next(), step.done !== true) {
            step.value.clear();
          }
          this._edges.clear();
          this._resetInstanceCounters();
          this.emit("edgesCleared");
        }
        /**---------------------------------------------------------------------------
         * Attributes-related methods
         **---------------------------------------------------------------------------
         */
        /**
         * Method returning the desired graph's attribute.
         *
         * @param  {string} name - Name of the attribute.
         * @return {any}
         */
        getAttribute(name2) {
          return this._attributes[name2];
        }
        /**
         * Method returning the graph's attributes.
         *
         * @return {object}
         */
        getAttributes() {
          return this._attributes;
        }
        /**
         * Method returning whether the graph has the desired attribute.
         *
         * @param  {string}  name - Name of the attribute.
         * @return {boolean}
         */
        hasAttribute(name2) {
          return this._attributes.hasOwnProperty(name2);
        }
        /**
         * Method setting a value for the desired graph's attribute.
         *
         * @param  {string}  name  - Name of the attribute.
         * @param  {any}     value - Value for the attribute.
         * @return {Graph}
         */
        setAttribute(name2, value) {
          this._attributes[name2] = value;
          this.emit("attributesUpdated", {
            type: "set",
            attributes: this._attributes,
            name: name2
          });
          return this;
        }
        /**
         * Method using a function to update the desired graph's attribute's value.
         *
         * @param  {string}   name    - Name of the attribute.
         * @param  {function} updater - Function use to update the attribute's value.
         * @return {Graph}
         */
        updateAttribute(name2, updater) {
          if (typeof updater !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.updateAttribute: updater should be a function."
            );
          const value = this._attributes[name2];
          this._attributes[name2] = updater(value);
          this.emit("attributesUpdated", {
            type: "set",
            attributes: this._attributes,
            name: name2
          });
          return this;
        }
        /**
         * Method removing the desired graph's attribute.
         *
         * @param  {string} name  - Name of the attribute.
         * @return {Graph}
         */
        removeAttribute(name2) {
          delete this._attributes[name2];
          this.emit("attributesUpdated", {
            type: "remove",
            attributes: this._attributes,
            name: name2
          });
          return this;
        }
        /**
         * Method replacing the graph's attributes.
         *
         * @param  {object} attributes - New attributes.
         * @return {Graph}
         *
         * @throws {Error} - Will throw if given attributes are not a plain object.
         */
        replaceAttributes(attributes) {
          if (!isPlainObject(attributes))
            throw new InvalidArgumentsGraphError(
              "Graph.replaceAttributes: provided attributes are not a plain object."
            );
          this._attributes = attributes;
          this.emit("attributesUpdated", {
            type: "replace",
            attributes: this._attributes
          });
          return this;
        }
        /**
         * Method merging the graph's attributes.
         *
         * @param  {object} attributes - Attributes to merge.
         * @return {Graph}
         *
         * @throws {Error} - Will throw if given attributes are not a plain object.
         */
        mergeAttributes(attributes) {
          if (!isPlainObject(attributes))
            throw new InvalidArgumentsGraphError(
              "Graph.mergeAttributes: provided attributes are not a plain object."
            );
          assign(this._attributes, attributes);
          this.emit("attributesUpdated", {
            type: "merge",
            attributes: this._attributes,
            data: attributes
          });
          return this;
        }
        /**
         * Method updating the graph's attributes.
         *
         * @param  {function} updater - Function used to update the attributes.
         * @return {Graph}
         *
         * @throws {Error} - Will throw if given updater is not a function.
         */
        updateAttributes(updater) {
          if (typeof updater !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.updateAttributes: provided updater is not a function."
            );
          this._attributes = updater(this._attributes);
          this.emit("attributesUpdated", {
            type: "update",
            attributes: this._attributes
          });
          return this;
        }
        /**
         * Method used to update each node's attributes using the given function.
         *
         * @param {function}  updater - Updater function to use.
         * @param {object}    [hints] - Optional hints.
         */
        updateEachNodeAttributes(updater, hints) {
          if (typeof updater !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.updateEachNodeAttributes: expecting an updater function."
            );
          if (hints && !validateHints(hints))
            throw new InvalidArgumentsGraphError(
              "Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}"
            );
          const iterator = this._nodes.values();
          let step, nodeData;
          while (step = iterator.next(), step.done !== true) {
            nodeData = step.value;
            nodeData.attributes = updater(nodeData.key, nodeData.attributes);
          }
          this.emit("eachNodeAttributesUpdated", {
            hints: hints ? hints : null
          });
        }
        /**
         * Method used to update each edge's attributes using the given function.
         *
         * @param {function}  updater - Updater function to use.
         * @param {object}    [hints] - Optional hints.
         */
        updateEachEdgeAttributes(updater, hints) {
          if (typeof updater !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.updateEachEdgeAttributes: expecting an updater function."
            );
          if (hints && !validateHints(hints))
            throw new InvalidArgumentsGraphError(
              "Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}"
            );
          const iterator = this._edges.values();
          let step, edgeData, sourceData, targetData;
          while (step = iterator.next(), step.done !== true) {
            edgeData = step.value;
            sourceData = edgeData.source;
            targetData = edgeData.target;
            edgeData.attributes = updater(
              edgeData.key,
              edgeData.attributes,
              sourceData.key,
              targetData.key,
              sourceData.attributes,
              targetData.attributes,
              edgeData.undirected
            );
          }
          this.emit("eachEdgeAttributesUpdated", {
            hints: hints ? hints : null
          });
        }
        /**---------------------------------------------------------------------------
         * Iteration-related methods
         **---------------------------------------------------------------------------
         */
        /**
         * Method iterating over the graph's adjacency using the given callback.
         *
         * @param  {function}  callback - Callback to use.
         */
        forEachAdjacencyEntry(callback) {
          if (typeof callback !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.forEachAdjacencyEntry: expecting a callback."
            );
          forEachAdjacency(false, false, false, this, callback);
        }
        forEachAdjacencyEntryWithOrphans(callback) {
          if (typeof callback !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.forEachAdjacencyEntryWithOrphans: expecting a callback."
            );
          forEachAdjacency(false, false, true, this, callback);
        }
        /**
         * Method iterating over the graph's assymetric adjacency using the given callback.
         *
         * @param  {function}  callback - Callback to use.
         */
        forEachAssymetricAdjacencyEntry(callback) {
          if (typeof callback !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.forEachAssymetricAdjacencyEntry: expecting a callback."
            );
          forEachAdjacency(false, true, false, this, callback);
        }
        forEachAssymetricAdjacencyEntryWithOrphans(callback) {
          if (typeof callback !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback."
            );
          forEachAdjacency(false, true, true, this, callback);
        }
        /**
         * Method returning the list of the graph's nodes.
         *
         * @return {array} - The nodes.
         */
        nodes() {
          if (typeof Array.from === "function")
            return Array.from(this._nodes.keys());
          return (0, import_take.default)(this._nodes.keys(), this._nodes.size);
        }
        /**
         * Method iterating over the graph's nodes using the given callback.
         *
         * @param  {function}  callback - Callback (key, attributes, index).
         */
        forEachNode(callback) {
          if (typeof callback !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.forEachNode: expecting a callback."
            );
          const iterator = this._nodes.values();
          let step, nodeData;
          while (step = iterator.next(), step.done !== true) {
            nodeData = step.value;
            callback(nodeData.key, nodeData.attributes);
          }
        }
        /**
         * Method iterating attempting to find a node matching the given predicate
         * function.
         *
         * @param  {function}  callback - Callback (key, attributes).
         */
        findNode(callback) {
          if (typeof callback !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.findNode: expecting a callback."
            );
          const iterator = this._nodes.values();
          let step, nodeData;
          while (step = iterator.next(), step.done !== true) {
            nodeData = step.value;
            if (callback(nodeData.key, nodeData.attributes))
              return nodeData.key;
          }
          return;
        }
        /**
         * Method mapping nodes.
         *
         * @param  {function}  callback - Callback (key, attributes).
         */
        mapNodes(callback) {
          if (typeof callback !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.mapNode: expecting a callback."
            );
          const iterator = this._nodes.values();
          let step, nodeData;
          const result = new Array(this.order);
          let i2 = 0;
          while (step = iterator.next(), step.done !== true) {
            nodeData = step.value;
            result[i2++] = callback(nodeData.key, nodeData.attributes);
          }
          return result;
        }
        /**
         * Method returning whether some node verify the given predicate.
         *
         * @param  {function}  callback - Callback (key, attributes).
         */
        someNode(callback) {
          if (typeof callback !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.someNode: expecting a callback."
            );
          const iterator = this._nodes.values();
          let step, nodeData;
          while (step = iterator.next(), step.done !== true) {
            nodeData = step.value;
            if (callback(nodeData.key, nodeData.attributes))
              return true;
          }
          return false;
        }
        /**
         * Method returning whether all node verify the given predicate.
         *
         * @param  {function}  callback - Callback (key, attributes).
         */
        everyNode(callback) {
          if (typeof callback !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.everyNode: expecting a callback."
            );
          const iterator = this._nodes.values();
          let step, nodeData;
          while (step = iterator.next(), step.done !== true) {
            nodeData = step.value;
            if (!callback(nodeData.key, nodeData.attributes))
              return false;
          }
          return true;
        }
        /**
         * Method filtering nodes.
         *
         * @param  {function}  callback - Callback (key, attributes).
         */
        filterNodes(callback) {
          if (typeof callback !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.filterNodes: expecting a callback."
            );
          const iterator = this._nodes.values();
          let step, nodeData;
          const result = [];
          while (step = iterator.next(), step.done !== true) {
            nodeData = step.value;
            if (callback(nodeData.key, nodeData.attributes))
              result.push(nodeData.key);
          }
          return result;
        }
        /**
         * Method reducing nodes.
         *
         * @param  {function}  callback - Callback (accumulator, key, attributes).
         */
        reduceNodes(callback, initialValue) {
          if (typeof callback !== "function")
            throw new InvalidArgumentsGraphError(
              "Graph.reduceNodes: expecting a callback."
            );
          if (arguments.length < 2)
            throw new InvalidArgumentsGraphError(
              "Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."
            );
          let accumulator = initialValue;
          const iterator = this._nodes.values();
          let step, nodeData;
          while (step = iterator.next(), step.done !== true) {
            nodeData = step.value;
            accumulator = callback(accumulator, nodeData.key, nodeData.attributes);
          }
          return accumulator;
        }
        /**
         * Method returning an iterator over the graph's node entries.
         *
         * @return {Iterator}
         */
        nodeEntries() {
          const iterator = this._nodes.values();
          return new import_iterator.default(() => {
            const step = iterator.next();
            if (step.done)
              return step;
            const data = step.value;
            return {
              value: { node: data.key, attributes: data.attributes },
              done: false
            };
          });
        }
        /**---------------------------------------------------------------------------
         * Serialization
         **---------------------------------------------------------------------------
         */
        /**
         * Method used to export the whole graph.
         *
         * @return {object} - The serialized graph.
         */
        export() {
          const nodes = new Array(this._nodes.size);
          let i2 = 0;
          this._nodes.forEach((data, key) => {
            nodes[i2++] = serializeNode(key, data);
          });
          const edges = new Array(this._edges.size);
          i2 = 0;
          this._edges.forEach((data, key) => {
            edges[i2++] = serializeEdge(this.type, key, data);
          });
          return {
            options: {
              type: this.type,
              multi: this.multi,
              allowSelfLoops: this.allowSelfLoops
            },
            attributes: this.getAttributes(),
            nodes,
            edges
          };
        }
        /**
         * Method used to import a serialized graph.
         *
         * @param  {object|Graph} data  - The serialized graph.
         * @param  {boolean}      merge - Whether to merge data.
         * @return {Graph}              - Returns itself for chaining.
         */
        import(data, merge = false) {
          if (data instanceof _Graph) {
            data.forEachNode((n2, a2) => {
              if (merge)
                this.mergeNode(n2, a2);
              else
                this.addNode(n2, a2);
            });
            data.forEachEdge((e2, a2, s2, t2, _sa, _ta, u2) => {
              if (merge) {
                if (u2)
                  this.mergeUndirectedEdgeWithKey(e2, s2, t2, a2);
                else
                  this.mergeDirectedEdgeWithKey(e2, s2, t2, a2);
              } else {
                if (u2)
                  this.addUndirectedEdgeWithKey(e2, s2, t2, a2);
                else
                  this.addDirectedEdgeWithKey(e2, s2, t2, a2);
              }
            });
            return this;
          }
          if (!isPlainObject(data))
            throw new InvalidArgumentsGraphError(
              "Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance."
            );
          if (data.attributes) {
            if (!isPlainObject(data.attributes))
              throw new InvalidArgumentsGraphError(
                "Graph.import: invalid attributes. Expecting a plain object."
              );
            if (merge)
              this.mergeAttributes(data.attributes);
            else
              this.replaceAttributes(data.attributes);
          }
          let i2, l2, list, node, edge;
          if (data.nodes) {
            list = data.nodes;
            if (!Array.isArray(list))
              throw new InvalidArgumentsGraphError(
                "Graph.import: invalid nodes. Expecting an array."
              );
            for (i2 = 0, l2 = list.length; i2 < l2; i2++) {
              node = list[i2];
              validateSerializedNode(node);
              const { key, attributes } = node;
              if (merge)
                this.mergeNode(key, attributes);
              else
                this.addNode(key, attributes);
            }
          }
          if (data.edges) {
            let undirectedByDefault = false;
            if (this.type === "undirected") {
              undirectedByDefault = true;
            }
            list = data.edges;
            if (!Array.isArray(list))
              throw new InvalidArgumentsGraphError(
                "Graph.import: invalid edges. Expecting an array."
              );
            for (i2 = 0, l2 = list.length; i2 < l2; i2++) {
              edge = list[i2];
              validateSerializedEdge(edge);
              const {
                source,
                target,
                attributes,
                undirected = undirectedByDefault
              } = edge;
              let method;
              if ("key" in edge) {
                method = merge ? undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey;
                method.call(this, edge.key, source, target, attributes);
              } else {
                method = merge ? undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge : undirected ? this.addUndirectedEdge : this.addDirectedEdge;
                method.call(this, source, target, attributes);
              }
            }
          }
          return this;
        }
        /**---------------------------------------------------------------------------
         * Utils
         **---------------------------------------------------------------------------
         */
        /**
         * Method returning a null copy of the graph, i.e. a graph without nodes
         * & edges but with the exact same options.
         *
         * @param  {object} options - Options to merge with the current ones.
         * @return {Graph}          - The null copy.
         */
        nullCopy(options) {
          const graph = new _Graph(assign({}, this._options, options));
          graph.replaceAttributes(assign({}, this.getAttributes()));
          return graph;
        }
        /**
         * Method returning an empty copy of the graph, i.e. a graph without edges but
         * with the exact same options.
         *
         * @param  {object} options - Options to merge with the current ones.
         * @return {Graph}          - The empty copy.
         */
        emptyCopy(options) {
          const graph = this.nullCopy(options);
          this._nodes.forEach((nodeData, key) => {
            const attributes = assign({}, nodeData.attributes);
            nodeData = new graph.NodeDataClass(key, attributes);
            graph._nodes.set(key, nodeData);
          });
          return graph;
        }
        /**
         * Method returning an exact copy of the graph.
         *
         * @param  {object} options - Upgrade options.
         * @return {Graph}          - The copy.
         */
        copy(options) {
          options = options || {};
          if (typeof options.type === "string" && options.type !== this.type && options.type !== "mixed")
            throw new UsageGraphError(
              `Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${options.type}" because this would mean losing information about the current graph.`
            );
          if (typeof options.multi === "boolean" && options.multi !== this.multi && options.multi !== true)
            throw new UsageGraphError(
              "Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph."
            );
          if (typeof options.allowSelfLoops === "boolean" && options.allowSelfLoops !== this.allowSelfLoops && options.allowSelfLoops !== true)
            throw new UsageGraphError(
              "Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph."
            );
          const graph = this.emptyCopy(options);
          const iterator = this._edges.values();
          let step, edgeData;
          while (step = iterator.next(), step.done !== true) {
            edgeData = step.value;
            addEdge(
              graph,
              "copy",
              false,
              edgeData.undirected,
              edgeData.key,
              edgeData.source.key,
              edgeData.target.key,
              assign({}, edgeData.attributes)
            );
          }
          return graph;
        }
        /**---------------------------------------------------------------------------
         * Known methods
         **---------------------------------------------------------------------------
         */
        /**
         * Method used by JavaScript to perform JSON serialization.
         *
         * @return {object} - The serialized graph.
         */
        toJSON() {
          return this.export();
        }
        /**
         * Method returning [object Graph].
         */
        toString() {
          return "[object Graph]";
        }
        /**
         * Method used internally by node's console to display a custom object.
         *
         * @return {object} - Formatted object representation of the graph.
         */
        inspect() {
          const nodes = {};
          this._nodes.forEach((data, key) => {
            nodes[key] = data.attributes;
          });
          const edges = {}, multiIndex = {};
          this._edges.forEach((data, key) => {
            const direction = data.undirected ? "--" : "->";
            let label = "";
            let source = data.source.key;
            let target = data.target.key;
            let tmp;
            if (data.undirected && source > target) {
              tmp = source;
              source = target;
              target = tmp;
            }
            const desc = `(${source})${direction}(${target})`;
            if (!key.startsWith("geid_")) {
              label += `[${key}]: `;
            } else if (this.multi) {
              if (typeof multiIndex[desc] === "undefined") {
                multiIndex[desc] = 0;
              } else {
                multiIndex[desc]++;
              }
              label += `${multiIndex[desc]}. `;
            }
            label += desc;
            edges[label] = data.attributes;
          });
          const dummy = {};
          for (const k in this) {
            if (this.hasOwnProperty(k) && !EMITTER_PROPS.has(k) && typeof this[k] !== "function" && typeof k !== "symbol")
              dummy[k] = this[k];
          }
          dummy.attributes = this._attributes;
          dummy.nodes = nodes;
          dummy.edges = edges;
          privateProperty(dummy, "constructor", this.constructor);
          return dummy;
        }
      };
      if (typeof Symbol !== "undefined")
        Graph.prototype[Symbol.for("nodejs.util.inspect.custom")] = Graph.prototype.inspect;
      EDGE_ADD_METHODS.forEach((method) => {
        ["add", "merge", "update"].forEach((verb) => {
          const name2 = method.name(verb);
          const fn = verb === "add" ? addEdge : mergeEdge;
          if (method.generateKey) {
            Graph.prototype[name2] = function(source, target, attributes) {
              return fn(
                this,
                name2,
                true,
                (method.type || this.type) === "undirected",
                null,
                source,
                target,
                attributes,
                verb === "update"
              );
            };
          } else {
            Graph.prototype[name2] = function(edge, source, target, attributes) {
              return fn(
                this,
                name2,
                false,
                (method.type || this.type) === "undirected",
                edge,
                source,
                target,
                attributes,
                verb === "update"
              );
            };
          }
        });
      });
      attachNodeAttributesMethods(Graph);
      attachEdgeAttributesMethods(Graph);
      attachEdgeIterationMethods(Graph);
      attachNeighborIterationMethods(Graph);
      DirectedGraph = class extends Graph {
        constructor(options) {
          const finalOptions = assign({ type: "directed" }, options);
          if ("multi" in finalOptions && finalOptions.multi !== false)
            throw new InvalidArgumentsGraphError(
              "DirectedGraph.from: inconsistent indication that the graph should be multi in given options!"
            );
          if (finalOptions.type !== "directed")
            throw new InvalidArgumentsGraphError(
              'DirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!'
            );
          super(finalOptions);
        }
      };
      UndirectedGraph = class extends Graph {
        constructor(options) {
          const finalOptions = assign({ type: "undirected" }, options);
          if ("multi" in finalOptions && finalOptions.multi !== false)
            throw new InvalidArgumentsGraphError(
              "UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!"
            );
          if (finalOptions.type !== "undirected")
            throw new InvalidArgumentsGraphError(
              'UndirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!'
            );
          super(finalOptions);
        }
      };
      MultiGraph = class extends Graph {
        constructor(options) {
          const finalOptions = assign({ multi: true }, options);
          if ("multi" in finalOptions && finalOptions.multi !== true)
            throw new InvalidArgumentsGraphError(
              "MultiGraph.from: inconsistent indication that the graph should be simple in given options!"
            );
          super(finalOptions);
        }
      };
      MultiDirectedGraph = class extends Graph {
        constructor(options) {
          const finalOptions = assign({ type: "directed", multi: true }, options);
          if ("multi" in finalOptions && finalOptions.multi !== true)
            throw new InvalidArgumentsGraphError(
              "MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!"
            );
          if (finalOptions.type !== "directed")
            throw new InvalidArgumentsGraphError(
              'MultiDirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!'
            );
          super(finalOptions);
        }
      };
      MultiUndirectedGraph = class extends Graph {
        constructor(options) {
          const finalOptions = assign({ type: "undirected", multi: true }, options);
          if ("multi" in finalOptions && finalOptions.multi !== true)
            throw new InvalidArgumentsGraphError(
              "MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!"
            );
          if (finalOptions.type !== "undirected")
            throw new InvalidArgumentsGraphError(
              'MultiUndirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!'
            );
          super(finalOptions);
        }
      };
      attachStaticFromMethod(Graph);
      attachStaticFromMethod(DirectedGraph);
      attachStaticFromMethod(UndirectedGraph);
      attachStaticFromMethod(MultiGraph);
      attachStaticFromMethod(MultiDirectedGraph);
      attachStaticFromMethod(MultiUndirectedGraph);
      Graph.Graph = Graph;
      Graph.DirectedGraph = DirectedGraph;
      Graph.UndirectedGraph = UndirectedGraph;
      Graph.MultiGraph = MultiGraph;
      Graph.MultiDirectedGraph = MultiDirectedGraph;
      Graph.MultiUndirectedGraph = MultiUndirectedGraph;
      Graph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;
      Graph.NotFoundGraphError = NotFoundGraphError;
      Graph.UsageGraphError = UsageGraphError;
    }
  });

  // ../../composition/dist/subgraph/subgraph.js
  var require_subgraph = __commonJS({
    "../../composition/dist/subgraph/subgraph.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.walkSubgraphToFederate = exports2.walkSubgraphToCollectFields = exports2.walkSubgraphToCollectObjectLikesAndDirectiveDefinitions = exports2.validateSubgraphName = void 0;
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var utils_1 = require_utils3();
      var type_merging_1 = require_type_merging();
      var utils_2 = require_utils();
      var string_constants_1 = require_string_constants();
      function validateSubgraphName(subgraphName, subgraphNames, nonUniqueSubgraphNames) {
        if (!subgraphNames.has(subgraphName)) {
          subgraphNames.add(subgraphName);
          return;
        }
        nonUniqueSubgraphNames.add(subgraphName);
      }
      exports2.validateSubgraphName = validateSubgraphName;
      function walkSubgraphToCollectObjectLikesAndDirectiveDefinitions(factory, subgraph) {
        subgraph.definitions = (0, graphql_1.visit)(subgraph.definitions, {
          DirectiveDefinition: {
            enter(node) {
              factory.upsertDirectiveNode(node);
            }
          },
          InterfaceTypeDefinition: {
            enter(node) {
              factory.upsertParentNode(node);
            }
          },
          ObjectTypeDefinition: {
            enter(node) {
              const name2 = node.name.value;
              const operationType = subgraph.operationTypes.get(name2);
              const parentTypeName = operationType ? (0, utils_2.getOrThrowError)(utils_1.operationTypeNodeToDefaultType, operationType, string_constants_1.OPERATION_TO_DEFAULT) : name2;
              (0, utils_1.addConcreteTypesForImplementedInterfaces)(node, factory.abstractToConcreteTypeNames);
              if (!factory.graph.hasNode(parentTypeName)) {
                factory.graph.addNode(parentTypeName);
              }
              if ((0, utils_1.isObjectLikeNodeEntity)(node)) {
                factory.upsertEntity(node);
              }
              if (name2 !== parentTypeName) {
                return __spreadProps(__spreadValues({}, node), {
                  name: (0, utils_1.stringToNameNode)(parentTypeName)
                });
              }
              return false;
            }
          },
          ObjectTypeExtension: {
            enter(node) {
              const name2 = node.name.value;
              const operationType = subgraph.operationTypes.get(name2);
              const parentTypeName = operationType ? (0, utils_2.getOrThrowError)(utils_1.operationTypeNodeToDefaultType, operationType, string_constants_1.OPERATION_TO_DEFAULT) : name2;
              (0, utils_1.addConcreteTypesForImplementedInterfaces)(node, factory.abstractToConcreteTypeNames);
              if (!factory.graph.hasNode(parentTypeName)) {
                factory.graph.addNode(parentTypeName);
              }
              if (name2 !== parentTypeName) {
                return __spreadProps(__spreadValues({}, node), {
                  name: (0, utils_1.stringToNameNode)(parentTypeName)
                });
              }
              if ((0, utils_1.isObjectLikeNodeEntity)(node)) {
                factory.upsertEntity(node);
              }
              return false;
            }
          },
          UnionTypeDefinition: {
            enter(node) {
              factory.upsertParentNode(node);
              (0, utils_1.addConcreteTypesForUnion)(node, factory.abstractToConcreteTypeNames);
            }
          }
        });
      }
      exports2.walkSubgraphToCollectObjectLikesAndDirectiveDefinitions = walkSubgraphToCollectObjectLikesAndDirectiveDefinitions;
      function walkSubgraphToCollectFields(factory, subgraph) {
        let isCurrentParentRootType = false;
        (0, graphql_1.visit)(subgraph.definitions, {
          ObjectTypeDefinition: {
            enter(node) {
              isCurrentParentRootType = factory.isObjectRootType(node);
              factory.isCurrentParentEntity = (0, utils_1.isObjectLikeNodeEntity)(node);
              factory.parentTypeName = node.name.value;
            },
            leave() {
              isCurrentParentRootType = false;
              factory.parentTypeName = "";
              factory.isCurrentParentEntity = false;
            }
          },
          ObjectTypeExtension: {
            enter(node) {
              factory.isCurrentParentEntity = (0, utils_1.isObjectLikeNodeEntity)(node);
              factory.parentTypeName = node.name.value;
            },
            leave() {
              factory.isCurrentParentEntity = false;
              factory.parentTypeName = "";
            }
          },
          FieldDefinition: {
            enter(node) {
              const fieldName = node.name.value;
              if (factory.isCurrentParentEntity) {
                const entity = (0, utils_2.getOrThrowError)(factory.entities, factory.parentTypeName, string_constants_1.ENTITIES);
                entity.fields.add(fieldName);
              }
              return false;
            }
          },
          InterfaceTypeDefinition: {
            enter() {
              return false;
            }
          }
        });
      }
      exports2.walkSubgraphToCollectFields = walkSubgraphToCollectFields;
      function walkSubgraphToFederate(subgraph, factory) {
        (0, graphql_1.visit)(subgraph, {
          Directive: {
            enter() {
              return false;
            }
          },
          EnumTypeDefinition: {
            enter(node) {
              factory.parentTypeName = node.name.value;
              factory.upsertParentNode(node);
            },
            leave() {
              factory.parentTypeName = "";
            }
          },
          EnumValueDefinition: {
            enter(node) {
              factory.childName = node.name.value;
              factory.upsertValueNode(node);
            },
            leave() {
              factory.childName = "";
            }
          },
          FieldDefinition: {
            enter(node) {
              const fieldName = node.name.value;
              const fieldPath = `${factory.parentTypeName}.${fieldName}`;
              const fieldNamedTypeName = (0, type_merging_1.getNamedTypeForChild)(fieldPath, node.type);
              if (factory.isParentRootType && (fieldName === string_constants_1.SERVICE_FIELD || fieldName === string_constants_1.ENTITIES_FIELD)) {
                return false;
              }
              factory.childName = fieldName;
              factory.upsertFieldNode(node);
              if (!factory.graph.hasNode(factory.parentTypeName) || factory.graphEdges.has(fieldPath)) {
                return;
              }
              factory.graphEdges.add(fieldPath);
              const entity = factory.entities.get(factory.parentTypeName);
              if (entity && !entity.fields.has(fieldName)) {
                return;
              }
              const concreteTypeNames = factory.abstractToConcreteTypeNames.get(fieldNamedTypeName);
              if (concreteTypeNames) {
                for (const concreteTypeName of concreteTypeNames) {
                  factory.graph.addEdge(factory.parentTypeName, concreteTypeName);
                }
              }
              if (!factory.graph.hasNode(fieldNamedTypeName)) {
                return;
              }
              factory.graph.addEdge(factory.parentTypeName, fieldNamedTypeName);
            },
            leave() {
              factory.childName = "";
            }
          },
          InputObjectTypeDefinition: {
            enter(node) {
              factory.parentTypeName = node.name.value;
              factory.isParentInputObject = true;
              factory.upsertParentNode(node);
            },
            leave() {
              factory.parentTypeName = "";
              factory.isParentInputObject = false;
            }
          },
          InputValueDefinition: {
            enter(node) {
              if (factory.isParentInputObject) {
                factory.childName = node.name.value;
              }
              factory.upsertValueNode(node);
            },
            leave() {
              if (factory.isParentInputObject) {
                factory.childName = "";
              }
            }
          },
          InterfaceTypeDefinition: {
            enter(node) {
              factory.parentTypeName = node.name.value;
              factory.isCurrentParentInterface = true;
              factory.upsertParentNode(node);
            },
            leave() {
              factory.parentTypeName = "";
              factory.isCurrentParentInterface = false;
            }
          },
          ObjectTypeDefinition: {
            enter(node) {
              factory.areFieldsExternal = (0, utils_1.isNodeExternal)(node);
              factory.areFieldsShareable = !factory.isCurrentSubgraphVersionTwo || (0, utils_1.isNodeShareable)(node);
              factory.isCurrentParentEntity = (0, utils_1.isObjectLikeNodeEntity)(node);
              factory.isParentRootType = factory.isObjectRootType(node);
              factory.parentTypeName = node.name.value;
              factory.upsertParentNode(node);
            },
            leave() {
              factory.areFieldsExternal = false;
              factory.areFieldsShareable = false;
              factory.isCurrentParentEntity = false;
              factory.isParentRootType = false;
              factory.parentTypeName = "";
            }
          },
          ObjectTypeExtension: {
            enter(node) {
              const name2 = node.name.value;
              factory.areFieldsExternal = (0, utils_1.isNodeExternal)(node);
              factory.areFieldsShareable = !factory.isCurrentSubgraphVersionTwo || (0, utils_1.isNodeShareable)(node);
              factory.isCurrentParentExtensionType = true;
              factory.isCurrentParentEntity = (0, utils_1.isObjectLikeNodeEntity)(node);
              factory.parentTypeName = name2;
              factory.isParentRootType = factory.isObjectRootType(node);
              factory.upsertExtensionNode(node);
            },
            leave() {
              factory.areFieldsExternal = false;
              factory.areFieldsShareable = false;
              factory.isCurrentParentEntity = false;
              factory.isCurrentParentExtensionType = false;
              factory.parentTypeName = "";
              factory.isParentRootType = false;
            }
          },
          ScalarTypeDefinition: {
            enter(node) {
              factory.upsertParentNode(node);
            }
          }
        });
      }
      exports2.walkSubgraphToFederate = walkSubgraphToFederate;
    }
  });

  // ../../composition/dist/federation/federation-factory.js
  var require_federation_factory = __commonJS({
    "../../composition/dist/federation/federation-factory.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.federateSubgraphs = exports2.FederationFactory = void 0;
      var graphology_1 = (init_graphology_esm(), __toCommonJS(graphology_esm_exports));
      var graphql_1 = (init_graphql2(), __toCommonJS(graphql_exports));
      var ast_1 = require_ast();
      var utils_1 = require_utils3();
      var errors_1 = require_errors();
      var type_merging_1 = require_type_merging();
      var utils_2 = require_utils2();
      var subgraph_1 = require_subgraph();
      var string_constants_1 = require_string_constants();
      var utils_3 = require_utils();
      var merge_1 = require_cjs2();
      var constants_1 = require_constants();
      var normalization_factory_1 = require_normalization_factory();
      var FederationFactory = class {
        constructor(subgraphs) {
          __publicField(this, "abstractToConcreteTypeNames", /* @__PURE__ */ new Map());
          __publicField(this, "areFieldsExternal", false);
          __publicField(this, "areFieldsShareable", false);
          __publicField(this, "argumentTypeNameSet", /* @__PURE__ */ new Set());
          __publicField(this, "argumentConfigurations", []);
          __publicField(this, "executableDirectives", /* @__PURE__ */ new Set());
          __publicField(this, "parentTypeName", "");
          __publicField(this, "persistedDirectives", /* @__PURE__ */ new Set([string_constants_1.DEPRECATED, string_constants_1.INACCESSIBLE, string_constants_1.TAG]));
          __publicField(this, "currentSubgraphName", "");
          __publicField(this, "childName", "");
          __publicField(this, "directiveDefinitions", /* @__PURE__ */ new Map());
          __publicField(this, "entities", /* @__PURE__ */ new Map());
          __publicField(this, "errors", []);
          __publicField(this, "extensions", /* @__PURE__ */ new Map());
          __publicField(this, "graph", new graphology_1.MultiGraph());
          __publicField(this, "graphEdges", /* @__PURE__ */ new Set());
          __publicField(this, "graphPaths", /* @__PURE__ */ new Map());
          __publicField(this, "inputFieldTypeNameSet", /* @__PURE__ */ new Set());
          __publicField(this, "isCurrentParentEntity", false);
          __publicField(this, "isCurrentParentInterface", false);
          __publicField(this, "isCurrentSubgraphVersionTwo", false);
          __publicField(this, "isCurrentParentExtensionType", false);
          __publicField(this, "isParentRootType", false);
          __publicField(this, "isParentInputObject", false);
          __publicField(this, "keyFieldsByParentTypeName", /* @__PURE__ */ new Map());
          __publicField(this, "outputFieldTypeNameSet", /* @__PURE__ */ new Set());
          __publicField(this, "parents", /* @__PURE__ */ new Map());
          __publicField(this, "rootTypeNames", /* @__PURE__ */ new Set([string_constants_1.DEFAULT_MUTATION, string_constants_1.DEFAULT_QUERY, string_constants_1.DEFAULT_SUBSCRIPTION]));
          __publicField(this, "subgraphs", []);
          __publicField(this, "shareableErrorTypeNames", /* @__PURE__ */ new Map());
          __publicField(this, "evaluatedObjectLikesBySubgraph", /* @__PURE__ */ new Map());
          this.subgraphs = subgraphs;
        }
        isObjectRootType(node) {
          return this.rootTypeNames.has(node.name.value);
        }
        upsertEntity(node) {
          const typeName = node.name.value;
          const entity = this.entities.get(typeName);
          if (entity) {
            (0, utils_1.extractEntityKeys)(node, entity.keys, this.errors);
            entity.subgraphs.add(this.currentSubgraphName);
            return;
          }
          this.entities.set(typeName, {
            fields: /* @__PURE__ */ new Set(),
            keys: (0, utils_1.extractEntityKeys)(node, /* @__PURE__ */ new Set(), this.errors),
            subgraphs: /* @__PURE__ */ new Set([this.currentSubgraphName])
          });
        }
        populateMultiGraphAndRenameOperations(subgraphs) {
          for (const subgraph of subgraphs) {
            this.currentSubgraphName = subgraph.name;
            (0, subgraph_1.walkSubgraphToCollectObjectLikesAndDirectiveDefinitions)(this, subgraph);
            (0, subgraph_1.walkSubgraphToCollectFields)(this, subgraph);
          }
        }
        getEnumMergeMethod(enumName) {
          if (this.inputFieldTypeNameSet.has(enumName) || this.argumentTypeNameSet.has(enumName)) {
            if (this.outputFieldTypeNameSet.has(enumName)) {
              return utils_2.MergeMethod.CONSISTENT;
            }
            return utils_2.MergeMethod.INTERSECTION;
          }
          return utils_2.MergeMethod.UNION;
        }
        validateArgumentDefaultValues(argName, existingDefaultValue, newDefaultValue) {
          if (existingDefaultValue.kind !== newDefaultValue.kind) {
            this.errors.push((0, errors_1.incompatibleArgumentDefaultValueTypeError)(argName, this.parentTypeName, this.childName, existingDefaultValue.kind, newDefaultValue.kind));
          }
          if ("value" in newDefaultValue && existingDefaultValue.value !== newDefaultValue.value) {
            this.errors.push((0, errors_1.incompatibleArgumentDefaultValueError)(argName, this.parentTypeName, this.childName, existingDefaultValue.value, newDefaultValue.value));
          }
        }
        compareAndValidateArgumentDefaultValues(existingArg, newArg) {
          const newDefaultValue = newArg.defaultValue;
          existingArg.node.defaultValue = existingArg.node.defaultValue || newDefaultValue;
          if (!existingArg.node.defaultValue || !newDefaultValue) {
            existingArg.includeDefaultValue = false;
            return;
          }
          const argumentName = existingArg.node.name.value;
          const existingDefaultValue = existingArg.node.defaultValue;
          switch (existingDefaultValue.kind) {
            case graphql_1.Kind.LIST:
              break;
            case graphql_1.Kind.NULL:
              break;
            case graphql_1.Kind.OBJECT:
              break;
            case graphql_1.Kind.BOOLEAN:
            case graphql_1.Kind.ENUM:
            case graphql_1.Kind.FLOAT:
            case graphql_1.Kind.INT:
            case graphql_1.Kind.STRING:
              this.validateArgumentDefaultValues(argumentName, existingDefaultValue, newDefaultValue);
              break;
            default:
              throw (0, errors_1.unexpectedArgumentKindFatalError)(argumentName, this.childName);
          }
        }
        upsertRequiredSubgraph(set, isRequired) {
          if (isRequired) {
            set.add(this.currentSubgraphName);
          }
          return set;
        }
        // TODO validation of default values
        upsertArguments(node, argumentMap) {
          if (!node.arguments) {
            return argumentMap;
          }
          for (const argumentNode of node.arguments) {
            const argName = argumentNode.name.value;
            const argPath = `${node.name.value}(${argName}...)`;
            this.argumentTypeNameSet.add((0, type_merging_1.getNamedTypeForChild)(argPath, argumentNode.type));
            const isRequired = (0, type_merging_1.isTypeRequired)(argumentNode.type);
            const existingArgumentContainer = argumentMap.get(argName);
            if (!existingArgumentContainer) {
              argumentMap.set(argName, {
                directives: this.extractPersistedDirectives(argumentNode.directives || [], (0, utils_2.newPersistedDirectivesContainer)()),
                includeDefaultValue: !!argumentNode.defaultValue,
                node: (0, ast_1.inputValueDefinitionNodeToMutable)(argumentNode, this.childName),
                requiredSubgraphs: this.upsertRequiredSubgraph(/* @__PURE__ */ new Set(), isRequired),
                subgraphs: /* @__PURE__ */ new Set([this.currentSubgraphName])
              });
              continue;
            }
            this.extractPersistedDirectives(argumentNode.directives || [], existingArgumentContainer.directives);
            (0, utils_1.setLongestDescriptionForNode)(existingArgumentContainer.node, argumentNode.description);
            this.upsertRequiredSubgraph(existingArgumentContainer.requiredSubgraphs, isRequired);
            existingArgumentContainer.subgraphs.add(this.currentSubgraphName);
            const { typeErrors, typeNode } = (0, type_merging_1.getMostRestrictiveMergedTypeNode)(existingArgumentContainer.node.type, argumentNode.type, this.childName, argName);
            if (typeNode) {
              existingArgumentContainer.node.type = typeNode;
            } else {
              if (!typeErrors || typeErrors.length < 2) {
                throw (0, errors_1.argumentTypeMergeFatalError)(argName, this.childName);
              }
              this.errors.push((0, errors_1.incompatibleArgumentTypesError)(argName, this.parentTypeName, this.childName, typeErrors[0], typeErrors[1]));
            }
            this.compareAndValidateArgumentDefaultValues(existingArgumentContainer, argumentNode);
          }
          return argumentMap;
        }
        isFieldEntityKey() {
          const parent = this.keyFieldsByParentTypeName.get(this.parentTypeName);
          if (parent) {
            return parent.has(this.childName);
          }
          return false;
        }
        isFieldExternal(node) {
          return this.areFieldsExternal || (0, utils_1.isNodeExternal)(node);
        }
        isFieldShareable(node, parent) {
          return !this.isCurrentSubgraphVersionTwo || this.areFieldsShareable || this.isFieldEntityKey() || (0, utils_1.isNodeShareable)(node) || (0, utils_1.isNodeOverridden)(node);
        }
        upsertDirectiveNode(node) {
          const directiveName = node.name.value;
          const directiveDefinition = this.directiveDefinitions.get(directiveName);
          if (directiveDefinition) {
            if (!this.executableDirectives.has(directiveName)) {
              return;
            }
            if ((0, utils_1.mergeExecutableDirectiveLocations)(node.locations, directiveDefinition).size < 1) {
              this.executableDirectives.delete(directiveName);
              return;
            }
            this.upsertArguments(node, directiveDefinition.arguments);
            (0, utils_1.setLongestDescriptionForNode)(directiveDefinition.node, node.description);
            directiveDefinition.node.repeatable = directiveDefinition.node.repeatable && node.repeatable;
            directiveDefinition.subgraphs.add(this.currentSubgraphName);
            return;
          }
          const executableLocations = (0, utils_1.extractExecutableDirectiveLocations)(node.locations, /* @__PURE__ */ new Set());
          this.directiveDefinitions.set(directiveName, {
            arguments: this.upsertArguments(node, /* @__PURE__ */ new Map()),
            executableLocations,
            node: (0, ast_1.directiveDefinitionNodeToMutable)(node),
            subgraphs: /* @__PURE__ */ new Set([this.currentSubgraphName])
          });
          if (executableLocations.size > 0) {
            this.executableDirectives.add(directiveName);
          }
        }
        areAllFieldInstancesExternalOrShareable(fieldContainer) {
          let shareableFields = 0;
          let unshareableFields = 0;
          for (const [subgraphName, isShareable] of fieldContainer.subgraphsByShareable) {
            if (isShareable) {
              shareableFields += 1;
              if (shareableFields && unshareableFields) {
                return false;
              }
              continue;
            }
            if (fieldContainer.subgraphsByExternal.get(subgraphName)) {
              continue;
            }
            unshareableFields += 1;
            if (shareableFields || unshareableFields > 1) {
              return false;
            }
          }
          return true;
        }
        upsertFieldNode(node) {
          const parent = this.isCurrentParentExtensionType ? (0, utils_3.getOrThrowError)(this.extensions, this.parentTypeName, string_constants_1.EXTENSIONS) : (0, utils_3.getOrThrowError)(this.parents, this.parentTypeName, string_constants_1.PARENTS);
          if (parent.kind !== graphql_1.Kind.OBJECT_TYPE_DEFINITION && parent.kind !== graphql_1.Kind.INTERFACE_TYPE_DEFINITION && parent.kind !== graphql_1.Kind.OBJECT_TYPE_EXTENSION) {
            throw (0, errors_1.unexpectedKindFatalError)(this.parentTypeName);
          }
          const fieldMap = parent.fields;
          const isFieldExternal = this.isFieldExternal(node);
          const isFieldShareable = this.isFieldShareable(node, parent);
          const fieldPath = `${this.parentTypeName}.${this.childName}`;
          const fieldRootTypeName = (0, type_merging_1.getNamedTypeForChild)(fieldPath, node.type);
          const existingFieldContainer = fieldMap.get(this.childName);
          if (existingFieldContainer) {
            this.extractPersistedDirectives(node.directives || [], existingFieldContainer.directives);
            (0, utils_1.setLongestDescriptionForNode)(existingFieldContainer.node, node.description);
            existingFieldContainer.subgraphs.add(this.currentSubgraphName);
            existingFieldContainer.subgraphsByShareable.set(this.currentSubgraphName, isFieldShareable);
            existingFieldContainer.subgraphsByExternal.set(this.currentSubgraphName, isFieldExternal);
            const { typeErrors, typeNode } = (0, type_merging_1.getLeastRestrictiveMergedTypeNode)(existingFieldContainer.node.type, node.type, this.parentTypeName, this.childName);
            if (typeNode) {
              existingFieldContainer.node.type = typeNode;
            } else {
              if (!typeErrors || typeErrors.length < 2) {
                throw (0, errors_1.fieldTypeMergeFatalError)(this.childName);
              }
              this.errors.push((0, errors_1.incompatibleChildTypesError)(this.parentTypeName, this.childName, typeErrors[0], typeErrors[1]));
            }
            this.upsertArguments(node, existingFieldContainer.arguments);
            if (this.isCurrentParentInterface || isFieldExternal || existingFieldContainer.isShareable && isFieldShareable || this.areAllFieldInstancesExternalOrShareable(existingFieldContainer)) {
              return;
            }
            const shareableErrorTypeNames = this.shareableErrorTypeNames.get(this.parentTypeName);
            if (shareableErrorTypeNames) {
              shareableErrorTypeNames.add(this.childName);
            } else {
              this.shareableErrorTypeNames.set(this.parentTypeName, /* @__PURE__ */ new Set([this.childName]));
            }
            return;
          }
          this.outputFieldTypeNameSet.add(fieldRootTypeName);
          fieldMap.set(this.childName, {
            arguments: this.upsertArguments(node, /* @__PURE__ */ new Map()),
            directives: this.extractPersistedDirectives(node.directives || [], (0, utils_2.newPersistedDirectivesContainer)()),
            isShareable: isFieldShareable,
            node: (0, ast_1.fieldDefinitionNodeToMutable)(node, this.parentTypeName),
            namedTypeName: fieldRootTypeName,
            subgraphs: /* @__PURE__ */ new Set([this.currentSubgraphName]),
            subgraphsByShareable: /* @__PURE__ */ new Map([[this.currentSubgraphName, isFieldShareable]]),
            subgraphsByExternal: /* @__PURE__ */ new Map([[this.currentSubgraphName, isFieldExternal]])
          });
        }
        upsertValueNode(node) {
          const parent = this.parents.get(this.parentTypeName);
          switch (node.kind) {
            case graphql_1.Kind.ENUM_VALUE_DEFINITION:
              if (!parent) {
                throw (0, errors_1.federationInvalidParentTypeError)(this.parentTypeName, this.childName);
              }
              if (parent.kind !== graphql_1.Kind.ENUM_TYPE_DEFINITION) {
                throw (0, errors_1.incompatibleParentKindFatalError)(this.parentTypeName, graphql_1.Kind.ENUM_TYPE_DEFINITION, parent.kind);
              }
              const enumValues = parent.values;
              const enumValueContainer = enumValues.get(this.childName);
              if (enumValueContainer) {
                this.extractPersistedDirectives(node.directives || [], enumValueContainer.directives);
                (0, utils_1.setLongestDescriptionForNode)(enumValueContainer.node, node.description);
                enumValueContainer.appearances += 1;
                return;
              }
              enumValues.set(this.childName, {
                appearances: 1,
                directives: this.extractPersistedDirectives(node.directives || [], (0, utils_2.newPersistedDirectivesContainer)()),
                node: (0, ast_1.enumValueDefinitionNodeToMutable)(node)
              });
              return;
            case graphql_1.Kind.INPUT_VALUE_DEFINITION:
              if (!parent || !this.isParentInputObject) {
                return;
              }
              if (parent.kind !== graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION) {
                throw (0, errors_1.incompatibleParentKindFatalError)(this.parentTypeName, graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION, parent.kind);
              }
              const inputValues = parent.fields;
              const inputValueContainer = inputValues.get(this.childName);
              if (inputValueContainer) {
                this.extractPersistedDirectives(node.directives || [], inputValueContainer.directives);
                inputValueContainer.appearances += 1;
                (0, utils_1.setLongestDescriptionForNode)(inputValueContainer.node, node.description);
                const { typeErrors, typeNode } = (0, type_merging_1.getMostRestrictiveMergedTypeNode)(inputValueContainer.node.type, node.type, this.parentTypeName, this.childName);
                if (typeNode) {
                  inputValueContainer.node.type = typeNode;
                } else {
                  if (!typeErrors || typeErrors.length < 2) {
                    throw (0, errors_1.fieldTypeMergeFatalError)(this.childName);
                  }
                  this.errors.push((0, errors_1.incompatibleChildTypesError)(this.parentTypeName, this.childName, typeErrors[0], typeErrors[1]));
                }
                return;
              }
              const valuePath = `${this.parentTypeName}.${this.childName}`;
              const inputValueNamedType = (0, type_merging_1.getNamedTypeForChild)(valuePath, node.type);
              this.inputFieldTypeNameSet.add(inputValueNamedType);
              inputValues.set(this.childName, {
                appearances: 1,
                directives: this.extractPersistedDirectives(node.directives || [], (0, utils_2.newPersistedDirectivesContainer)()),
                includeDefaultValue: !!node.defaultValue,
                node: (0, ast_1.inputValueDefinitionNodeToMutable)(node, this.parentTypeName)
              });
              return;
            default:
              throw (0, errors_1.unexpectedKindFatalError)(this.childName);
          }
        }
        upsertParentNode(node) {
          var _a, _b;
          const parentTypeName = node.name.value;
          const parent = this.parents.get(parentTypeName);
          if (parent) {
            (0, utils_1.setLongestDescriptionForNode)(parent.node, node.description);
            this.extractPersistedDirectives(node.directives || [], parent.directives);
          }
          switch (node.kind) {
            case graphql_1.Kind.ENUM_TYPE_DEFINITION:
              if (parent) {
                if (parent.kind !== node.kind) {
                  throw (0, errors_1.incompatibleParentKindFatalError)(parentTypeName, node.kind, parent.kind);
                }
                parent.appearances += 1;
                return;
              }
              this.parents.set(parentTypeName, {
                appearances: 1,
                directives: this.extractPersistedDirectives(node.directives || [], (0, utils_2.newPersistedDirectivesContainer)()),
                values: /* @__PURE__ */ new Map(),
                kind: node.kind,
                node: (0, ast_1.enumTypeDefinitionNodeToMutable)(node)
              });
              return;
            case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
              if (parent) {
                if (parent.kind !== node.kind) {
                  throw (0, errors_1.incompatibleParentKindFatalError)(parentTypeName, node.kind, parent.kind);
                }
                parent.appearances += 1;
                return;
              }
              this.parents.set(parentTypeName, {
                appearances: 1,
                directives: this.extractPersistedDirectives(node.directives || [], (0, utils_2.newPersistedDirectivesContainer)()),
                fields: /* @__PURE__ */ new Map(),
                kind: node.kind,
                node: (0, ast_1.inputObjectTypeDefinitionNodeToMutable)(node)
              });
              return;
            case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              if (parent) {
                if (parent.kind !== node.kind) {
                  throw (0, errors_1.incompatibleParentKindFatalError)(parentTypeName, node.kind, parent.kind);
                }
                (0, utils_1.extractInterfaces)(node, parent.interfaces);
                parent.subgraphs.add(this.currentSubgraphName);
                return;
              }
              const nestedInterfaces = /* @__PURE__ */ new Set();
              (0, utils_1.extractInterfaces)(node, nestedInterfaces);
              this.parents.set(parentTypeName, {
                directives: this.extractPersistedDirectives(node.directives || [], (0, utils_2.newPersistedDirectivesContainer)()),
                fields: /* @__PURE__ */ new Map(),
                interfaces: nestedInterfaces,
                kind: node.kind,
                node: (0, ast_1.interfaceTypeDefinitionNodeToMutable)(node),
                subgraphs: /* @__PURE__ */ new Set([this.currentSubgraphName])
              });
              return;
            case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
              if (parent) {
                if (parent.kind !== node.kind) {
                  throw (0, errors_1.incompatibleParentKindFatalError)(parentTypeName, node.kind, parent.kind);
                }
                return;
              }
              this.parents.set(parentTypeName, {
                directives: this.extractPersistedDirectives(node.directives || [], (0, utils_2.newPersistedDirectivesContainer)()),
                kind: node.kind,
                node: (0, ast_1.scalarTypeDefinitionNodeToMutable)(node)
              });
              return;
            case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
              if (parent) {
                if (parent.kind !== node.kind) {
                  throw (0, errors_1.incompatibleParentKindFatalError)(parentTypeName, node.kind, parent.kind);
                }
                (0, utils_1.extractInterfaces)(node, parent.interfaces);
                (0, utils_1.extractEntityKeys)(node, parent.entityKeys, this.errors);
                parent.subgraphs.add(this.currentSubgraphName);
                return;
              }
              const interfaces = /* @__PURE__ */ new Set();
              (0, utils_1.extractInterfaces)(node, interfaces);
              const entityKeys = /* @__PURE__ */ new Set();
              (0, utils_1.extractEntityKeys)(node, entityKeys, this.errors);
              this.parents.set(parentTypeName, {
                directives: this.extractPersistedDirectives(node.directives || [], (0, utils_2.newPersistedDirectivesContainer)()),
                fields: /* @__PURE__ */ new Map(),
                entityKeys,
                interfaces,
                isRootType: this.isParentRootType,
                kind: node.kind,
                node: (0, ast_1.objectTypeDefinitionNodeToMutable)(node),
                subgraphs: /* @__PURE__ */ new Set([this.currentSubgraphName])
              });
              return;
            case graphql_1.Kind.UNION_TYPE_DEFINITION:
              if (parent) {
                if (parent.kind !== node.kind) {
                  throw (0, errors_1.incompatibleParentKindFatalError)(parentTypeName, node.kind, parent.kind);
                }
                if (!node.types || node.types.length < 1) {
                  this.errors.push((0, errors_1.invalidUnionError)(parent.node.name.value));
                  return;
                }
                (_a = node.types) == null ? void 0 : _a.forEach((member) => parent.members.add(member.name.value));
                return;
              }
              this.parents.set(parentTypeName, {
                directives: this.extractPersistedDirectives(node.directives || [], (0, utils_2.newPersistedDirectivesContainer)()),
                kind: node.kind,
                members: new Set((_b = node.types) == null ? void 0 : _b.map((member) => member.name.value)),
                node: (0, ast_1.unionTypeDefinitionNodeToMutable)(node)
              });
              return;
          }
        }
        upsertExtensionNode(node) {
          const extension = this.extensions.get(this.parentTypeName);
          if (extension) {
            if (extension.kind !== graphql_1.Kind.OBJECT_TYPE_EXTENSION) {
              throw (0, errors_1.incompatibleParentKindFatalError)(this.parentTypeName, graphql_1.Kind.OBJECT_TYPE_EXTENSION, extension.kind);
            }
            extension.subgraphs.add(this.currentSubgraphName);
            (0, utils_1.extractInterfaces)(node, extension.interfaces);
            this.extractPersistedDirectives(node.directives || [], extension.directives);
            return;
          }
          const interfaces = (0, utils_1.extractInterfaces)(node, /* @__PURE__ */ new Set());
          const entityKeys = (0, utils_1.extractEntityKeys)(node, /* @__PURE__ */ new Set(), this.errors);
          this.extensions.set(this.parentTypeName, {
            directives: this.extractPersistedDirectives(node.directives || [], (0, utils_2.newPersistedDirectivesContainer)()),
            entityKeys,
            fields: /* @__PURE__ */ new Map(),
            interfaces,
            isRootType: this.isParentRootType,
            kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,
            node: (0, ast_1.objectTypeExtensionNodeToMutable)(node),
            subgraphs: /* @__PURE__ */ new Set([this.currentSubgraphName])
          });
        }
        isTypeValidImplementation(originalType, implementationType) {
          if (originalType.kind === graphql_1.Kind.NON_NULL_TYPE) {
            if (implementationType.kind !== graphql_1.Kind.NON_NULL_TYPE) {
              return false;
            }
            return this.isTypeValidImplementation(originalType.type, implementationType.type);
          }
          if (implementationType.kind === graphql_1.Kind.NON_NULL_TYPE) {
            return this.isTypeValidImplementation(originalType, implementationType.type);
          }
          switch (originalType.kind) {
            case graphql_1.Kind.NAMED_TYPE:
              if (implementationType.kind === graphql_1.Kind.NAMED_TYPE) {
                const originalTypeName = originalType.name.value;
                const implementationTypeName = implementationType.name.value;
                if (originalTypeName === implementationTypeName) {
                  return true;
                }
                const concreteTypes = this.abstractToConcreteTypeNames.get(originalTypeName);
                if (!concreteTypes) {
                  return false;
                }
                return concreteTypes.has(implementationTypeName);
              }
              return false;
            default:
              if (implementationType.kind === graphql_1.Kind.LIST_TYPE) {
                return this.isTypeValidImplementation(originalType.type, implementationType.type);
              }
              return false;
          }
        }
        getAndValidateImplementedInterfaces(container) {
          var _a;
          const interfaces = [];
          if (container.interfaces.size < 1) {
            return interfaces;
          }
          const implementationErrorsMap = /* @__PURE__ */ new Map();
          for (const interfaceName of container.interfaces) {
            interfaces.push((0, utils_1.stringToNamedTypeNode)(interfaceName));
            const interfaceContainer = this.parents.get(interfaceName);
            if (!interfaceContainer) {
              this.errors.push((0, errors_1.undefinedTypeError)(interfaceName));
              continue;
            }
            if (interfaceContainer.kind !== graphql_1.Kind.INTERFACE_TYPE_DEFINITION) {
              throw (0, errors_1.incompatibleParentKindFatalError)(interfaceName, graphql_1.Kind.INTERFACE_TYPE_DEFINITION, interfaceContainer.kind);
            }
            const implementationErrors = {
              invalidFieldImplementations: /* @__PURE__ */ new Map(),
              unimplementedFields: []
            };
            let hasErrors = false;
            for (const [fieldName, interfaceField] of interfaceContainer.fields) {
              let hasNestedErrors = false;
              const containerField = container.fields.get(fieldName);
              if (!containerField) {
                hasErrors = true;
                implementationErrors.unimplementedFields.push(fieldName);
                continue;
              }
              const invalidFieldImplementation = {
                invalidAdditionalArguments: /* @__PURE__ */ new Set(),
                invalidImplementedArguments: [],
                originalResponseType: (0, merge_1.printTypeNode)(interfaceField.node.type),
                unimplementedArguments: /* @__PURE__ */ new Set()
              };
              if (!this.isTypeValidImplementation(interfaceField.node.type, containerField.node.type)) {
                hasErrors = true;
                hasNestedErrors = true;
                invalidFieldImplementation.implementedResponseType = (0, merge_1.printTypeNode)(containerField.node.type);
              }
              const handledArguments = /* @__PURE__ */ new Set();
              for (const [argumentName, inputValueContainer] of interfaceField.arguments) {
                const interfaceArgument = inputValueContainer.node;
                handledArguments.add(argumentName);
                const containerArgument = (_a = containerField.arguments.get(argumentName)) == null ? void 0 : _a.node;
                if (!containerArgument) {
                  hasErrors = true;
                  hasNestedErrors = true;
                  invalidFieldImplementation.unimplementedArguments.add(argumentName);
                  continue;
                }
                const actualType = (0, merge_1.printTypeNode)(containerArgument.type);
                const expectedType = (0, merge_1.printTypeNode)(interfaceArgument.type);
                if (expectedType !== actualType) {
                  hasErrors = true;
                  hasNestedErrors = true;
                  invalidFieldImplementation.invalidImplementedArguments.push({ actualType, argumentName, expectedType });
                }
              }
              for (const [argumentName, inputValueContainer] of containerField.arguments) {
                const argumentNode = inputValueContainer.node;
                if (handledArguments.has(argumentName)) {
                  continue;
                }
                if (argumentNode.type.kind !== graphql_1.Kind.NON_NULL_TYPE) {
                  continue;
                }
                hasErrors = true;
                hasNestedErrors = true;
                invalidFieldImplementation.invalidAdditionalArguments.add(argumentName);
              }
              if (hasNestedErrors) {
                implementationErrors.invalidFieldImplementations.set(fieldName, invalidFieldImplementation);
              }
            }
            if (hasErrors) {
              implementationErrorsMap.set(interfaceName, implementationErrors);
            }
          }
          if (implementationErrorsMap.size) {
            this.errors.push((0, errors_1.unimplementedInterfaceFieldsError)(container.node.name.value, (0, utils_3.kindToTypeString)(container.kind), implementationErrorsMap));
          }
          return interfaces;
        }
        mergeArguments(container, args, errors, argumentNames) {
          for (const argumentContainer of container.arguments.values()) {
            const missingSubgraphs = (0, utils_3.getEntriesNotInHashSet)(container.subgraphs, argumentContainer.subgraphs);
            const argumentName = argumentContainer.node.name.value;
            if (missingSubgraphs.length > 0) {
              if (argumentContainer.requiredSubgraphs.size > 0) {
                errors.push({
                  argumentName,
                  missingSubgraphs,
                  requiredSubgraphs: [...argumentContainer.requiredSubgraphs]
                });
              }
              continue;
            }
            argumentContainer.node.defaultValue = argumentContainer.includeDefaultValue ? argumentContainer.node.defaultValue : void 0;
            args.push((0, utils_1.pushPersistedDirectivesAndGetNode)(argumentContainer));
            if (argumentNames) {
              argumentNames.push(argumentName);
            }
          }
        }
        addValidExecutableDirectiveDefinition(directiveName, directiveContainer, definitions) {
          if (!this.executableDirectives.has(directiveName)) {
            return;
          }
          if (this.subgraphs.length !== directiveContainer.subgraphs.size) {
            return;
          }
          directiveContainer.node.locations = (0, utils_1.setToNameNodeArray)(directiveContainer.executableLocations);
          if (!directiveContainer.arguments) {
            definitions.push(directiveContainer.node);
            return;
          }
          const args = [];
          const errors = [];
          this.mergeArguments(directiveContainer, args, errors);
          if (errors.length > 0) {
            this.errors.push((0, errors_1.invalidRequiredArgumentsError)(string_constants_1.DIRECTIVE_DEFINITION, directiveName, errors));
            return;
          }
          directiveContainer.node.arguments = args;
          definitions.push(directiveContainer.node);
        }
        getMergedFieldDefinitionNode(fieldContainer, parentTypeName) {
          if (!fieldContainer.arguments) {
            return fieldContainer.node;
          }
          (0, utils_1.pushPersistedDirectivesAndGetNode)(fieldContainer);
          const fieldName = fieldContainer.node.name.value;
          const fieldPath = `${parentTypeName}.${fieldName}`;
          const args = [];
          const errors = [];
          const argumentNames = [];
          this.mergeArguments(fieldContainer, args, errors, argumentNames);
          if (errors.length > 0) {
            this.errors.push((0, errors_1.invalidRequiredArgumentsError)(string_constants_1.FIELD, fieldPath, errors));
          } else if (argumentNames.length > 0) {
            this.argumentConfigurations.push({
              argumentNames,
              fieldName,
              typeName: parentTypeName
            });
          }
          fieldContainer.node.arguments = args;
          return fieldContainer.node;
        }
        // the deprecated directive with the longest reason is kept
        upsertDeprecatedDirective(directive, deprecatedDirectiveContainer) {
          if (!directive.arguments || directive.arguments.length < 1) {
            deprecatedDirectiveContainer.directive = directive;
            return;
          }
          if (directive.arguments.length !== 1) {
            this.errors.push(errors_1.invalidDeprecatedDirectiveError);
            return;
          }
          const reasonArgument = directive.arguments[0].value;
          if (reasonArgument.kind !== graphql_1.Kind.STRING) {
            this.errors.push(errors_1.invalidDeprecatedDirectiveError);
            return;
          }
          if (deprecatedDirectiveContainer.reason && reasonArgument.value.length < deprecatedDirectiveContainer.reason.length) {
            return;
          }
          deprecatedDirectiveContainer.reason = reasonArgument.value;
          deprecatedDirectiveContainer.directive = directive;
        }
        // tags with the same name string are merged
        mergeTagDirectives(directive, map) {
          if (!directive.arguments || directive.arguments.length !== 1) {
            this.errors.push(errors_1.invalidTagDirectiveError);
            return;
          }
          const nameArgument = directive.arguments[0].value;
          if (nameArgument.kind !== graphql_1.Kind.STRING) {
            this.errors.push(errors_1.invalidTagDirectiveError);
            return;
          }
          map.set(nameArgument.value, directive);
        }
        extractPersistedDirectives(directives, container) {
          if (directives.length < 1) {
            return container;
          }
          for (const directive of directives) {
            const directiveName = directive.name.value;
            if (!this.persistedDirectives.has(directiveName)) {
              continue;
            }
            if (directiveName == string_constants_1.DEPRECATED) {
              this.upsertDeprecatedDirective(directive, container.deprecated);
              continue;
            }
            if (directiveName === string_constants_1.TAG) {
              this.mergeTagDirectives(directive, container.tags);
              continue;
            }
            const existingDirectives = container.directives.get(directiveName);
            if (!existingDirectives) {
              container.directives.set(directiveName, [directive]);
              continue;
            }
            const definition = (0, utils_3.getOrThrowError)(this.directiveDefinitions, directiveName, "directiveDefinitions");
            if (!definition.node.repeatable) {
              continue;
            }
            existingDirectives.push(directive);
          }
          return container;
        }
        isFieldResolvableByEntityAncestor(entityAncestors, fieldSubgraphs, parentTypeName) {
          if (!this.graph.hasNode(parentTypeName)) {
            return false;
          }
          for (const entityAncestorName of entityAncestors) {
            const path = `${entityAncestorName}.${parentTypeName}`;
            if (entityAncestorName !== parentTypeName && this.graphPaths.get(path)) {
              return true;
            }
            if (entityAncestorName === parentTypeName) {
              const hasOverlap = (0, utils_3.doSetsHaveAnyOverlap)(fieldSubgraphs, (0, utils_3.getOrThrowError)(this.entities, entityAncestorName, string_constants_1.ENTITIES).subgraphs);
              this.graphPaths.set(path, hasOverlap);
              return hasOverlap;
            }
            if ((0, utils_3.hasSimplePath)(this.graph, entityAncestorName, parentTypeName)) {
              this.graphPaths.set(path, true);
              return true;
            }
            this.graphPaths.set(path, false);
          }
          return false;
        }
        shouldEvaluateObjectLike(rootTypeFieldSubgraphs, parentTypeName) {
          for (const subgraph of rootTypeFieldSubgraphs) {
            const evaluatedObjectLikes = this.evaluatedObjectLikesBySubgraph.get(subgraph);
            if (evaluatedObjectLikes && evaluatedObjectLikes.has(parentTypeName)) {
              continue;
            }
            return true;
          }
          return false;
        }
        isFieldExternalInAllMutualSubgraphs(subgraphs, fieldContainer) {
          const mutualSubgraphs = (0, utils_3.getAllMutualEntries)(subgraphs, fieldContainer.subgraphs);
          if (mutualSubgraphs.size < 1) {
            return false;
          }
          for (const mutualSubgraph of mutualSubgraphs) {
            const isExternal = fieldContainer.subgraphsByExternal.get(mutualSubgraph);
            if (isExternal) {
              continue;
            }
            return false;
          }
          return true;
        }
        updateEvaluatedSubgraphOccurrences(rootTypeFieldSubgraphs, objectSubgraphs, entityAncestors, parentTypeName) {
          const mutualSubgraphs = (0, utils_3.getAllMutualEntries)(rootTypeFieldSubgraphs, objectSubgraphs);
          if (mutualSubgraphs.size > 0) {
            for (const mutualSubgraph of mutualSubgraphs) {
              const evaluatedObjects = this.evaluatedObjectLikesBySubgraph.get(mutualSubgraph);
              if (evaluatedObjects) {
                evaluatedObjects.add(parentTypeName);
              } else {
                this.evaluatedObjectLikesBySubgraph.set(mutualSubgraph, /* @__PURE__ */ new Set([parentTypeName]));
              }
            }
          }
          for (const entityAncestor of entityAncestors) {
            const entityContainer = (0, utils_3.getOrThrowError)(this.parents, entityAncestor, string_constants_1.PARENTS);
            const mutualEntityAncestorRootTypeFieldSubgraphs = (0, utils_3.getAllMutualEntries)(rootTypeFieldSubgraphs, entityContainer.subgraphs);
            const mutualEntityAncestorSubgraphs = (0, utils_3.getAllMutualEntries)(mutualEntityAncestorRootTypeFieldSubgraphs, objectSubgraphs);
            for (const mutualSubgraph of mutualEntityAncestorSubgraphs) {
              const objects = this.evaluatedObjectLikesBySubgraph.get(mutualSubgraph);
              if (objects) {
                objects.add(parentTypeName);
              } else {
                this.evaluatedObjectLikesBySubgraph.set(mutualSubgraph, /* @__PURE__ */ new Set([parentTypeName]));
              }
            }
          }
        }
        evaluateResolvabilityOfObject(parentContainer, rootTypeFieldData, currentFieldPath, evaluatedObjectLikes, entityAncestors, isParentAbstract = false) {
          const parentTypeName = parentContainer.node.name.value;
          if (evaluatedObjectLikes.has(parentTypeName)) {
            return;
          }
          if (!this.shouldEvaluateObjectLike(rootTypeFieldData.subgraphs, parentTypeName)) {
            evaluatedObjectLikes.add(parentTypeName);
            return;
          }
          for (const [fieldName, fieldContainer] of parentContainer.fields) {
            const fieldNamedTypeName = fieldContainer.namedTypeName;
            if (string_constants_1.ROOT_TYPES.has(fieldNamedTypeName)) {
              continue;
            }
            if (evaluatedObjectLikes.has(fieldNamedTypeName)) {
              continue;
            }
            if (this.isFieldExternalInAllMutualSubgraphs(rootTypeFieldData.subgraphs, fieldContainer)) {
              continue;
            }
            this.updateEvaluatedSubgraphOccurrences(rootTypeFieldData.subgraphs, parentContainer.subgraphs, entityAncestors, parentTypeName);
            evaluatedObjectLikes.add(parentTypeName);
            const isFieldResolvable = (0, utils_3.doSetsHaveAnyOverlap)(rootTypeFieldData.subgraphs, fieldContainer.subgraphs) || this.isFieldResolvableByEntityAncestor(entityAncestors, fieldContainer.subgraphs, parentTypeName);
            const newCurrentFieldPath = currentFieldPath + (isParentAbstract ? " " : ".") + fieldName;
            const entity = this.entities.get(fieldNamedTypeName);
            if (isFieldResolvable) {
              if (constants_1.BASE_SCALARS.has(fieldNamedTypeName)) {
                continue;
              }
              const childContainer2 = (0, utils_3.getOrThrowError)(this.parents, fieldNamedTypeName, string_constants_1.PARENTS);
              switch (childContainer2.kind) {
                case graphql_1.Kind.ENUM_TYPE_DEFINITION:
                case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
                  continue;
                case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
                  this.evaluateResolvabilityOfObject(childContainer2, rootTypeFieldData, newCurrentFieldPath, evaluatedObjectLikes, entity ? [...entityAncestors, fieldNamedTypeName] : [...entityAncestors]);
                  continue;
                case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
                case graphql_1.Kind.UNION_TYPE_DEFINITION:
                  this.evaluateResolvabilityOfAbstractType(fieldNamedTypeName, childContainer2.kind, rootTypeFieldData, newCurrentFieldPath, evaluatedObjectLikes, entity ? [...entityAncestors, fieldNamedTypeName] : [...entityAncestors], fieldContainer.subgraphs);
                  continue;
                default:
                  this.errors.push((0, errors_1.unexpectedObjectResponseType)(newCurrentFieldPath, (0, utils_3.kindToTypeString)(childContainer2.kind)));
                  continue;
              }
            }
            if (constants_1.BASE_SCALARS.has(fieldNamedTypeName)) {
              this.errors.push((0, errors_1.unresolvableFieldError)(rootTypeFieldData, fieldName, [...fieldContainer.subgraphs], newCurrentFieldPath, parentTypeName));
              continue;
            }
            const childContainer = (0, utils_3.getOrThrowError)(this.parents, fieldNamedTypeName, string_constants_1.PARENTS);
            switch (childContainer.kind) {
              case graphql_1.Kind.ENUM_TYPE_DEFINITION:
              case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
                this.errors.push((0, errors_1.unresolvableFieldError)(rootTypeFieldData, fieldName, [...fieldContainer.subgraphs], newCurrentFieldPath, parentTypeName));
                continue;
              case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
              case graphql_1.Kind.UNION_TYPE_DEFINITION:
              case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
                this.errors.push((0, errors_1.unresolvableFieldError)(rootTypeFieldData, fieldName, [...fieldContainer.subgraphs], newCurrentFieldPath + string_constants_1.SELECTION_REPRESENTATION, parentTypeName));
                continue;
              default:
                this.errors.push((0, errors_1.unexpectedObjectResponseType)(newCurrentFieldPath, (0, utils_3.kindToTypeString)(childContainer.kind)));
            }
          }
        }
        evaluateResolvabilityOfAbstractType(abstractTypeName, abstractKind, rootTypeFieldData, currentFieldPath, evaluatedObjectLikes, entityAncestors, parentSubgraphs) {
          if (evaluatedObjectLikes.has(abstractTypeName)) {
            return;
          }
          evaluatedObjectLikes.add(abstractTypeName);
          const concreteTypeNames = this.abstractToConcreteTypeNames.get(abstractTypeName);
          if (!concreteTypeNames) {
            (0, errors_1.noConcreteTypesForAbstractTypeError)((0, utils_3.kindToTypeString)(abstractKind), abstractTypeName);
            return;
          }
          for (const concreteTypeName of concreteTypeNames) {
            if (evaluatedObjectLikes.has(concreteTypeName)) {
              continue;
            }
            const concreteParentContainer = (0, utils_3.getOrThrowError)(this.parents, concreteTypeName, string_constants_1.PARENTS);
            if (concreteParentContainer.kind !== graphql_1.Kind.OBJECT_TYPE_DEFINITION) {
              throw (0, errors_1.unexpectedParentKindErrorMessage)(concreteTypeName, "Object", (0, utils_3.kindToTypeString)(concreteParentContainer.kind));
            }
            if (!(0, utils_3.doSetsHaveAnyOverlap)(concreteParentContainer.subgraphs, parentSubgraphs)) {
              continue;
            }
            const entity = this.entities.get(concreteTypeName);
            this.evaluateResolvabilityOfObject(concreteParentContainer, rootTypeFieldData, currentFieldPath + ` ... on ` + concreteTypeName, evaluatedObjectLikes, entity ? [...entityAncestors, concreteTypeName] : [...entityAncestors], true);
          }
        }
        federate() {
          this.populateMultiGraphAndRenameOperations(this.subgraphs);
          const factory = this;
          for (const subgraph of this.subgraphs) {
            this.isCurrentSubgraphVersionTwo = subgraph.isVersionTwo;
            this.currentSubgraphName = subgraph.name;
            this.keyFieldsByParentTypeName = subgraph.keyFieldsByParentTypeName;
            (0, subgraph_1.walkSubgraphToFederate)(subgraph.definitions, factory);
          }
          const definitions = [];
          for (const [directiveName, directiveContainer] of this.directiveDefinitions) {
            if (this.persistedDirectives.has(directiveName)) {
              definitions.push(directiveContainer.node);
              continue;
            }
            this.addValidExecutableDirectiveDefinition(directiveName, directiveContainer, definitions);
          }
          for (const [typeName, extension] of this.extensions) {
            if (extension.isRootType && !this.parents.has(typeName)) {
              this.upsertParentNode((0, ast_1.objectTypeExtensionNodeToMutableDefinitionNode)(extension.node));
            }
            const baseObject = this.parents.get(typeName);
            if (!baseObject) {
              this.errors.push((0, errors_1.noBaseTypeExtensionError)(typeName));
              continue;
            }
            if (baseObject.kind !== graphql_1.Kind.OBJECT_TYPE_DEFINITION) {
              throw (0, errors_1.incompatibleParentKindFatalError)(typeName, graphql_1.Kind.OBJECT_TYPE_DEFINITION, baseObject.kind);
            }
            for (const [extensionFieldName, extensionFieldContainer] of extension.fields) {
              const baseFieldContainer = baseObject.fields.get(extensionFieldName);
              if (!baseFieldContainer) {
                baseObject.fields.set(extensionFieldName, extensionFieldContainer);
                continue;
              }
              if (baseFieldContainer.isShareable && extensionFieldContainer.isShareable) {
                (0, utils_1.setLongestDescriptionForNode)(baseFieldContainer.node, extensionFieldContainer.node.description);
                (0, utils_3.addIterableValuesToSet)(extensionFieldContainer.subgraphs, baseFieldContainer.subgraphs);
                continue;
              }
              const parent = this.shareableErrorTypeNames.get(typeName);
              if (parent) {
                parent.add(extensionFieldName);
                continue;
              }
              this.shareableErrorTypeNames.set(typeName, /* @__PURE__ */ new Set([extensionFieldName]));
            }
            for (const interfaceName of extension.interfaces) {
              baseObject.interfaces.add(interfaceName);
            }
          }
          for (const [parentTypeName, children] of this.shareableErrorTypeNames) {
            const parent = (0, utils_3.getOrThrowError)(this.parents, parentTypeName, string_constants_1.PARENTS);
            if (parent.kind !== graphql_1.Kind.OBJECT_TYPE_DEFINITION) {
              throw (0, errors_1.incompatibleParentKindFatalError)(parentTypeName, graphql_1.Kind.OBJECT_TYPE_DEFINITION, parent.kind);
            }
            this.errors.push((0, errors_1.shareableFieldDefinitionsError)(parent, children));
          }
          const objectLikeContainersWithInterfaces = [];
          for (const parentContainer of this.parents.values()) {
            const parentTypeName = parentContainer.node.name.value;
            switch (parentContainer.kind) {
              case graphql_1.Kind.ENUM_TYPE_DEFINITION:
                const values = [];
                const mergeMethod = this.getEnumMergeMethod(parentTypeName);
                for (const enumValueContainer of parentContainer.values.values()) {
                  (0, utils_1.pushPersistedDirectivesAndGetNode)(enumValueContainer);
                  switch (mergeMethod) {
                    case utils_2.MergeMethod.CONSISTENT:
                      if (enumValueContainer.appearances < parentContainer.appearances) {
                        this.errors.push((0, errors_1.incompatibleSharedEnumError)(parentTypeName));
                      }
                      values.push(enumValueContainer.node);
                      break;
                    case utils_2.MergeMethod.INTERSECTION:
                      if (enumValueContainer.appearances === parentContainer.appearances) {
                        values.push(enumValueContainer.node);
                      }
                      break;
                    default:
                      values.push(enumValueContainer.node);
                      break;
                  }
                }
                parentContainer.node.values = values;
                definitions.push((0, utils_1.pushPersistedDirectivesAndGetNode)(parentContainer));
                break;
              case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
                const inputValues = [];
                for (const inputValueContainer of parentContainer.fields.values()) {
                  (0, utils_1.pushPersistedDirectivesAndGetNode)(inputValueContainer);
                  if (parentContainer.appearances === inputValueContainer.appearances) {
                    inputValues.push(inputValueContainer.node);
                  } else if ((0, type_merging_1.isTypeRequired)(inputValueContainer.node.type)) {
                    this.errors.push((0, errors_1.federationRequiredInputFieldError)(parentTypeName, inputValueContainer.node.name.value));
                    break;
                  }
                }
                parentContainer.node.fields = inputValues;
                definitions.push((0, utils_1.pushPersistedDirectivesAndGetNode)(parentContainer));
                break;
              case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
                const interfaceFields = [];
                for (const fieldContainer of parentContainer.fields.values()) {
                  interfaceFields.push(this.getMergedFieldDefinitionNode(fieldContainer, parentTypeName));
                }
                parentContainer.node.fields = interfaceFields;
                (0, utils_1.pushPersistedDirectivesAndGetNode)(parentContainer);
                if (parentContainer.interfaces.size > 0) {
                  objectLikeContainersWithInterfaces.push(parentContainer);
                } else {
                  definitions.push(parentContainer.node);
                }
                break;
              case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
                const fields = [];
                for (const fieldContainer of parentContainer.fields.values()) {
                  fields.push(this.getMergedFieldDefinitionNode(fieldContainer, parentTypeName));
                }
                parentContainer.node.fields = fields;
                (0, utils_1.pushPersistedDirectivesAndGetNode)(parentContainer);
                if (parentContainer.interfaces.size > 0) {
                  objectLikeContainersWithInterfaces.push(parentContainer);
                } else {
                  definitions.push(parentContainer.node);
                }
                break;
              case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
                definitions.push((0, utils_1.pushPersistedDirectivesAndGetNode)(parentContainer));
                break;
              case graphql_1.Kind.UNION_TYPE_DEFINITION:
                const types = [];
                for (const memberName of parentContainer.members) {
                  types.push((0, utils_1.stringToNamedTypeNode)(memberName));
                }
                parentContainer.node.types = types;
                definitions.push((0, utils_1.pushPersistedDirectivesAndGetNode)(parentContainer));
                break;
            }
          }
          for (const container of objectLikeContainersWithInterfaces) {
            container.node.interfaces = this.getAndValidateImplementedInterfaces(container);
            definitions.push(container.node);
          }
          if (!this.parents.has(string_constants_1.QUERY)) {
            this.errors.push(errors_1.noQueryRootTypeError);
          }
          if (this.errors.length > 0) {
            return { errors: this.errors };
          }
          for (const rootTypeName of string_constants_1.ROOT_TYPES) {
            const rootTypeContainer = this.parents.get(rootTypeName);
            if (!rootTypeContainer || rootTypeContainer.kind !== graphql_1.Kind.OBJECT_TYPE_DEFINITION) {
              continue;
            }
            if (this.errors.length > 0) {
              break;
            }
            const evaluatedRootScalarsAndEnums = new Set(constants_1.BASE_SCALARS);
            for (const [rootTypeFieldName, rootTypeFieldContainer] of rootTypeContainer.fields) {
              const rootTypeFieldNamedTypeName = rootTypeFieldContainer.namedTypeName;
              if (evaluatedRootScalarsAndEnums.has(rootTypeFieldNamedTypeName)) {
                continue;
              }
              if (!this.shouldEvaluateObjectLike(rootTypeFieldContainer.subgraphs, rootTypeFieldNamedTypeName)) {
                continue;
              }
              const childContainer = (0, utils_3.getOrThrowError)(this.parents, rootTypeFieldNamedTypeName, string_constants_1.PARENTS);
              const fieldPath = `${rootTypeName}.${rootTypeFieldName}`;
              const rootTypeFieldData = {
                fieldName: rootTypeFieldName,
                fieldTypeNodeString: (0, merge_1.printTypeNode)(rootTypeFieldContainer.node.type),
                path: fieldPath,
                typeName: rootTypeName,
                subgraphs: rootTypeFieldContainer.subgraphs
              };
              switch (childContainer.kind) {
                case graphql_1.Kind.ENUM_TYPE_DEFINITION:
                case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
                  evaluatedRootScalarsAndEnums.add(rootTypeFieldNamedTypeName);
                  continue;
                case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
                  this.evaluateResolvabilityOfObject(childContainer, rootTypeFieldData, fieldPath, /* @__PURE__ */ new Set(), this.entities.has(rootTypeFieldNamedTypeName) ? [rootTypeFieldNamedTypeName] : []);
                  continue;
                case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
                case graphql_1.Kind.UNION_TYPE_DEFINITION:
                  this.evaluateResolvabilityOfAbstractType(rootTypeFieldNamedTypeName, childContainer.kind, rootTypeFieldData, fieldPath, /* @__PURE__ */ new Set(), this.entities.has(rootTypeFieldNamedTypeName) ? [rootTypeFieldNamedTypeName] : [], rootTypeFieldContainer.subgraphs);
                  continue;
                default:
                  this.errors.push((0, errors_1.unexpectedObjectResponseType)(fieldPath, (0, utils_3.kindToTypeString)(childContainer.kind)));
              }
            }
          }
          if (this.errors.length > 0) {
            return { errors: this.errors };
          }
          const newAst = {
            kind: graphql_1.Kind.DOCUMENT,
            definitions
          };
          return {
            federationResult: {
              argumentConfigurations: this.argumentConfigurations,
              federatedGraphAST: newAst,
              federatedGraphSchema: (0, graphql_1.buildASTSchema)(newAst)
            }
          };
        }
      };
      exports2.FederationFactory = FederationFactory;
      function federateSubgraphs2(subgraphs) {
        if (subgraphs.length < 1) {
          throw errors_1.minimumSubgraphRequirementError;
        }
        const normalizedSubgraphs = [];
        const validationErrors = [];
        const subgraphNames = /* @__PURE__ */ new Set();
        const nonUniqueSubgraphNames = /* @__PURE__ */ new Set();
        const invalidNameErrorMessages = [];
        for (let i2 = 0; i2 < subgraphs.length; i2++) {
          const subgraph = subgraphs[i2];
          const name2 = subgraph.name || `subgraph-${i2}-${Date.now()}`;
          if (!subgraph.name) {
            invalidNameErrorMessages.push((0, errors_1.invalidSubgraphNameErrorMessage)(i2, name2));
          } else {
            (0, subgraph_1.validateSubgraphName)(subgraph.name, subgraphNames, nonUniqueSubgraphNames);
          }
          const { errors, normalizationResult } = (0, normalization_factory_1.normalizeSubgraph)(subgraph.definitions);
          if (errors) {
            validationErrors.push((0, errors_1.subgraphValidationError)(name2, errors));
            continue;
          }
          if (!normalizationResult) {
            validationErrors.push((0, errors_1.subgraphValidationError)(name2, [errors_1.subgraphValidationFailureErrorMessage]));
            continue;
          }
          normalizedSubgraphs.push({
            definitions: normalizationResult.subgraphAST,
            keyFieldsByParentTypeName: normalizationResult.keyFieldsByParentTypeName,
            isVersionTwo: normalizationResult.isVersionTwo,
            name: name2,
            operationTypes: normalizationResult.operationTypes,
            url: subgraph.url
          });
        }
        const allErrors = [];
        if (invalidNameErrorMessages.length > 0 || nonUniqueSubgraphNames.size > 0) {
          allErrors.push((0, errors_1.invalidSubgraphNamesError)([...nonUniqueSubgraphNames], invalidNameErrorMessages));
        }
        allErrors.push(...validationErrors);
        if (allErrors.length > 0) {
          return { errors: allErrors };
        }
        const federationFactory = new FederationFactory(normalizedSubgraphs);
        return federationFactory.federate();
      }
      exports2.federateSubgraphs = federateSubgraphs2;
    }
  });

  // ../../composition/dist/subgraph/field-configuration.js
  var require_field_configuration = __commonJS({
    "../../composition/dist/subgraph/field-configuration.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports2, "__esModule", { value: true });
    }
  });

  // ../../composition/dist/index.js
  var require_dist = __commonJS({
    "../../composition/dist/index.js"(exports2) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o2, k2, desc);
      } : function(o2, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o2[k2] = m[k];
      });
      var __exportStar2 = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p2 in m)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding2(exports3, m, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      __exportStar2(require_normalization_factory(), exports2);
      __exportStar2(require_federation_factory(), exports2);
      __exportStar2(require_utils2(), exports2);
      __exportStar2(require_field_configuration(), exports2);
      __exportStar2(require_subgraph(), exports2);
      __exportStar2(require_errors(), exports2);
      __exportStar2(require_utils(), exports2);
      __exportStar2(require_utils3(), exports2);
      __exportStar2(require_ast(), exports2);
      __exportStar2(require_type_merging(), exports2);
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    federateSubgraphs: () => federateSubgraphs
  });
  init_dirname();
  init_buffer2();
  init_process2();
  var import_composition = __toESM(require_dist());
  init_graphql2();
  function federateSubgraphs(subgraphs) {
    const { federationResult, errors } = (0, import_composition.federateSubgraphs)(subgraphs.map(({ schema, name: name2, url }) => {
      let definitions;
      try {
        definitions = parse(schema);
      } catch (e2) {
        throw new Error(`could not parse schema for Graph ${name2}: ${e2}`);
      }
      return {
        definitions,
        name: name2,
        url
      };
    }));
    if (errors && errors.length > 0) {
      throw new Error(`could not federate schema: ${errors.map((e2) => e2.message).join(", ")}`);
    }
    return {
      argumentConfigurations: federationResult.argumentConfigurations,
      ast: print(federationResult.federatedGraphAST),
      schema: printSchema(federationResult.federatedGraphSchema)
    };
  }
  return __toCommonJS(src_exports);
})();
/*! Bundled license information:

@jspm/core/nodelibs/browser/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
